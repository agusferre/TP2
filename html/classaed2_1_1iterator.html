<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<title>My Project: aed2::iterator Class Reference</title>

<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css" />

<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>

</head>
<body>
<div id="top"><!-- do not remove this div! -->


<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  
  
  <td style="padding-left: 0.5em;">
   <div id="projectname">My Project
   
   </div>
   
  </td>
  
  
  
 </tr>
 </tbody>
</table>
</div>

<!-- Generated by Doxygen 1.7.6.1 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Friends</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

  <div id="nav-path" class="navpath">
    <ul>
      <li class="navelem"><a class="el" href="namespaceaed2.html">aed2</a>      </li>
      <li class="navelem"><a class="el" href="classaed2_1_1iterator.html">iterator</a>      </li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#friends">Friends</a>  </div>
  <div class="headertitle">
<div class="title">aed2::iterator Class Reference</div>  </div>
</div><!--header-->
<div class="contents">
<!-- doxytag: class="aed2::iterator" -->
<p>Parte del módulo que implementa los iteradores que permiten la modificación de los significados.  
 <a href="classaed2_1_1iterator.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="map2_8h_source.html">map2.h</a>&gt;</code></p>

<p><a href="classaed2_1_1iterator-members.html">List of all members.</a></p>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classaed2_1_1iterator_1_1const__iterator.html">const_iterator</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Parte del módulo que implementa los iteradores que no permiten la modificación de los significados.  <a href="classaed2_1_1iterator_1_1const__iterator.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><b>InnerNode</b></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Estructura (privada) de un nodo no cabecera del árbol red-black. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classaed2_1_1iterator_1_1iterator.html">iterator</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Parte del módulo que implementa los iteradores que permiten la modificación de los significados.  <a href="classaed2_1_1iterator_1_1iterator.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><b>Node</b></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Estructura (privada) de un nodo del árbol red-black. <br/></td></tr>
<tr><td colspan="2"><h2><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classaed2_1_1iterator_1_1iterator.html">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classaed2_1_1iterator.html#aab34e7001b3ee3ce79da8ea24d7e6351">insert_or_assign</a> (<a class="el" href="classaed2_1_1iterator_1_1const__iterator.html">const_iterator</a> hint, const value_type &amp;value)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classaed2_1_1iterator_1_1iterator.html">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classaed2_1_1iterator.html#af131c4b0d89978372a0c8ce38bf8f33e">insert_or_assign</a> (const value_type &amp;value)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classaed2_1_1iterator_1_1iterator.html">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classaed2_1_1iterator.html#adf371aaec9e68bd4a4d5a889d0b6b679">erase</a> (<a class="el" href="classaed2_1_1iterator_1_1const__iterator.html">const_iterator</a> pos)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Elimina el valor apuntado por {pos}.  <a href="#adf371aaec9e68bd4a4d5a889d0b6b679"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classaed2_1_1iterator.html#a0a0e62b2a2c0fb98f431164c66a6e388">erase</a> (const Key &amp;key)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Elimina el valor cuya clave es {key}.  <a href="#a0a0e62b2a2c0fb98f431164c66a6e388"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classaed2_1_1iterator.html#ac98b533e402839c99d33d3118906c38f">clear</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Vacia el diccionario.  <a href="#ac98b533e402839c99d33d3118906c38f"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classaed2_1_1iterator.html#a8ec2215b2dfaf6ddd57b1e0b00d8d3d2">swap</a> (<a class="el" href="classaed2_1_1map.html">map</a> &amp;other)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Intercambia el contenido de {*this} y {other}.  <a href="#a8ec2215b2dfaf6ddd57b1e0b00d8d3d2"></a><br/></td></tr>
<tr><td colspan="2"><div class="groupHeader">Construcción, asignación y destrucción</div></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classaed2_1_1iterator.html#ab55f7bc4639e905d66935b56995a5b1f">map</a> (Compare c=Compare())</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Crea un diccionario vacio.  <a href="#ab55f7bc4639e905d66935b56995a5b1f"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classaed2_1_1iterator.html#aee42bcaf809b71168f4266e1d05971e2">map</a> (const <a class="el" href="classaed2_1_1map.html">map</a> &amp;other)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor por copia.  <a href="#aee42bcaf809b71168f4266e1d05971e2"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class iterator &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classaed2_1_1iterator.html#aa44ca788a300603c5fae2d192e11f249">map</a> (<a class="el" href="classaed2_1_1iterator_1_1iterator.html">iterator</a> first, <a class="el" href="classaed2_1_1iterator_1_1iterator.html">iterator</a> last, Compare c=Compare())</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Crea un diccionario con los elementos del rango [{first}, {last})  <a href="#aa44ca788a300603c5fae2d192e11f249"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classaed2_1_1map.html">map</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classaed2_1_1iterator.html#a7cafd02350b04f7546fa29c17168c18b">operator=</a> (<a class="el" href="classaed2_1_1map.html">map</a> other)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Operador de asignación.  <a href="#a7cafd02350b04f7546fa29c17168c18b"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classaed2_1_1iterator.html#a769d0ae1a1c7ed66acdd321e44fcd0e1">~map</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Destructor.  <a href="#a769d0ae1a1c7ed66acdd321e44fcd0e1"></a><br/></td></tr>
<tr><td colspan="2"><div class="groupHeader">Busqueda y acceso a los valores</div></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const Meaning &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classaed2_1_1iterator.html#a8cca919f59850908ef421db454db835a">at</a> (const Key &amp;key) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Devuelve el significado asociado a {key}.  <a href="#a8cca919f59850908ef421db454db835a"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">Meaning &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classaed2_1_1iterator.html#ac0459c685868fba041b9be2cde974119">at</a> (const Key &amp;key)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">Meaning &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classaed2_1_1iterator.html#af74d214f3278d8cd6b3a5a721e173fa3">operator[]</a> (const Key &amp;key)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Devuelve el significado asociado a {key}, asegurando su existencia.  <a href="#af74d214f3278d8cd6b3a5a721e173fa3"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classaed2_1_1iterator_1_1iterator.html">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classaed2_1_1iterator.html#a3d87256cbfc935a932677092ec57f49a">find</a> (const Key &amp;key)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Devuelve un iterador a la posicion del valor con clave {key}.  <a href="#a3d87256cbfc935a932677092ec57f49a"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classaed2_1_1iterator_1_1const__iterator.html">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classaed2_1_1iterator.html#aebe4bb3359d2223a83a0afe5f92e0c84">find</a> (const Key &amp;key) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classaed2_1_1iterator_1_1const__iterator.html">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classaed2_1_1iterator.html#afbdd3bc5a5dc3565f3c743d6d5e82d73">lower_bound</a> (const Key &amp;key) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Devuelve un iterador al primer valor con clave mayor o igual a {key}.  <a href="#afbdd3bc5a5dc3565f3c743d6d5e82d73"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classaed2_1_1iterator_1_1iterator.html">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classaed2_1_1iterator.html#ac48bbb54fea69c1fb4c093eecda02c5a">lower_bound</a> (const Key &amp;key)</td></tr>
<tr><td colspan="2"><div class="groupHeader">Tamaño del diccionario</div></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classaed2_1_1iterator.html#a2ce99485deecad0038a82bb98167c3a9">empty</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Indica si el diccionario esta vacío.  <a href="#a2ce99485deecad0038a82bb98167c3a9"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classaed2_1_1iterator.html#a75fda8b0f9b937433d0872573dc6c27f">size</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Devuelve la cantidad de valores en el diccionario.  <a href="#a75fda8b0f9b937433d0872573dc6c27f"></a><br/></td></tr>
<tr><td colspan="2"><div class="groupHeader">Inserción, borrado y modificación</div></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classaed2_1_1iterator_1_1iterator.html">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classaed2_1_1iterator.html#ab9446668ad5619115b6c4a10eac83d68">insert</a> (<a class="el" href="classaed2_1_1iterator_1_1const__iterator.html">const_iterator</a> hint, const value_type &amp;value)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserta {value} en el diccionario.  <a href="#ab9446668ad5619115b6c4a10eac83d68"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab23378eb6149357e1a2167e9804eb6e3"></a><!-- doxytag: member="aed2::iterator::insert_fixup" ref="ab23378eb6149357e1a2167e9804eb6e3" args="(iterator it, const value_type &amp;value)" -->
void&#160;</td><td class="memItemRight" valign="bottom"><b>insert_fixup</b> (<a class="el" href="classaed2_1_1iterator_1_1iterator.html">iterator</a> it, const value_type &amp;value)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af4e447a081108196ecdf39b16ecb5303"></a><!-- doxytag: member="aed2::iterator::rotate" ref="af4e447a081108196ecdf39b16ecb5303" args="(iterator it)" -->
void left&#160;</td><td class="memItemRight" valign="bottom"><b>rotate</b> (<a class="el" href="classaed2_1_1iterator_1_1iterator.html">iterator</a> it)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a191eae4f3f076914ff1560a2fa833b70"></a><!-- doxytag: member="aed2::iterator::rotate" ref="a191eae4f3f076914ff1560a2fa833b70" args="(iterator it)" -->
void right&#160;</td><td class="memItemRight" valign="bottom"><b>rotate</b> (<a class="el" href="classaed2_1_1iterator_1_1iterator.html">iterator</a> it)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classaed2_1_1iterator_1_1iterator.html">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classaed2_1_1iterator.html#aa1870e8bfa4f45c82fa1ee076846922b">insert</a> (const value_type &amp;value)</td></tr>
<tr><td colspan="2"><div class="groupHeader">Recorridos e iteradores</div></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classaed2_1_1iterator_1_1iterator.html">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classaed2_1_1iterator.html#af8901de173468531c58458b581d345a6">begin</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Devuelve un iterador al primer valor del diccionario.  <a href="#af8901de173468531c58458b581d345a6"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classaed2_1_1iterator_1_1const__iterator.html">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classaed2_1_1iterator.html#a102b6014e02bf9a1ed551f9cdea027d0">begin</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classaed2_1_1iterator_1_1const__iterator.html">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classaed2_1_1iterator.html#a89cca73bd2e4df39de7c412c441d6da1">cbegin</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classaed2_1_1iterator_1_1iterator.html">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classaed2_1_1iterator.html#a67caf9468be999e9be96b7add5d79946">end</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Devuelve un iterador apuntando a la posición pasando-el-ultimo del diccionario.  <a href="#a67caf9468be999e9be96b7add5d79946"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classaed2_1_1iterator_1_1const__iterator.html">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classaed2_1_1iterator.html#ae08e4f49cbbd2dfa756609aceb431633">end</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classaed2_1_1iterator_1_1const__iterator.html">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classaed2_1_1iterator.html#a2d0d226485d9280d16a739d0b9dae525">cend</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">reverse_iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classaed2_1_1iterator.html#a296638725dce2fc10316d18563eb3131">rbegin</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Devuelve un iterador al primer valor del diccionario, en un recorrido al revés.  <a href="#a296638725dce2fc10316d18563eb3131"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const_reverse_iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classaed2_1_1iterator.html#ae6b990a72769289b9cd0236a91c3b43f">rbegin</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const_reverse_iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classaed2_1_1iterator.html#aa4b6ce667258581859351db42cfd3ee4">crbegin</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">reverse_iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classaed2_1_1iterator.html#a0007a7962bc6aca8dca78c2a49bd581d">rend</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Devuelve un iterador apuntando a la posición pasando-el-ultimo del diccionario, en un recorrido al revés.  <a href="#a0007a7962bc6aca8dca78c2a49bd581d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const_reverse_iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classaed2_1_1iterator.html#a1230bf2063ce100c830129a24dea854d">rend</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const_reverse_iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classaed2_1_1iterator.html#a2e31ad7ded06c666c6c37c5d30bb41af">crend</a> ()</td></tr>
<tr><td colspan="2"><h2><a name="friends"></a>
Friends</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a67171474c4da6cc8efe0c7fafefd2b2d"></a><!-- doxytag: member="aed2::iterator::iterator" ref="a67171474c4da6cc8efe0c7fafefd2b2d" args="" -->
class&#160;</td><td class="memItemRight" valign="bottom"><b>iterator</b></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac220ce1c155db1ac44146c12d178056f"></a><!-- doxytag: member="aed2::iterator::const_iterator" ref="ac220ce1c155db1ac44146c12d178056f" args="" -->
class&#160;</td><td class="memItemRight" valign="bottom"><b>const_iterator</b></td></tr>
</table>
<hr/><a name="details" id="details"></a><h2>Detailed Description</h2>
<div class="textblock"><p>Parte del módulo que implementa los iteradores que permiten la modificación de los significados. </p>
<p>Cuando el iterador se encuentra asociado a un diccionario `d`, el rango válido de valores del iterador va desde el primer valor de `d` hasta una posición (ficticia) que se encuentra pasando-el-último. Esta posición no tiene definido un valor para el `operator*`, y se usa para indicar el fin del recorrido.</p>
<p>Este es un iterador que sigue el estándar de C++, y por lo tanto es compatible con la bilioteca de algoritmos. Asimismo, las operaciones siguen el protocolo estándar, con lo cual no es necesiario describir el resultado de las mismas. Sin embargo, siendo este un TP, vamos a describir el comportamiento en el marco conceptual de la materia.</p>
<dl class="user"><dt><b>Aspectos generales de aliasing</b></dt><dd>Vale remarcar que un iterador tiene dos estados posibles:<ol type="1">
<li>Es valido: cuando esta asociado a un diccionario y apunta a un valor existente del diccionario,</li>
<li>Es inválido: cuando esta asociado a un diccionario (que quiza ya no es accesible), pero el valor al que apunta fue eliminado.</li>
<li>Es nulo: cuando no está asociado a ningún diccionario; sirve como análogo de `nullptr`. </li>
</ol>
</dd></dl>
<dl class="user"><dt><b>Se explica con</b></dt><dd>IteradorBidireccional(Diccionario({Key}, {Meaning}), tupla({Key}, {Meaning}))</dd></dl>
<dl class="attention"><dt><b>Attention:</b></dt><dd>En caso de usar los iteradores como punteros, se desaconseja el uso de la posicion pasando-el-ultimo como valor nulo, ya que queda invalidada luego de aplicar la operación <a class="el" href="classaed2_1_1map.html#a43ddb71cc91e5c6021a7a1f243d6cc4a" title="Intercambia el contenido de {*this} y {other}.">aed2::map::swap</a>. Conviene usar el iterador nulo (que, lamentablemente, es independiente del diccionario).</dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd>[Documentacion estándar de iteradores bidireccionales](<a href="http://en.cppreference.com/w/cpp/concept/BidirectionalIterator">http://en.cppreference.com/w/cpp/concept/BidirectionalIterator</a>) </dd></dl>
</div><hr/><h2>Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="a769d0ae1a1c7ed66acdd321e44fcd0e1"></a><!-- doxytag: member="aed2::iterator::~map" ref="a769d0ae1a1c7ed66acdd321e44fcd0e1" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classaed2_1_1iterator.html#a769d0ae1a1c7ed66acdd321e44fcd0e1">aed2::iterator::~map</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Destructor. </p>
<p>{completar}</p>
<dl class="pre"><dt><b>Precondition:</b></dt><dd>{true} </dd></dl>
<dl class="post"><dt><b>Postcondition:</b></dt><dd>{true}</dd></dl>
<p>{(({*this}))}</p>
<dl class="attention"><dt><b>Attention:</b></dt><dd>Como se explicita, esta función no hace nada, porque no tiene un objetivo funcional. De hecho, su implementación es innecesaria bajo la hipótesis de infinitud de memoria (que muchos sistemas de especificación, e.g. nuestros TADs, asumen por simplicidad). Sin embargo, esta función tiene un comportamiento real y es liberar la memoria usada. Claramente, esta funcionalidad depende del sistema en que estemos trabajando. Suponiendo que tuvieramos acceso a la implementación de las tablas de memoria del sistema operativo (o al mapa de memoria de la computadora), podríamos expresar la funcionalidad estableciendo la liberación de la memoria inicializa iterador con <a class="el" href="classaed2_1_1iterator.html#af8901de173468531c58458b581d345a6" title="Devuelve un iterador al primer valor del diccionario.">begin()</a> mientras hay Siguiente, borra (siguiente) </dd></dl>

</div>
</div>
<hr/><h2>Member Function Documentation</h2>
<a class="anchor" id="a8cca919f59850908ef421db454db835a"></a><!-- doxytag: member="aed2::iterator::at" ref="a8cca919f59850908ef421db454db835a" args="(const Key &amp;key) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const Meaning&amp; <a class="el" href="classaed2_1_1iterator.html#a8cca919f59850908ef421db454db835a">aed2::iterator::at</a> </td>
          <td>(</td>
          <td class="paramtype">const Key &amp;&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Devuelve el significado asociado a {key}. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>clave a buscar. </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt><b>Return values:</b></dt><dd>
  <table class="retval">
    <tr><td class="paramname">res</td><td>referencia al significado asociado a {key}.</td></tr>
  </table>
  </dd>
</dl>
<p>{completar}</p>
<dl class="pre"><dt><b>Precondition:</b></dt><dd>{def?(key,*this)}</dd></dl>
<dl class="post"><dt><b>Postcondition:</b></dt><dd>{res  obtener(key,*this)}</dd></dl>
<p>{((({*this})  ({*this}))}</p>
<dl class="remark"><dt><b>Remarks:</b></dt><dd>Esta función, que se asemeja más a la forma de programar propuesta en AED2 que al estándar C++, fue incluida en el estándar C++11. Antes era obligación recurrir a la función find. Comienza en la raiz y si el valor es menor sigue la recursión hacia la izquierda, sino a la derecha, hasta que encuentra un nodo con la clave (key) pasada por parámetro y devuelve el significado almacenado en ese nodo. </dd></dl>

</div>
</div>
<a class="anchor" id="ac0459c685868fba041b9be2cde974119"></a><!-- doxytag: member="aed2::iterator::at" ref="ac0459c685868fba041b9be2cde974119" args="(const Key &amp;key)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Meaning&amp; <a class="el" href="classaed2_1_1iterator.html#a8cca919f59850908ef421db454db835a">aed2::iterator::at</a> </td>
          <td>(</td>
          <td class="paramtype">const Key &amp;&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>

</div>
</div>
<a class="anchor" id="af8901de173468531c58458b581d345a6"></a><!-- doxytag: member="aed2::iterator::begin" ref="af8901de173468531c58458b581d345a6" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classaed2_1_1iterator_1_1iterator.html">iterator</a> <a class="el" href="classaed2_1_1iterator.html#af8901de173468531c58458b581d345a6">aed2::iterator::begin</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Devuelve un iterador al primer valor del diccionario. </p>
<p>{no hay}</p>
<dl class="retval"><dt><b>Return values:</b></dt><dd>
  <table class="retval">
    <tr><td class="paramname">res</td><td>iterador al primer valor</td></tr>
  </table>
  </dd>
</dl>
<dl class="pre"><dt><b>Precondition:</b></dt><dd>{true} </dd></dl>
<dl class="post"><dt><b>Postcondition:</b></dt><dd>{res  CrearItMod(inorder(*this))}</dd></dl>
<p>{(1)} Inicia un iterador en header-&gt;izq. </p>

</div>
</div>
<a class="anchor" id="a102b6014e02bf9a1ed551f9cdea027d0"></a><!-- doxytag: member="aed2::iterator::begin" ref="a102b6014e02bf9a1ed551f9cdea027d0" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classaed2_1_1iterator_1_1const__iterator.html">const_iterator</a> <a class="el" href="classaed2_1_1iterator.html#af8901de173468531c58458b581d345a6">aed2::iterator::begin</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>

</div>
</div>
<a class="anchor" id="a89cca73bd2e4df39de7c412c441d6da1"></a><!-- doxytag: member="aed2::iterator::cbegin" ref="a89cca73bd2e4df39de7c412c441d6da1" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classaed2_1_1iterator_1_1const__iterator.html">const_iterator</a> <a class="el" href="classaed2_1_1iterator.html#a89cca73bd2e4df39de7c412c441d6da1">aed2::iterator::cbegin</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>

</div>
</div>
<a class="anchor" id="a2d0d226485d9280d16a739d0b9dae525"></a><!-- doxytag: member="aed2::iterator::cend" ref="a2d0d226485d9280d16a739d0b9dae525" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classaed2_1_1iterator_1_1const__iterator.html">const_iterator</a> <a class="el" href="classaed2_1_1iterator.html#a2d0d226485d9280d16a739d0b9dae525">aed2::iterator::cend</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>

</div>
</div>
<a class="anchor" id="ac98b533e402839c99d33d3118906c38f"></a><!-- doxytag: member="aed2::iterator::clear" ref="ac98b533e402839c99d33d3118906c38f" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classaed2_1_1iterator.html#ac98b533e402839c99d33d3118906c38f">aed2::iterator::clear</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Vacia el diccionario. </p>
<p>{Se invalidan todos los iteradores asociados a {*this}, con excepcion de aquellos que apuntan a la posicion pasando-el-ultimo.}</p>
<dl class="pre"><dt><b>Precondition:</b></dt><dd>{true} </dd></dl>
<dl class="post"><dt><b>Postcondition:</b></dt><dd>{{*this}  vacio}</dd></dl>
<p>{(({*this}))} Mientras count sea distinto de 0, va eliminando con la función erase todos los elementos del árbol. </p>

</div>
</div>
<a class="anchor" id="aa4b6ce667258581859351db42cfd3ee4"></a><!-- doxytag: member="aed2::iterator::crbegin" ref="aa4b6ce667258581859351db42cfd3ee4" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const_reverse_iterator <a class="el" href="classaed2_1_1iterator.html#aa4b6ce667258581859351db42cfd3ee4">aed2::iterator::crbegin</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>

</div>
</div>
<a class="anchor" id="a2e31ad7ded06c666c6c37c5d30bb41af"></a><!-- doxytag: member="aed2::iterator::crend" ref="a2e31ad7ded06c666c6c37c5d30bb41af" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const_reverse_iterator <a class="el" href="classaed2_1_1iterator.html#a2e31ad7ded06c666c6c37c5d30bb41af">aed2::iterator::crend</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>

</div>
</div>
<a class="anchor" id="a2ce99485deecad0038a82bb98167c3a9"></a><!-- doxytag: member="aed2::iterator::empty" ref="a2ce99485deecad0038a82bb98167c3a9" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classaed2_1_1iterator.html#a2ce99485deecad0038a82bb98167c3a9">aed2::iterator::empty</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Indica si el diccionario esta vacío. </p>
<dl class="retval"><dt><b>Return values:</b></dt><dd>
  <table class="retval">
    <tr><td class="paramname">res</td><td>denota true si y solo si el diccionario está vacío</td></tr>
  </table>
  </dd>
</dl>
<dl class="pre"><dt><b>Precondition:</b></dt><dd>{true} </dd></dl>
<dl class="post"><dt><b>Postcondition:</b></dt><dd>{res   ?(claves(*this))}</dd></dl>
<p>{(1)} Inicia en raíz, y si la misma es distinta de null devuelve false. </p>

</div>
</div>
<a class="anchor" id="a67caf9468be999e9be96b7add5d79946"></a><!-- doxytag: member="aed2::iterator::end" ref="a67caf9468be999e9be96b7add5d79946" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classaed2_1_1iterator_1_1iterator.html">iterator</a> <a class="el" href="classaed2_1_1iterator.html#a67caf9468be999e9be96b7add5d79946">aed2::iterator::end</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Devuelve un iterador apuntando a la posición pasando-el-ultimo del diccionario. </p>
<p>{no hay}</p>
<dl class="retval"><dt><b>Return values:</b></dt><dd>
  <table class="retval">
    <tr><td class="paramname">res</td><td>iterador a la posicion pasando-al-ultimo</td></tr>
  </table>
  </dd>
</dl>
<dl class="pre"><dt><b>Precondition:</b></dt><dd>{true} </dd></dl>
<dl class="post"><dt><b>Postcondition:</b></dt><dd>{res  CrearItMod(inorder(*this),  )}</dd></dl>
<p>{(1)}</p>
<p>Inicia un iterador en nullptr. </p>

</div>
</div>
<a class="anchor" id="ae08e4f49cbbd2dfa756609aceb431633"></a><!-- doxytag: member="aed2::iterator::end" ref="ae08e4f49cbbd2dfa756609aceb431633" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classaed2_1_1iterator_1_1const__iterator.html">const_iterator</a> <a class="el" href="classaed2_1_1iterator.html#a67caf9468be999e9be96b7add5d79946">aed2::iterator::end</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>

</div>
</div>
<a class="anchor" id="adf371aaec9e68bd4a4d5a889d0b6b679"></a><!-- doxytag: member="aed2::iterator::erase" ref="adf371aaec9e68bd4a4d5a889d0b6b679" args="(const_iterator pos)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classaed2_1_1iterator_1_1iterator.html">iterator</a> <a class="el" href="classaed2_1_1iterator.html#adf371aaec9e68bd4a4d5a889d0b6b679">aed2::iterator::erase</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classaed2_1_1iterator_1_1const__iterator.html">const_iterator</a>&#160;</td>
          <td class="paramname"><em>pos</em></td><td>)</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Elimina el valor apuntado por {pos}. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">pos</td><td>iterador apuntando al valor a eliminar. </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt><b>Return values:</b></dt><dd>
  <table class="retval">
    <tr><td class="paramname">res</td><td>iterador apuntando al primer valor con clave mayor a {pos} (o {this}-&gt;<a class="el" href="classaed2_1_1iterator.html#a67caf9468be999e9be96b7add5d79946" title="Devuelve un iterador apuntando a la posición pasando-el-ultimo del diccionario.">end()</a>, si dicho valor no existe).</td></tr>
  </table>
  </dd>
</dl>
<p>{complertar}.</p>
<dl class="pre"><dt><b>Precondition:</b></dt><dd>{HayMas?(pos)} </dd></dl>
<dl class="post"><dt><b>Postcondition:</b></dt><dd>{Eliminar(pos)}</dd></dl>
<p>{</p>
<ul>
<li>Peor caso: (({*pos}) + (({*this})))</li>
<li>Peor caso amortizado: (({*pos})) } </li>
</ul>

</div>
</div>
<a class="anchor" id="a0a0e62b2a2c0fb98f431164c66a6e388"></a><!-- doxytag: member="aed2::iterator::erase" ref="a0a0e62b2a2c0fb98f431164c66a6e388" args="(const Key &amp;key)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classaed2_1_1iterator.html#adf371aaec9e68bd4a4d5a889d0b6b679">aed2::iterator::erase</a> </td>
          <td>(</td>
          <td class="paramtype">const Key &amp;&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Elimina el valor cuya clave es {key}. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>clave del elemento a eliminar</td></tr>
  </table>
  </dd>
</dl>
<p>{completar}</p>
<dl class="pre"><dt><b>Precondition:</b></dt><dd>{*this  *this0  def?(key, *this)} </dd></dl>
<dl class="post"><dt><b>Postcondition:</b></dt><dd>{*this  borrar(key, *this0)}</dd></dl>
<p>{(({*pos}) + (({*this}))  ({*this}))} </p>

</div>
</div>
<a class="anchor" id="a3d87256cbfc935a932677092ec57f49a"></a><!-- doxytag: member="aed2::iterator::find" ref="a3d87256cbfc935a932677092ec57f49a" args="(const Key &amp;key)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classaed2_1_1iterator_1_1iterator.html">iterator</a> <a class="el" href="classaed2_1_1iterator.html#a3d87256cbfc935a932677092ec57f49a">aed2::iterator::find</a> </td>
          <td>(</td>
          <td class="paramtype">const Key &amp;&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Devuelve un iterador a la posicion del valor con clave {key}. </p>
<p>Retorna un iterador apuntando a la posicion del valor con clave {key}. Si dicho valor no existe, porque la clave no fue definida, entonces el iterador retornado apunta a la posición <em>pasando-el-ultimo</em>.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>clave a buscar </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt><b>Return values:</b></dt><dd>
  <table class="retval">
    <tr><td class="paramname">res</td><td>iterador apuntando al valor con clave {key} (o a {this}-&gt;<a class="el" href="classaed2_1_1iterator.html#a67caf9468be999e9be96b7add5d79946" title="Devuelve un iterador apuntando a la posición pasando-el-ultimo del diccionario.">end()</a> si dicho elemento no existe)</td></tr>
  </table>
  </dd>
</dl>
<p>{Hay aliasing entre el actual(iterador) y obtener(key, *this)}</p>
<dl class="pre"><dt><b>Precondition:</b></dt><dd>{true} </dd></dl>
<dl class="post"><dt><b>Postcondition:</b></dt><dd>{def?(key, *this)  res  crearitAux(key,inorder(*this))}</dd></dl>
<p>{((({*this}))  ({*this}))}</p>
<dl class="attention"><dt><b>Attention:</b></dt><dd>Si el objetivo es insertar un valor con clave {key} de acuerdo a alguna condición, entonces conviene usar <a class="el" href="classaed2_1_1map.html#a3399d36fdd5a880b494f3a5795d3f18f" title="Devuelve un iterador al primer valor con clave mayor o igual a {key}.">aed2::map::lower_bound</a> para la búsqueda, dado que el resultado puede ser usado como hint, mejorando la complejidad de la inserción.<ul>
<li>Inicia el iterador en el hijo izquierdo de header.</li>
<li>Avanzo hasta que la clave sea key o, en caso de que no esté definida, hasta la posición pasando-el-último.</li>
<li>Devuelve el Iterador en esa posición. </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="aebe4bb3359d2223a83a0afe5f92e0c84"></a><!-- doxytag: member="aed2::iterator::find" ref="aebe4bb3359d2223a83a0afe5f92e0c84" args="(const Key &amp;key) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classaed2_1_1iterator_1_1const__iterator.html">const_iterator</a> <a class="el" href="classaed2_1_1iterator.html#a3d87256cbfc935a932677092ec57f49a">aed2::iterator::find</a> </td>
          <td>(</td>
          <td class="paramtype">const Key &amp;&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>

</div>
</div>
<a class="anchor" id="ab9446668ad5619115b6c4a10eac83d68"></a><!-- doxytag: member="aed2::iterator::insert" ref="ab9446668ad5619115b6c4a10eac83d68" args="(const_iterator hint, const value_type &amp;value)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classaed2_1_1iterator_1_1iterator.html">iterator</a> <a class="el" href="classaed2_1_1iterator.html#ab9446668ad5619115b6c4a10eac83d68">aed2::iterator::insert</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classaed2_1_1iterator_1_1const__iterator.html">const_iterator</a>&#160;</td>
          <td class="paramname"><em>hint</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const value_type &amp;&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Inserta {value} en el diccionario. </p>
<p>Inserta un <b>nuevo</b> valor en el diccionario. Si {*this} ya tiene un valor con clave {value}.first, entonces la función no tiene efectos. El iterador de retorno apunta al elemento recien insertado (o aquel que previno la insercion).</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>valor a insertar </td></tr>
    <tr><td class="paramname">hint</td><td>iterador apuntando al diccionario. Se espera que apunte al minimo valor mayor o igual a {value}.first (i.e., a lower_bound({value}.first)). Igualmente, la función es robusta y funciona correctamente aunque esto no ocurra. </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt><b>Return values:</b></dt><dd>
  <table class="retval">
    <tr><td class="paramname">res</td><td>iterador apuntando al elemento insertado o que previno la inserción</td></tr>
  </table>
  </dd>
</dl>
<p>{hay aliasing???}</p>
<dl class="pre"><dt><b>Precondition:</b></dt><dd>{true} </dd></dl>
<dl class="post"><dt><b>Postcondition:</b></dt><dd>{def?(value.first, *this)  crearitAux(*this.first, inorder(*this) )   def?(value.first, *this)  res  agregar(crearIt(inorder(*this)), value)}</dd></dl>
<p>{</p>
<ul>
<li>Peor caso: ((({*this}))  ({*this})  ({value}))</li>
<li>Si {hint} apunta al primer valor con clave al menos {value}.first (o {this}-&gt;<a class="el" href="classaed2_1_1iterator.html#a67caf9468be999e9be96b7add5d79946" title="Devuelve un iterador apuntando a la posición pasando-el-ultimo del diccionario.">end()</a> en caso de no existir): (({*this})  ({value})) amortizado. }</li>
</ul>
<dl class="attention"><dt><b>Attention:</b></dt><dd>Para garantizar que el nuevo elemento se inserte sí o sí, usar <a class="el" href="classaed2_1_1map.html#a2ef6723c183916276b0afc4a4c721475">aed2::map::insert_or_assign</a>. </dd></dl>

</div>
</div>
<a class="anchor" id="aa1870e8bfa4f45c82fa1ee076846922b"></a><!-- doxytag: member="aed2::iterator::insert" ref="aa1870e8bfa4f45c82fa1ee076846922b" args="(const value_type &amp;value)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classaed2_1_1iterator_1_1iterator.html">iterator</a> <a class="el" href="classaed2_1_1iterator.html#ab9446668ad5619115b6c4a10eac83d68">aed2::iterator::insert</a> </td>
          <td>(</td>
          <td class="paramtype">const value_type &amp;&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>

</div>
</div>
<a class="anchor" id="aab34e7001b3ee3ce79da8ea24d7e6351"></a><!-- doxytag: member="aed2::iterator::insert_or_assign" ref="aab34e7001b3ee3ce79da8ea24d7e6351" args="(const_iterator hint, const value_type &amp;value)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classaed2_1_1iterator_1_1iterator.html">iterator</a> <a class="el" href="classaed2_1_1iterator.html#aab34e7001b3ee3ce79da8ea24d7e6351">aed2::iterator::insert_or_assign</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classaed2_1_1iterator_1_1const__iterator.html">const_iterator</a>&#160;</td>
          <td class="paramname"><em>hint</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const value_type &amp;&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>{</p>
<ul>
<li>Peor caso: ((({*this}))  ({*this})  ({value}))</li>
<li>Si {hint} apunta al primer valor con clave al menos {value}.first (o {this}-&gt;<a class="el" href="classaed2_1_1iterator.html#a67caf9468be999e9be96b7add5d79946" title="Devuelve un iterador apuntando a la posición pasando-el-ultimo del diccionario.">end()</a> en caso de no existir): (({*this})  ({value})) amortizado. }</li>
</ul>
<dl class="attention"><dt><b>Attention:</b></dt><dd>Para prevenir que el nuevo valor redefina uno ya existente, usar <a class="el" href="classaed2_1_1map.html#a6941cde9a79c27f054b5c97a587a1854" title="Inserta {value} en el diccionario.">aed2::map::insert</a>. </dd></dl>
<dl class="remark"><dt><b>Remarks:</b></dt><dd>Esta función es similar al operator[], pero tiene dos ventajas y una desventaja. Las ventajas es que 1. se puede indicar un {hint} para la búsqueda y 2. no es necesario que {Meaning} tenga constructor sin parámetros. La desventaja es que la notación no es tan bonita. </dd></dl>

</div>
</div>
<a class="anchor" id="af131c4b0d89978372a0c8ce38bf8f33e"></a><!-- doxytag: member="aed2::iterator::insert_or_assign" ref="af131c4b0d89978372a0c8ce38bf8f33e" args="(const value_type &amp;value)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classaed2_1_1iterator_1_1iterator.html">iterator</a> <a class="el" href="classaed2_1_1iterator.html#aab34e7001b3ee3ce79da8ea24d7e6351">aed2::iterator::insert_or_assign</a> </td>
          <td>(</td>
          <td class="paramtype">const value_type &amp;&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>

</div>
</div>
<a class="anchor" id="afbdd3bc5a5dc3565f3c743d6d5e82d73"></a><!-- doxytag: member="aed2::iterator::lower_bound" ref="afbdd3bc5a5dc3565f3c743d6d5e82d73" args="(const Key &amp;key) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classaed2_1_1iterator_1_1const__iterator.html">const_iterator</a> <a class="el" href="classaed2_1_1iterator.html#afbdd3bc5a5dc3565f3c743d6d5e82d73">aed2::iterator::lower_bound</a> </td>
          <td>(</td>
          <td class="paramtype">const Key &amp;&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Devuelve un iterador al primer valor con clave mayor o igual a {key}. </p>
<p>Retorna un iterador apuntando a la primer posición cuyo valor tenga clave al menos {key}. Si dicho valor no existe, porque {key} es mayor a todas las claves de {*this}, entonces el iterador retornado apunta a la posición <em>pasando-el-último</em>.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>clave a buscar </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt><b>Return values:</b></dt><dd>
  <table class="retval">
    <tr><td class="paramname">res</td><td>iterador apuntando al valor con clave al menos {key} (o a {this}-&gt;<a class="el" href="classaed2_1_1iterator.html#a67caf9468be999e9be96b7add5d79946" title="Devuelve un iterador apuntando a la posición pasando-el-ultimo del diccionario.">end()</a> si dicho elemento no existe)</td></tr>
  </table>
  </dd>
</dl>
<p>{hay aliasing entre res y el sucesor inmediato de key}</p>
<dl class="pre"><dt><b>Precondition:</b></dt><dd>{true} </dd></dl>
<dl class="post"><dt><b>Postcondition:</b></dt><dd>{res  crearitAux2(key,inorder(*this))(busca en la secu inorder a key y devuelve el siguiente o null si es mayor a todas las claves)}</dd></dl>
<p>{((({*this}))  ({*this}))}</p>
<ul>
<li>Inicia el iterador en el hijo izquierdo de header.</li>
<li>Avanzo hasta que la clave sea mayor o igual a key o, en caso de que no exista ninguna, hasta la posición pasando-el-último.</li>
<li>Devuelve el Iterador en esa posición. </li>
</ul>

</div>
</div>
<a class="anchor" id="ac48bbb54fea69c1fb4c093eecda02c5a"></a><!-- doxytag: member="aed2::iterator::lower_bound" ref="ac48bbb54fea69c1fb4c093eecda02c5a" args="(const Key &amp;key)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classaed2_1_1iterator_1_1iterator.html">iterator</a> <a class="el" href="classaed2_1_1iterator.html#afbdd3bc5a5dc3565f3c743d6d5e82d73">aed2::iterator::lower_bound</a> </td>
          <td>(</td>
          <td class="paramtype">const Key &amp;&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>

</div>
</div>
<a class="anchor" id="ab55f7bc4639e905d66935b56995a5b1f"></a><!-- doxytag: member="aed2::iterator::map" ref="ab55f7bc4639e905d66935b56995a5b1f" args="(Compare c=Compare())" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classaed2_1_1iterator.html#ab55f7bc4639e905d66935b56995a5b1f">aed2::iterator::map</a> </td>
          <td>(</td>
          <td class="paramtype">Compare&#160;</td>
          <td class="paramname"><em>c</em> = <code>Compare()</code></td><td>)</td>
          <td><code> [inline, explicit]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Crea un diccionario vacio. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">c</td><td>comparador (functor de orden) a utilizar </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt><b>Return values:</b></dt><dd>
  <table class="retval">
    <tr><td class="paramname">res</td><td>diccionario recién construido</td></tr>
  </table>
  </dd>
</dl>
<dl class="pre"><dt><b>Precondition:</b></dt><dd>{true} </dd></dl>
<dl class="post"><dt><b>Postcondition:</b></dt><dd>{res  vacio()}</dd></dl>
<p>{(1)}</p>
<dl class="attention"><dt><b>Attention:</b></dt><dd>El parámetro formal  del TAD diccionario se establece en esta función.  = {c}.operator() ambos hijos de header apuntan a null, y padre de header apunta a null </dd></dl>

</div>
</div>
<a class="anchor" id="aee42bcaf809b71168f4266e1d05971e2"></a><!-- doxytag: member="aed2::iterator::map" ref="aee42bcaf809b71168f4266e1d05971e2" args="(const map &amp;other)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classaed2_1_1iterator.html#ab55f7bc4639e905d66935b56995a5b1f">aed2::iterator::map</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classaed2_1_1map.html">map</a> &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Constructor por copia. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>diccionario a copiar </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt><b>Return values:</b></dt><dd>
  <table class="retval">
    <tr><td class="paramname">res</td><td>diccionario recien construido</td></tr>
  </table>
  </dd>
</dl>
<dl class="pre"><dt><b>Precondition:</b></dt><dd>{true} </dd></dl>
<dl class="post"><dt><b>Postcondition:</b></dt><dd>{res  other}</dd></dl>
<p>{(({other}))}</p>
<dl class="attention"><dt><b>Attention:</b></dt><dd>El parámetro formal  del TAD diccionario se establece en esta función.  es igual al operator() del comparador de {other} <a class="el" href="classaed2_1_1iterator.html#af8901de173468531c58458b581d345a6" title="Devuelve un iterador al primer valor del diccionario.">begin()</a> iterador en other. mientras haya Siguiente en el iterador de other, insertar siguiente, y avanzar. </dd></dl>

</div>
</div>
<a class="anchor" id="aa44ca788a300603c5fae2d192e11f249"></a><!-- doxytag: member="aed2::iterator::map" ref="aa44ca788a300603c5fae2d192e11f249" args="(iterator first, iterator last, Compare c=Compare())" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class iterator &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classaed2_1_1iterator.html#ab55f7bc4639e905d66935b56995a5b1f">aed2::iterator::map</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classaed2_1_1iterator_1_1iterator.html">iterator</a>&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classaed2_1_1iterator_1_1iterator.html">iterator</a>&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Compare&#160;</td>
          <td class="paramname"><em>c</em> = <code>Compare()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Crea un diccionario con los elementos del rango [{first}, {last}) </p>
<dl class=""><dt><b>Template Parameters:</b></dt><dd>
  <table class="">
    <tr><td class="paramname">iterator</td><td>clase del iterador a recorrer</td></tr>
  </table>
  </dd>
</dl>
<dl class="user"><dt><b>Requerimientos sobre el tipo {iterator}</b></dt><dd>El tipo {iterator} debe tener todas las funcionalidades de un <em>InputIterator</em> de C++. En términos de la materia, vamos a suponer que {iterator} se explica con el TAD Iterador Unidireccional(puntero(C), {value_type}) para alguna colección de tipo C.</dd></dl>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">first</td><td>iterador al primer elemento del rango </td></tr>
    <tr><td class="paramname">last</td><td>iterador pasando el ultimo elemento del rango </td></tr>
    <tr><td class="paramname">c</td><td>comparador a utilizar </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt><b>Return values:</b></dt><dd>
  <table class="retval">
    <tr><td class="paramname">res</td><td>diccionario recien construido</td></tr>
  </table>
  </dd>
</dl>
<p>{{first} y {last} son iteradores que recorren la misma secuencia definida por una colección.}</p>
<dl class="pre"><dt><b>Precondition:</b></dt><dd>{last} debe ser alcanzable desde {first} y en el rango [{first}, {last}) no pueden haber valores repetidos.</dd></dl>
<p>{coleccion({first})  coleccion({last})  esSufijo(Siguientes({last}), Siguientes({first}))  (Siguientes({first})  Siguientes({last}))} </p>
<dl class="post"><dt><b>Postcondition:</b></dt><dd>Los valores definidos en {res} son aquellos que aparecen en [{first}, {last})</dd></dl>
<p>{( k: {Key})( s: {Meaning}) (def?({res}, k)  significado({res}, k)  s  esta((k,s), Siguientes({first})  Siguientes({last}))) } </p>
<p>{</p>
<ul>
<li>En el peor caso: (({res})  ((({res}))  ({res}) + ({res})))</li>
<li>Si el rango [{first}, {last}) está ordenado: (({res})  (({res})+ ({res}))) }</li>
</ul>
<dl class="attention"><dt><b>Attention:</b></dt><dd>El parámetro formal  del TAD diccionario se establece en esta función.  = {c}.operator()</dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd>[Documentación de InputIterator](<a href="http://en.cppreference.com/w/cpp/concept/InputIterator">http://en.cppreference.com/w/cpp/concept/InputIterator</a>) </dd></dl>

</div>
</div>
<a class="anchor" id="a7cafd02350b04f7546fa29c17168c18b"></a><!-- doxytag: member="aed2::iterator::operator=" ref="a7cafd02350b04f7546fa29c17168c18b" args="(map other)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classaed2_1_1map.html">map</a>&amp; aed2::iterator::operator= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classaed2_1_1map.html">map</a>&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Operador de asignación. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>diccionario a copiar </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt><b>Return values:</b></dt><dd>
  <table class="retval">
    <tr><td class="paramname">res</td><td>referencia a *this</td></tr>
  </table>
  </dd>
</dl>
<p>{no hay}</p>
<dl class="pre"><dt><b>Precondition:</b></dt><dd>{true} </dd></dl>
<dl class="post"><dt><b>Postcondition:</b></dt><dd>{res  other}</dd></dl>
<p>{(({*this})  ({other}))}</p>
<dl class="note"><dt><b>Note:</b></dt><dd>Es importante remarcar que no se realiza ninguna comparación entre los elementos. -destruir this<ul>
<li>this-&gt;map(other) </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="af74d214f3278d8cd6b3a5a721e173fa3"></a><!-- doxytag: member="aed2::iterator::operator[]" ref="af74d214f3278d8cd6b3a5a721e173fa3" args="(const Key &amp;key)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Meaning&amp; aed2::iterator::operator[] </td>
          <td>(</td>
          <td class="paramtype">const Key &amp;&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Devuelve el significado asociado a {key}, asegurando su existencia. </p>
<p>Devuelve el significado asociado a {key}. Si {key} no está definido en {*this}, entonces se inserta un nuevo valor con clave {key} y significado {Meaning}(). De esta forma, podemos usar `operator[]` para definir nuevos valores o modificar los existentes.</p>
<p>Ejemplo: </p>
<div class="fragment"><pre class="fragment"> {.cpp}
 <a class="code" href="classaed2_1_1map.html" title="Modulo que implementa un diccionario.">aed2::map&lt;int, int&gt;</a> d;
 d[1] = 2;      <span class="comment">//define 1 -&gt; 2</span>
 d[1] = 3;      <span class="comment">//redefine 1 -&gt; 3</span>

 <a class="code" href="classaed2_1_1map.html" title="Modulo que implementa un diccionario.">aed2::map&lt;int, int&gt;</a> m;
 <span class="keywordflow">if</span>(m[1] == 3) {...} <span class="comment">//posible bug: define 1 -&gt; basura (que puede o no ser 3).</span>
</pre></div><dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>clave a buscar. </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt><b>Return values:</b></dt><dd>
  <table class="retval">
    <tr><td class="paramname">res</td><td>referencia al significado asociado a {key}.</td></tr>
  </table>
  </dd>
</dl>
<dl class="user"><dt><b>Requerimientos sobre el tipo {Meaning}</b></dt><dd>Requiere que {Meaning} tenga un constructor sin parámetros con complejidad (<em>c</em>)</dd></dl>
<p>{hay aliasing entre res y obtener(key, *this)}</p>
<dl class="pre"><dt><b>Precondition:</b></dt><dd>{true} </dd></dl>
<dl class="post"><dt><b>Postcondition:</b></dt><dd>{def?(key, *this)  res  obtener(key, *this)}</dd></dl>
<p>{((({*this}))  ({*this}) + <em>x</em>) donde</p>
<ul>
<li><em>x</em> = 1 si def?(<em>self</em>, {key}), y</li>
<li><em>x</em> = <em>c</em> en caso contrario.} Comienza en la raiz y si el valor es menor sigue la recursión hacia la izquierda, sino a la derecha, hasta que encuentra un nodo con la clave (key) pasada por parámetro y devuelve el significado almacenado en ese nodo, o en el caso que la clave no esté definida, la define con el significado default y además incrementa en uno count. </li>
</ul>

</div>
</div>
<a class="anchor" id="a296638725dce2fc10316d18563eb3131"></a><!-- doxytag: member="aed2::iterator::rbegin" ref="a296638725dce2fc10316d18563eb3131" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">reverse_iterator <a class="el" href="classaed2_1_1iterator.html#a296638725dce2fc10316d18563eb3131">aed2::iterator::rbegin</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Devuelve un iterador al primer valor del diccionario, en un recorrido al revés. </p>
<p>{no hay}</p>
<dl class="retval"><dt><b>Return values:</b></dt><dd>
  <table class="retval">
    <tr><td class="paramname">res</td><td>iterador a la primer posicion en un recorrido al revés</td></tr>
  </table>
  </dd>
</dl>
<dl class="pre"><dt><b>Precondition:</b></dt><dd>{true} </dd></dl>
<dl class="post"><dt><b>Postcondition:</b></dt><dd>{res  CrearItMod(  , postorder(*this))}</dd></dl>
<p>{(1)}</p>
<p>Inicia un reverse_iterator en el hijo derecho de header. </p>

</div>
</div>
<a class="anchor" id="ae6b990a72769289b9cd0236a91c3b43f"></a><!-- doxytag: member="aed2::iterator::rbegin" ref="ae6b990a72769289b9cd0236a91c3b43f" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const_reverse_iterator <a class="el" href="classaed2_1_1iterator.html#a296638725dce2fc10316d18563eb3131">aed2::iterator::rbegin</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>

</div>
</div>
<a class="anchor" id="a0007a7962bc6aca8dca78c2a49bd581d"></a><!-- doxytag: member="aed2::iterator::rend" ref="a0007a7962bc6aca8dca78c2a49bd581d" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">reverse_iterator <a class="el" href="classaed2_1_1iterator.html#a0007a7962bc6aca8dca78c2a49bd581d">aed2::iterator::rend</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Devuelve un iterador apuntando a la posición pasando-el-ultimo del diccionario, en un recorrido al revés. </p>
<p>{no hay}</p>
<dl class="retval"><dt><b>Return values:</b></dt><dd>
  <table class="retval">
    <tr><td class="paramname">res</td><td>iterador a la posicion pasando-al-ultimo, en un recorrido al revés</td></tr>
  </table>
  </dd>
</dl>
<dl class="pre"><dt><b>Precondition:</b></dt><dd>{true} </dd></dl>
<dl class="post"><dt><b>Postcondition:</b></dt><dd>{res  CrearItMod(postorder(*this),  )}</dd></dl>
<p>{(1)}</p>
<p>Inicia un reversre_iterator en el hijo izquierdo de header. </p>

</div>
</div>
<a class="anchor" id="a1230bf2063ce100c830129a24dea854d"></a><!-- doxytag: member="aed2::iterator::rend" ref="a1230bf2063ce100c830129a24dea854d" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const_reverse_iterator <a class="el" href="classaed2_1_1iterator.html#a0007a7962bc6aca8dca78c2a49bd581d">aed2::iterator::rend</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>

</div>
</div>
<a class="anchor" id="a75fda8b0f9b937433d0872573dc6c27f"></a><!-- doxytag: member="aed2::iterator::size" ref="a75fda8b0f9b937433d0872573dc6c27f" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t <a class="el" href="classaed2_1_1iterator.html#a75fda8b0f9b937433d0872573dc6c27f">aed2::iterator::size</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Devuelve la cantidad de valores en el diccionario. </p>
<dl class="retval"><dt><b>Return values:</b></dt><dd>
  <table class="retval">
    <tr><td class="paramname">res</td><td>cantidad de valores</td></tr>
  </table>
  </dd>
</dl>
<dl class="pre"><dt><b>Precondition:</b></dt><dd>{true} </dd></dl>
<dl class="post"><dt><b>Postcondition:</b></dt><dd>{res  #claves(*this)}</dd></dl>
<p>{(1)} Devuelve count; </p>

</div>
</div>
<a class="anchor" id="a8ec2215b2dfaf6ddd57b1e0b00d8d3d2"></a><!-- doxytag: member="aed2::iterator::swap" ref="a8ec2215b2dfaf6ddd57b1e0b00d8d3d2" args="(map &amp;other)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classaed2_1_1iterator.html#a8ec2215b2dfaf6ddd57b1e0b00d8d3d2">aed2::iterator::swap</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classaed2_1_1map.html">map</a> &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Intercambia el contenido de {*this} y {other}. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>diccionario a intercambiar con {*this}</td></tr>
  </table>
  </dd>
</dl>
<p>{Todos los iteradores, salvo aquellos que apuntan a las posiciones pasando-el-ultimo, se mantienen válidos. Aquellos iteradores que apuntan a la posición pasando-el-ultimo de {*this} pasan a apuntar a la posición pasando-el-ultimo de {other}, y viceversa.}</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>mapa a intercambiar con this</td></tr>
  </table>
  </dd>
</dl>
<dl class="pre"><dt><b>Precondition:</b></dt><dd>{<em>self</em> = {*this}  <em>oth</em> = {other}} </dd></dl>
<dl class="post"><dt><b>Postcondition:</b></dt><dd>{{*this}  <em>oth</em>  {other} = <em>self}</em> </dd></dl>
<p>{(1)}</p>
<dl class="note"><dt><b>Note:</b></dt><dd>La razón por la que se "invalidan" los iteradores pasando-el-fin tiene que ver con la forma en que se implementa el módulo (que emula la implementacion de C++). No hay ninguna razón técnica que impida mantener los iteradores pasando el fin, salvo por un pequeño ahorro de memoria y tiempo. En caso de querer usar los iteradores como punteros, se recomienda usar el iterador nulo de diccionario para representar al valor inválido, en lugar de usar los iteradores pasando-el-ultimo. </dd></dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li><a class="el" href="map2_8h_source.html">map2.h</a></li>
</ul>
</div><!-- contents -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Friends</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>



<hr class="footer"/><address class="footer"><small>
Generated on Fri Jun 2 2017 12:23:53 for My Project by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.7.6.1
</small></address>

</body>
</html>
