<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.14"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>My Project: aed2::iterator Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">My Project
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.14 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespaceaed2.html">aed2</a></li><li class="navelem"><a class="el" href="classaed2_1_1iterator.html">iterator</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#friends">Friends</a> &#124;
<a href="classaed2_1_1iterator-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">aed2::iterator Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Parte del módulo que implementa los iteradores que permiten la modificación de los significados.  
 <a href="classaed2_1_1iterator.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="map2_8h_source.html">map2.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classaed2_1_1iterator_1_1const__iterator.html">const_iterator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parte del módulo que implementa los iteradores que no permiten la modificación de los significados.  <a href="classaed2_1_1iterator_1_1const__iterator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classaed2_1_1iterator_1_1iterator.html">iterator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parte del módulo que implementa los iteradores que permiten la modificación de los significados.  <a href="classaed2_1_1iterator_1_1iterator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:afd2dbf717b48e5921b9d7f5c97bdf16e"><td class="memItemLeft" align="right" valign="top"><a id="afd2dbf717b48e5921b9d7f5c97bdf16e"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classaed2_1_1iterator.html#afd2dbf717b48e5921b9d7f5c97bdf16e">key_type</a> = Key</td></tr>
<tr class="memdesc:afd2dbf717b48e5921b9d7f5c97bdf16e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Renombre para poder acceder al tipo de las claves. Compatible con estándar C++. <br /></td></tr>
<tr class="separator:afd2dbf717b48e5921b9d7f5c97bdf16e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9616435dd0f809fcd47b1c23264c217e"><td class="memItemLeft" align="right" valign="top"><a id="a9616435dd0f809fcd47b1c23264c217e"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classaed2_1_1iterator.html#a9616435dd0f809fcd47b1c23264c217e">mapped_type</a> = Meaning</td></tr>
<tr class="memdesc:a9616435dd0f809fcd47b1c23264c217e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Renombre para poder acceder al tipo de los significados. Compatible con estándar C++. <br /></td></tr>
<tr class="separator:a9616435dd0f809fcd47b1c23264c217e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6411a2c08b2b7c52f063bef1a168acb6"><td class="memItemLeft" align="right" valign="top"><a id="a6411a2c08b2b7c52f063bef1a168acb6"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classaed2_1_1iterator.html#a6411a2c08b2b7c52f063bef1a168acb6">value_type</a> = std::pair&lt; const Key, Meaning &gt;</td></tr>
<tr class="memdesc:a6411a2c08b2b7c52f063bef1a168acb6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Renombre para poder acceder al tipo de las valores almacenados. Compatible con estándar C++. <br /></td></tr>
<tr class="separator:a6411a2c08b2b7c52f063bef1a168acb6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a958d31cebad5df42b144eb6da2d44764"><td class="memItemLeft" align="right" valign="top"><a id="a958d31cebad5df42b144eb6da2d44764"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classaed2_1_1iterator.html#a958d31cebad5df42b144eb6da2d44764">key_compare</a> = Compare</td></tr>
<tr class="memdesc:a958d31cebad5df42b144eb6da2d44764"><td class="mdescLeft">&#160;</td><td class="mdescRight">Renombre para poder acceder al tipo del comparador. Compatible con estándar C++. <br /></td></tr>
<tr class="separator:a958d31cebad5df42b144eb6da2d44764"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad4ba975de35932c0cc8af3c25a6748bf"><td class="memItemLeft" align="right" valign="top"><a id="ad4ba975de35932c0cc8af3c25a6748bf"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classaed2_1_1iterator.html#ad4ba975de35932c0cc8af3c25a6748bf">reference</a> = <a class="el" href="classaed2_1_1iterator.html#a6411a2c08b2b7c52f063bef1a168acb6">value_type</a> &amp;</td></tr>
<tr class="memdesc:ad4ba975de35932c0cc8af3c25a6748bf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Renombre para poder acceder al tipo de referencia de los valores guardados. Compatible con estándar C++. <br /></td></tr>
<tr class="separator:ad4ba975de35932c0cc8af3c25a6748bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a84dc2693b11216f8c641b5df59088283"><td class="memItemLeft" align="right" valign="top"><a id="a84dc2693b11216f8c641b5df59088283"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classaed2_1_1iterator.html#a84dc2693b11216f8c641b5df59088283">const_reference</a> = const <a class="el" href="classaed2_1_1iterator.html#a6411a2c08b2b7c52f063bef1a168acb6">value_type</a> &amp;</td></tr>
<tr class="memdesc:a84dc2693b11216f8c641b5df59088283"><td class="mdescLeft">&#160;</td><td class="mdescRight">Renombre para poder acceder al tipo de referencia constante de los valores guardados. Compatible con estándar C++. <br /></td></tr>
<tr class="separator:a84dc2693b11216f8c641b5df59088283"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a07466e8d020a80e2deb80364f28d4fa0"><td class="memItemLeft" align="right" valign="top"><a id="a07466e8d020a80e2deb80364f28d4fa0"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classaed2_1_1iterator.html#a07466e8d020a80e2deb80364f28d4fa0">pointer</a> = <a class="el" href="classaed2_1_1iterator.html#a6411a2c08b2b7c52f063bef1a168acb6">value_type</a> *</td></tr>
<tr class="memdesc:a07466e8d020a80e2deb80364f28d4fa0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Renombre para poder acceder al tipo de los punteros de los valores guardados. Compatible con estándar C++. <br /></td></tr>
<tr class="separator:a07466e8d020a80e2deb80364f28d4fa0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afa70c9577ce04d4d7b84741fababc5ac"><td class="memItemLeft" align="right" valign="top"><a id="afa70c9577ce04d4d7b84741fababc5ac"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classaed2_1_1iterator.html#afa70c9577ce04d4d7b84741fababc5ac">const_pointer</a> = const <a class="el" href="classaed2_1_1iterator.html#a6411a2c08b2b7c52f063bef1a168acb6">value_type</a> *</td></tr>
<tr class="memdesc:afa70c9577ce04d4d7b84741fababc5ac"><td class="mdescLeft">&#160;</td><td class="mdescRight">Renombre para poder acceder al tipo de los punteros de los valores constantes guardados. Compatible con estándar C++. <br /></td></tr>
<tr class="separator:afa70c9577ce04d4d7b84741fababc5ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0d460d3f76439cea3436e1113990be47"><td class="memItemLeft" align="right" valign="top"><a id="a0d460d3f76439cea3436e1113990be47"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classaed2_1_1iterator.html#a0d460d3f76439cea3436e1113990be47">size_type</a> = std::size_t</td></tr>
<tr class="memdesc:a0d460d3f76439cea3436e1113990be47"><td class="mdescLeft">&#160;</td><td class="mdescRight">Renombre para poder acceder al tipo usado para describir tamaños. Compatible con estándar C++. <br /></td></tr>
<tr class="separator:a0d460d3f76439cea3436e1113990be47"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a552af1cab9391f5af6bb86d457031329"><td class="memItemLeft" align="right" valign="top"><a id="a552af1cab9391f5af6bb86d457031329"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classaed2_1_1iterator.html#a552af1cab9391f5af6bb86d457031329">difference_type</a> = std::ptrdiff_t</td></tr>
<tr class="memdesc:a552af1cab9391f5af6bb86d457031329"><td class="mdescLeft">&#160;</td><td class="mdescRight">Renombre para poder acceder al tipo usado para describir diferencias entre punteros. Compatible con estándar C++. <br /></td></tr>
<tr class="separator:a552af1cab9391f5af6bb86d457031329"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a07b2c0fa31611e03cd019b290acd6d80"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classaed2_1_1iterator.html#a07b2c0fa31611e03cd019b290acd6d80">reverse_iterator</a> = std::reverse_iterator&lt; <a class="el" href="classaed2_1_1iterator_1_1iterator.html">iterator</a> &gt;</td></tr>
<tr class="memdesc:a07b2c0fa31611e03cd019b290acd6d80"><td class="mdescLeft">&#160;</td><td class="mdescRight">Iterador para recorrer un diccionario en orden inverso.  <a href="#a07b2c0fa31611e03cd019b290acd6d80">More...</a><br /></td></tr>
<tr class="separator:a07b2c0fa31611e03cd019b290acd6d80"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a657402896e5b5966660032f5686cc4c4"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classaed2_1_1iterator.html#a657402896e5b5966660032f5686cc4c4">const_reverse_iterator</a> = std::reverse_iterator&lt; <a class="el" href="classaed2_1_1iterator_1_1const__iterator.html">const_iterator</a> &gt;</td></tr>
<tr class="memdesc:a657402896e5b5966660032f5686cc4c4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Iterador para recorrer un diccionario constante en orden inverso.  <a href="#a657402896e5b5966660032f5686cc4c4">More...</a><br /></td></tr>
<tr class="separator:a657402896e5b5966660032f5686cc4c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:aab34e7001b3ee3ce79da8ea24d7e6351"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classaed2_1_1iterator_1_1iterator.html">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classaed2_1_1iterator.html#aab34e7001b3ee3ce79da8ea24d7e6351">insert_or_assign</a> (<a class="el" href="classaed2_1_1iterator_1_1const__iterator.html">const_iterator</a> hint, const <a class="el" href="classaed2_1_1iterator.html#a6411a2c08b2b7c52f063bef1a168acb6">value_type</a> &amp;value)</td></tr>
<tr class="separator:aab34e7001b3ee3ce79da8ea24d7e6351"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af131c4b0d89978372a0c8ce38bf8f33e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classaed2_1_1iterator_1_1iterator.html">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classaed2_1_1iterator.html#af131c4b0d89978372a0c8ce38bf8f33e">insert_or_assign</a> (const <a class="el" href="classaed2_1_1iterator.html#a6411a2c08b2b7c52f063bef1a168acb6">value_type</a> &amp;value)</td></tr>
<tr class="separator:af131c4b0d89978372a0c8ce38bf8f33e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adf371aaec9e68bd4a4d5a889d0b6b679"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classaed2_1_1iterator_1_1iterator.html">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classaed2_1_1iterator.html#adf371aaec9e68bd4a4d5a889d0b6b679">erase</a> (<a class="el" href="classaed2_1_1iterator_1_1const__iterator.html">const_iterator</a> pos)</td></tr>
<tr class="memdesc:adf371aaec9e68bd4a4d5a889d0b6b679"><td class="mdescLeft">&#160;</td><td class="mdescRight">Elimina el valor apuntado por {pos}.  <a href="#adf371aaec9e68bd4a4d5a889d0b6b679">More...</a><br /></td></tr>
<tr class="separator:adf371aaec9e68bd4a4d5a889d0b6b679"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0a0e62b2a2c0fb98f431164c66a6e388"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classaed2_1_1iterator.html#a0a0e62b2a2c0fb98f431164c66a6e388">erase</a> (const Key &amp;key)</td></tr>
<tr class="memdesc:a0a0e62b2a2c0fb98f431164c66a6e388"><td class="mdescLeft">&#160;</td><td class="mdescRight">Elimina el valor cuya clave es {key}.  <a href="#a0a0e62b2a2c0fb98f431164c66a6e388">More...</a><br /></td></tr>
<tr class="separator:a0a0e62b2a2c0fb98f431164c66a6e388"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac98b533e402839c99d33d3118906c38f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classaed2_1_1iterator.html#ac98b533e402839c99d33d3118906c38f">clear</a> ()</td></tr>
<tr class="memdesc:ac98b533e402839c99d33d3118906c38f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Vacia el diccionario.  <a href="#ac98b533e402839c99d33d3118906c38f">More...</a><br /></td></tr>
<tr class="separator:ac98b533e402839c99d33d3118906c38f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8ec2215b2dfaf6ddd57b1e0b00d8d3d2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classaed2_1_1iterator.html#a8ec2215b2dfaf6ddd57b1e0b00d8d3d2">swap</a> (<a class="el" href="classaed2_1_1map.html">map</a> &amp;other)</td></tr>
<tr class="memdesc:a8ec2215b2dfaf6ddd57b1e0b00d8d3d2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Intercambia el contenido de {*this} y {other}.  <a href="#a8ec2215b2dfaf6ddd57b1e0b00d8d3d2">More...</a><br /></td></tr>
<tr class="separator:a8ec2215b2dfaf6ddd57b1e0b00d8d3d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Construcción, asignación y destrucción</div></td></tr>
<tr class="memitem:ab55f7bc4639e905d66935b56995a5b1f"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classaed2_1_1iterator.html#ab55f7bc4639e905d66935b56995a5b1f">map</a> (Compare c=Compare())</td></tr>
<tr class="memdesc:ab55f7bc4639e905d66935b56995a5b1f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Crea un diccionario vacio.  <a href="#ab55f7bc4639e905d66935b56995a5b1f">More...</a><br /></td></tr>
<tr class="separator:ab55f7bc4639e905d66935b56995a5b1f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aee42bcaf809b71168f4266e1d05971e2"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classaed2_1_1iterator.html#aee42bcaf809b71168f4266e1d05971e2">map</a> (const <a class="el" href="classaed2_1_1map.html">map</a> &amp;other)</td></tr>
<tr class="memdesc:aee42bcaf809b71168f4266e1d05971e2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor por copia.  <a href="#aee42bcaf809b71168f4266e1d05971e2">More...</a><br /></td></tr>
<tr class="separator:aee42bcaf809b71168f4266e1d05971e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa44ca788a300603c5fae2d192e11f249"><td class="memTemplParams" colspan="2">template&lt;class iterator &gt; </td></tr>
<tr class="memitem:aa44ca788a300603c5fae2d192e11f249"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classaed2_1_1iterator.html#aa44ca788a300603c5fae2d192e11f249">map</a> (<a class="el" href="classaed2_1_1iterator_1_1iterator.html">iterator</a> first, <a class="el" href="classaed2_1_1iterator_1_1iterator.html">iterator</a> last, Compare c=Compare())</td></tr>
<tr class="memdesc:aa44ca788a300603c5fae2d192e11f249"><td class="mdescLeft">&#160;</td><td class="mdescRight">Crea un diccionario con los elementos del rango [{first}, {last})  <a href="#aa44ca788a300603c5fae2d192e11f249">More...</a><br /></td></tr>
<tr class="separator:aa44ca788a300603c5fae2d192e11f249"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7cafd02350b04f7546fa29c17168c18b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classaed2_1_1map.html">map</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classaed2_1_1iterator.html#a7cafd02350b04f7546fa29c17168c18b">operator=</a> (<a class="el" href="classaed2_1_1map.html">map</a> other)</td></tr>
<tr class="memdesc:a7cafd02350b04f7546fa29c17168c18b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Operador de asignación.  <a href="#a7cafd02350b04f7546fa29c17168c18b">More...</a><br /></td></tr>
<tr class="separator:a7cafd02350b04f7546fa29c17168c18b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a769d0ae1a1c7ed66acdd321e44fcd0e1"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classaed2_1_1iterator.html#a769d0ae1a1c7ed66acdd321e44fcd0e1">~map</a> ()</td></tr>
<tr class="memdesc:a769d0ae1a1c7ed66acdd321e44fcd0e1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destructor.  <a href="#a769d0ae1a1c7ed66acdd321e44fcd0e1">More...</a><br /></td></tr>
<tr class="separator:a769d0ae1a1c7ed66acdd321e44fcd0e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Busqueda y acceso a los valores</div></td></tr>
<tr class="memitem:a5a443b1a5d288b9512a6698b92cb415d"><td class="memItemLeft" align="right" valign="top">const Meaning &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classaed2_1_1iterator.html#a5a443b1a5d288b9512a6698b92cb415d">at</a> (const Key &amp;key) const</td></tr>
<tr class="memdesc:a5a443b1a5d288b9512a6698b92cb415d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Devuelve el significado asociado a {key}.  <a href="#a5a443b1a5d288b9512a6698b92cb415d">More...</a><br /></td></tr>
<tr class="separator:a5a443b1a5d288b9512a6698b92cb415d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac0459c685868fba041b9be2cde974119"><td class="memItemLeft" align="right" valign="top">Meaning &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classaed2_1_1iterator.html#ac0459c685868fba041b9be2cde974119">at</a> (const Key &amp;key)</td></tr>
<tr class="separator:ac0459c685868fba041b9be2cde974119"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af74d214f3278d8cd6b3a5a721e173fa3"><td class="memItemLeft" align="right" valign="top">Meaning &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classaed2_1_1iterator.html#af74d214f3278d8cd6b3a5a721e173fa3">operator[]</a> (const Key &amp;key)</td></tr>
<tr class="memdesc:af74d214f3278d8cd6b3a5a721e173fa3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Devuelve el significado asociado a {key}, asegurando su existencia.  <a href="#af74d214f3278d8cd6b3a5a721e173fa3">More...</a><br /></td></tr>
<tr class="separator:af74d214f3278d8cd6b3a5a721e173fa3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3d87256cbfc935a932677092ec57f49a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classaed2_1_1iterator_1_1iterator.html">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classaed2_1_1iterator.html#a3d87256cbfc935a932677092ec57f49a">find</a> (const Key &amp;key)</td></tr>
<tr class="memdesc:a3d87256cbfc935a932677092ec57f49a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Devuelve un iterador a la posicion del valor con clave {key}.  <a href="#a3d87256cbfc935a932677092ec57f49a">More...</a><br /></td></tr>
<tr class="separator:a3d87256cbfc935a932677092ec57f49a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a21b4a52c60fc70ef482e174325e8fec5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classaed2_1_1iterator_1_1const__iterator.html">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classaed2_1_1iterator.html#a21b4a52c60fc70ef482e174325e8fec5">find</a> (const Key &amp;key) const</td></tr>
<tr class="separator:a21b4a52c60fc70ef482e174325e8fec5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa7366926b6328e4f2e80484944408cbc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classaed2_1_1iterator_1_1const__iterator.html">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classaed2_1_1iterator.html#aa7366926b6328e4f2e80484944408cbc">lower_bound</a> (const Key &amp;key) const</td></tr>
<tr class="memdesc:aa7366926b6328e4f2e80484944408cbc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Devuelve un iterador al primer valor con clave mayor o igual a {key}.  <a href="#aa7366926b6328e4f2e80484944408cbc">More...</a><br /></td></tr>
<tr class="separator:aa7366926b6328e4f2e80484944408cbc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac48bbb54fea69c1fb4c093eecda02c5a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classaed2_1_1iterator_1_1iterator.html">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classaed2_1_1iterator.html#ac48bbb54fea69c1fb4c093eecda02c5a">lower_bound</a> (const Key &amp;key)</td></tr>
<tr class="separator:ac48bbb54fea69c1fb4c093eecda02c5a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Tamaño del diccionario</div></td></tr>
<tr class="memitem:a7f98e1c0896c0d960a9dc020a0a4edb8"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classaed2_1_1iterator.html#a7f98e1c0896c0d960a9dc020a0a4edb8">empty</a> () const</td></tr>
<tr class="memdesc:a7f98e1c0896c0d960a9dc020a0a4edb8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Indica si el diccionario esta vacío.  <a href="#a7f98e1c0896c0d960a9dc020a0a4edb8">More...</a><br /></td></tr>
<tr class="separator:a7f98e1c0896c0d960a9dc020a0a4edb8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa07bd4de2aeca4a6936fdbe9013be2ee"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classaed2_1_1iterator.html#aa07bd4de2aeca4a6936fdbe9013be2ee">size</a> () const</td></tr>
<tr class="memdesc:aa07bd4de2aeca4a6936fdbe9013be2ee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Devuelve la cantidad de valores en el diccionario.  <a href="#aa07bd4de2aeca4a6936fdbe9013be2ee">More...</a><br /></td></tr>
<tr class="separator:aa07bd4de2aeca4a6936fdbe9013be2ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Inserción, borrado y modificación</div></td></tr>
<tr class="memitem:ab9446668ad5619115b6c4a10eac83d68"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classaed2_1_1iterator_1_1iterator.html">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classaed2_1_1iterator.html#ab9446668ad5619115b6c4a10eac83d68">insert</a> (<a class="el" href="classaed2_1_1iterator_1_1const__iterator.html">const_iterator</a> hint, const <a class="el" href="classaed2_1_1iterator.html#a6411a2c08b2b7c52f063bef1a168acb6">value_type</a> &amp;value)</td></tr>
<tr class="memdesc:ab9446668ad5619115b6c4a10eac83d68"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserta {value} en el diccionario.  <a href="#ab9446668ad5619115b6c4a10eac83d68">More...</a><br /></td></tr>
<tr class="separator:ab9446668ad5619115b6c4a10eac83d68"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab23378eb6149357e1a2167e9804eb6e3"><td class="memItemLeft" align="right" valign="top"><a id="ab23378eb6149357e1a2167e9804eb6e3"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>insert_fixup</b> (<a class="el" href="classaed2_1_1iterator_1_1iterator.html">iterator</a> it, const <a class="el" href="classaed2_1_1iterator.html#a6411a2c08b2b7c52f063bef1a168acb6">value_type</a> &amp;value)</td></tr>
<tr class="separator:ab23378eb6149357e1a2167e9804eb6e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af4e447a081108196ecdf39b16ecb5303"><td class="memItemLeft" align="right" valign="top"><a id="af4e447a081108196ecdf39b16ecb5303"></a>
void left&#160;</td><td class="memItemRight" valign="bottom"><b>rotate</b> (<a class="el" href="classaed2_1_1iterator_1_1iterator.html">iterator</a> it)</td></tr>
<tr class="separator:af4e447a081108196ecdf39b16ecb5303"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a191eae4f3f076914ff1560a2fa833b70"><td class="memItemLeft" align="right" valign="top"><a id="a191eae4f3f076914ff1560a2fa833b70"></a>
void right&#160;</td><td class="memItemRight" valign="bottom"><b>rotate</b> (<a class="el" href="classaed2_1_1iterator_1_1iterator.html">iterator</a> it)</td></tr>
<tr class="separator:a191eae4f3f076914ff1560a2fa833b70"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa1870e8bfa4f45c82fa1ee076846922b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classaed2_1_1iterator_1_1iterator.html">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classaed2_1_1iterator.html#aa1870e8bfa4f45c82fa1ee076846922b">insert</a> (const <a class="el" href="classaed2_1_1iterator.html#a6411a2c08b2b7c52f063bef1a168acb6">value_type</a> &amp;value)</td></tr>
<tr class="separator:aa1870e8bfa4f45c82fa1ee076846922b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Recorridos e iteradores</div></td></tr>
<tr class="memitem:af8901de173468531c58458b581d345a6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classaed2_1_1iterator_1_1iterator.html">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classaed2_1_1iterator.html#af8901de173468531c58458b581d345a6">begin</a> ()</td></tr>
<tr class="memdesc:af8901de173468531c58458b581d345a6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Devuelve un iterador al primer valor del diccionario.  <a href="#af8901de173468531c58458b581d345a6">More...</a><br /></td></tr>
<tr class="separator:af8901de173468531c58458b581d345a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8a5783a3ab356cd6247b98d302d9130c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classaed2_1_1iterator_1_1const__iterator.html">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classaed2_1_1iterator.html#a8a5783a3ab356cd6247b98d302d9130c">begin</a> () const</td></tr>
<tr class="separator:a8a5783a3ab356cd6247b98d302d9130c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a89cca73bd2e4df39de7c412c441d6da1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classaed2_1_1iterator_1_1const__iterator.html">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classaed2_1_1iterator.html#a89cca73bd2e4df39de7c412c441d6da1">cbegin</a> ()</td></tr>
<tr class="separator:a89cca73bd2e4df39de7c412c441d6da1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a67caf9468be999e9be96b7add5d79946"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classaed2_1_1iterator_1_1iterator.html">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classaed2_1_1iterator.html#a67caf9468be999e9be96b7add5d79946">end</a> ()</td></tr>
<tr class="memdesc:a67caf9468be999e9be96b7add5d79946"><td class="mdescLeft">&#160;</td><td class="mdescRight">Devuelve un iterador apuntando a la posición pasando-el-ultimo del diccionario.  <a href="#a67caf9468be999e9be96b7add5d79946">More...</a><br /></td></tr>
<tr class="separator:a67caf9468be999e9be96b7add5d79946"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a66ee57cfa3bed6ffa74a1c8c23b13767"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classaed2_1_1iterator_1_1const__iterator.html">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classaed2_1_1iterator.html#a66ee57cfa3bed6ffa74a1c8c23b13767">end</a> () const</td></tr>
<tr class="separator:a66ee57cfa3bed6ffa74a1c8c23b13767"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2d0d226485d9280d16a739d0b9dae525"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classaed2_1_1iterator_1_1const__iterator.html">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classaed2_1_1iterator.html#a2d0d226485d9280d16a739d0b9dae525">cend</a> ()</td></tr>
<tr class="separator:a2d0d226485d9280d16a739d0b9dae525"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a296638725dce2fc10316d18563eb3131"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classaed2_1_1iterator.html#a07b2c0fa31611e03cd019b290acd6d80">reverse_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classaed2_1_1iterator.html#a296638725dce2fc10316d18563eb3131">rbegin</a> ()</td></tr>
<tr class="memdesc:a296638725dce2fc10316d18563eb3131"><td class="mdescLeft">&#160;</td><td class="mdescRight">Devuelve un iterador al primer valor del diccionario, en un recorrido al revés.  <a href="#a296638725dce2fc10316d18563eb3131">More...</a><br /></td></tr>
<tr class="separator:a296638725dce2fc10316d18563eb3131"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a633182fba99ef1a9f10f7bb836f990e0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classaed2_1_1iterator.html#a657402896e5b5966660032f5686cc4c4">const_reverse_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classaed2_1_1iterator.html#a633182fba99ef1a9f10f7bb836f990e0">rbegin</a> () const</td></tr>
<tr class="separator:a633182fba99ef1a9f10f7bb836f990e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa4b6ce667258581859351db42cfd3ee4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classaed2_1_1iterator.html#a657402896e5b5966660032f5686cc4c4">const_reverse_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classaed2_1_1iterator.html#aa4b6ce667258581859351db42cfd3ee4">crbegin</a> ()</td></tr>
<tr class="separator:aa4b6ce667258581859351db42cfd3ee4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0007a7962bc6aca8dca78c2a49bd581d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classaed2_1_1iterator.html#a07b2c0fa31611e03cd019b290acd6d80">reverse_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classaed2_1_1iterator.html#a0007a7962bc6aca8dca78c2a49bd581d">rend</a> ()</td></tr>
<tr class="memdesc:a0007a7962bc6aca8dca78c2a49bd581d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Devuelve un iterador apuntando a la posición pasando-el-ultimo del diccionario, en un recorrido al revés.  <a href="#a0007a7962bc6aca8dca78c2a49bd581d">More...</a><br /></td></tr>
<tr class="separator:a0007a7962bc6aca8dca78c2a49bd581d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad7d43d936bf4f3957f590723e9029132"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classaed2_1_1iterator.html#a657402896e5b5966660032f5686cc4c4">const_reverse_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classaed2_1_1iterator.html#ad7d43d936bf4f3957f590723e9029132">rend</a> () const</td></tr>
<tr class="separator:ad7d43d936bf4f3957f590723e9029132"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e31ad7ded06c666c6c37c5d30bb41af"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classaed2_1_1iterator.html#a657402896e5b5966660032f5686cc4c4">const_reverse_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classaed2_1_1iterator.html#a2e31ad7ded06c666c6c37c5d30bb41af">crend</a> ()</td></tr>
<tr class="separator:a2e31ad7ded06c666c6c37c5d30bb41af"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="friends"></a>
Friends</h2></td></tr>
<tr class="memitem:a67171474c4da6cc8efe0c7fafefd2b2d"><td class="memItemLeft" align="right" valign="top"><a id="a67171474c4da6cc8efe0c7fafefd2b2d"></a>
class&#160;</td><td class="memItemRight" valign="bottom"><b>iterator</b></td></tr>
<tr class="separator:a67171474c4da6cc8efe0c7fafefd2b2d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac220ce1c155db1ac44146c12d178056f"><td class="memItemLeft" align="right" valign="top"><a id="ac220ce1c155db1ac44146c12d178056f"></a>
class&#160;</td><td class="memItemRight" valign="bottom"><b>const_iterator</b></td></tr>
<tr class="separator:ac220ce1c155db1ac44146c12d178056f"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Parte del módulo que implementa los iteradores que permiten la modificación de los significados. </p>
<p>Cuando el iterador se encuentra asociado a un diccionario <code>d</code>, el rango válido de valores del iterador va desde el primer valor de <code>d</code> hasta una posición (ficticia) que se encuentra pasando-el-último. Esta posición no tiene definido un valor para el <code>operator*</code>, y se usa para indicar el fin del recorrido.</p>
<p>Este es un iterador que sigue el estándar de C++, y por lo tanto es compatible con la bilioteca de algoritmos. Asimismo, las operaciones siguen el protocolo estándar, con lo cual no es necesiario describir el resultado de las mismas. Sin embargo, siendo este un TP, vamos a describir el comportamiento en el marco conceptual de la materia.</p>
<dl class="section user"><dt>Aspectos generales de aliasing</dt><dd>Vale remarcar que un iterador tiene dos estados posibles:<ol type="1">
<li>Es valido: cuando esta asociado a un diccionario y apunta a un valor existente del diccionario,</li>
<li>Es inválido: cuando esta asociado a un diccionario (que quiza ya no es accesible), pero el valor al que apunta fue eliminado.</li>
<li>Es nulo: cuando no está asociado a ningún diccionario; sirve como análogo de <code>nullptr</code>. </li>
</ol>
</dd></dl>
<dl class="section user"><dt>Se explica con</dt><dd>IteradorBidireccional(Diccionario({Key}, {Meaning}), tupla({Key}, {Meaning}))</dd></dl>
<dl class="section attention"><dt>Attention</dt><dd>En caso de usar los iteradores como punteros, se desaconseja el uso de la posicion pasando-el-ultimo como valor nulo, ya que queda invalidada luego de aplicar la operación <a class="el" href="classaed2_1_1map.html#a43ddb71cc91e5c6021a7a1f243d6cc4a" title="Intercambia el contenido de {*this} y {other}. ">aed2::map::swap</a>. Conviene usar el iterador nulo (que, lamentablemente, es independiente del diccionario).</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a href="http://en.cppreference.com/w/cpp/concept/BidirectionalIterator">Documentacion estándar de iteradores bidireccionales</a> </dd></dl>
</div><h2 class="groupheader">Member Typedef Documentation</h2>
<a id="a657402896e5b5966660032f5686cc4c4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a657402896e5b5966660032f5686cc4c4">&#9670;&nbsp;</a></span>const_reverse_iterator</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classaed2_1_1iterator.html#a657402896e5b5966660032f5686cc4c4">aed2::iterator::const_reverse_iterator</a> =  std::reverse_iterator&lt;<a class="el" href="classaed2_1_1iterator_1_1const__iterator.html">const_iterator</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Iterador para recorrer un diccionario constante en orden inverso. </p>
<p>Este tipo implementa un iterador que puede recorrer el diccionario en el orden inverso. Es un renombre, porque nos aprovechamos del adaptador <code>std::reverse_iterator</code> que implementa un iterador reverso para <b>cualquier</b> iterador bidireccional que respete el estándar C++. Su interfaz y complejidades puede consultarse en la documentación de la biblioteca estándar</p>
<dl class="section see"><dt>See also</dt><dd><a href="http://en.cppreference.com/w/cpp/iterator/reverse_iterator">Documentación de <code>std::reverse_iterator</code></a> </dd></dl>

</div>
</div>
<a id="a07b2c0fa31611e03cd019b290acd6d80"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a07b2c0fa31611e03cd019b290acd6d80">&#9670;&nbsp;</a></span>reverse_iterator</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classaed2_1_1iterator.html#a07b2c0fa31611e03cd019b290acd6d80">aed2::iterator::reverse_iterator</a> =  std::reverse_iterator&lt;<a class="el" href="classaed2_1_1iterator_1_1iterator.html">iterator</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Iterador para recorrer un diccionario en orden inverso. </p>
<p>Este tipo implementa un iterador que puede recorrer el diccionario en el orden inverso. Es un renombre, porque nos aprovechamos del adaptador <code>std::reverse_iterator</code> que implementa un iterador reverso para <b>cualquier</b> iterador bidireccional que respete el estándar C++. Su interfaz y complejidades pueden consultarse en la documentación de la biblioteca estándar</p>
<dl class="section see"><dt>See also</dt><dd><a href="http://en.cppreference.com/w/cpp/iterator/reverse_iterator">Documentación de <code>std::reverse_iterator</code></a> </dd></dl>

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a769d0ae1a1c7ed66acdd321e44fcd0e1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a769d0ae1a1c7ed66acdd321e44fcd0e1">&#9670;&nbsp;</a></span>~map()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">aed2::iterator::~map </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Destructor. </p>
<p>{completar}</p>
<dl class="section pre"><dt>Precondition</dt><dd>{true} </dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd>{true}</dd></dl>
<p>{(({*this}))}</p>
<dl class="section attention"><dt>Attention</dt><dd>Como se explicita, esta función no hace nada, porque no tiene un objetivo funcional. De hecho, su implementación es innecesaria bajo la hipótesis de infinitud de memoria (que muchos sistemas de especificación, e.g. nuestros TADs, asumen por simplicidad). Sin embargo, esta función tiene un comportamiento real y es liberar la memoria usada. Claramente, esta funcionalidad depende del sistema en que estemos trabajando. Suponiendo que tuvieramos acceso a la implementación de las tablas de memoria del sistema operativo (o al mapa de memoria de la computadora), podríamos expresar la funcionalidad estableciendo la liberación de la memoria inicializa iterador con <a class="el" href="classaed2_1_1iterator.html#af8901de173468531c58458b581d345a6" title="Devuelve un iterador al primer valor del diccionario. ">begin()</a> mientras hay Siguiente, borra (siguiente) </dd></dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a5a443b1a5d288b9512a6698b92cb415d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5a443b1a5d288b9512a6698b92cb415d">&#9670;&nbsp;</a></span>at() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const Meaning&amp; aed2::iterator::at </td>
          <td>(</td>
          <td class="paramtype">const Key &amp;&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Devuelve el significado asociado a {key}. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>clave a buscar. </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">res</td><td>referencia al significado asociado a {key}.</td></tr>
  </table>
  </dd>
</dl>
<p>{completar}</p>
<dl class="section pre"><dt>Precondition</dt><dd>{def?(key,*this)}</dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd>{res  obtener(key,*this)}</dd></dl>
<p>{((({*this})  ({*this}))}</p>
<dl class="section remark"><dt>Remarks</dt><dd>Esta función, que se asemeja más a la forma de programar propuesta en AED2 que al estándar C++, fue incluida en el estándar C++11. Antes era obligación recurrir a la función find. Comienza en la raiz y si el valor es menor sigue la recursión hacia la izquierda, sino a la derecha, hasta que encuentra un nodo con la clave (key) pasada por parámetro y devuelve el significado almacenado en ese nodo. </dd></dl>

</div>
</div>
<a id="ac0459c685868fba041b9be2cde974119"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac0459c685868fba041b9be2cde974119">&#9670;&nbsp;</a></span>at() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Meaning&amp; aed2::iterator::at </td>
          <td>(</td>
          <td class="paramtype">const Key &amp;&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>

</div>
</div>
<a id="af8901de173468531c58458b581d345a6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af8901de173468531c58458b581d345a6">&#9670;&nbsp;</a></span>begin() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classaed2_1_1iterator_1_1iterator.html">iterator</a> aed2::iterator::begin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Devuelve un iterador al primer valor del diccionario. </p>
<p>{no hay}</p>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">res</td><td>iterador al primer valor</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd>{true} </dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd>{res  CrearItMod(inorder(*this))}</dd></dl>
<p>{(1)} Inicia un iterador en header-&gt;izq. </p>

</div>
</div>
<a id="a8a5783a3ab356cd6247b98d302d9130c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8a5783a3ab356cd6247b98d302d9130c">&#9670;&nbsp;</a></span>begin() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classaed2_1_1iterator_1_1const__iterator.html">const_iterator</a> aed2::iterator::begin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>

</div>
</div>
<a id="a89cca73bd2e4df39de7c412c441d6da1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a89cca73bd2e4df39de7c412c441d6da1">&#9670;&nbsp;</a></span>cbegin()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classaed2_1_1iterator_1_1const__iterator.html">const_iterator</a> aed2::iterator::cbegin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>

</div>
</div>
<a id="a2d0d226485d9280d16a739d0b9dae525"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2d0d226485d9280d16a739d0b9dae525">&#9670;&nbsp;</a></span>cend()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classaed2_1_1iterator_1_1const__iterator.html">const_iterator</a> aed2::iterator::cend </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>

</div>
</div>
<a id="ac98b533e402839c99d33d3118906c38f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac98b533e402839c99d33d3118906c38f">&#9670;&nbsp;</a></span>clear()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void aed2::iterator::clear </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Vacia el diccionario. </p>
<p>{Se invalidan todos los iteradores asociados a {*this}, con excepcion de aquellos que apuntan a la posicion pasando-el-ultimo.}</p>
<dl class="section pre"><dt>Precondition</dt><dd>{true} </dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd>{{*this}  vacio}</dd></dl>
<p>{(({*this}))} Mientras count sea distinto de 0, va eliminando con la función erase todos los elementos del árbol. </p>

</div>
</div>
<a id="aa4b6ce667258581859351db42cfd3ee4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa4b6ce667258581859351db42cfd3ee4">&#9670;&nbsp;</a></span>crbegin()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classaed2_1_1iterator.html#a657402896e5b5966660032f5686cc4c4">const_reverse_iterator</a> aed2::iterator::crbegin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>

</div>
</div>
<a id="a2e31ad7ded06c666c6c37c5d30bb41af"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2e31ad7ded06c666c6c37c5d30bb41af">&#9670;&nbsp;</a></span>crend()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classaed2_1_1iterator.html#a657402896e5b5966660032f5686cc4c4">const_reverse_iterator</a> aed2::iterator::crend </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>

</div>
</div>
<a id="a7f98e1c0896c0d960a9dc020a0a4edb8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7f98e1c0896c0d960a9dc020a0a4edb8">&#9670;&nbsp;</a></span>empty()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool aed2::iterator::empty </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Indica si el diccionario esta vacío. </p>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">res</td><td>denota true si y solo si el diccionario está vacío</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd>{true} </dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd>{res   ?(claves(*this))}</dd></dl>
<p>{(1)} Inicia en raíz, y si la misma es distinta de null devuelve false. </p>

</div>
</div>
<a id="a67caf9468be999e9be96b7add5d79946"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a67caf9468be999e9be96b7add5d79946">&#9670;&nbsp;</a></span>end() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classaed2_1_1iterator_1_1iterator.html">iterator</a> aed2::iterator::end </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Devuelve un iterador apuntando a la posición pasando-el-ultimo del diccionario. </p>
<p>{no hay}</p>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">res</td><td>iterador a la posicion pasando-al-ultimo</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd>{true} </dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd>{res  CrearItMod(inorder(*this),  )}</dd></dl>
<p>{(1)}</p>
<p>Inicia un iterador en nullptr. </p>

</div>
</div>
<a id="a66ee57cfa3bed6ffa74a1c8c23b13767"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a66ee57cfa3bed6ffa74a1c8c23b13767">&#9670;&nbsp;</a></span>end() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classaed2_1_1iterator_1_1const__iterator.html">const_iterator</a> aed2::iterator::end </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>

</div>
</div>
<a id="adf371aaec9e68bd4a4d5a889d0b6b679"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adf371aaec9e68bd4a4d5a889d0b6b679">&#9670;&nbsp;</a></span>erase() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classaed2_1_1iterator_1_1iterator.html">iterator</a> aed2::iterator::erase </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classaed2_1_1iterator_1_1const__iterator.html">const_iterator</a>&#160;</td>
          <td class="paramname"><em>pos</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Elimina el valor apuntado por {pos}. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pos</td><td>iterador apuntando al valor a eliminar. </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">res</td><td>iterador apuntando al primer valor con clave mayor a {pos} (o {this}-&gt;<a class="el" href="classaed2_1_1iterator.html#a67caf9468be999e9be96b7add5d79946" title="Devuelve un iterador apuntando a la posición pasando-el-ultimo del diccionario. ">end()</a>, si dicho valor no existe).</td></tr>
  </table>
  </dd>
</dl>
<p>{complertar}.</p>
<dl class="section pre"><dt>Precondition</dt><dd>{HayMas?(pos)} </dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd>{Eliminar(pos)}</dd></dl>
<p>{</p><ul>
<li>Peor caso: (({*pos}) + (({*this})))</li>
<li>Peor caso amortizado: (({*pos})) } </li>
</ul>

</div>
</div>
<a id="a0a0e62b2a2c0fb98f431164c66a6e388"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0a0e62b2a2c0fb98f431164c66a6e388">&#9670;&nbsp;</a></span>erase() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void aed2::iterator::erase </td>
          <td>(</td>
          <td class="paramtype">const Key &amp;&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Elimina el valor cuya clave es {key}. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>clave del elemento a eliminar</td></tr>
  </table>
  </dd>
</dl>
<p>{completar}</p>
<dl class="section pre"><dt>Precondition</dt><dd>{*this  *this0  def?(key, *this)} </dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd>{*this  borrar(key, *this0)}</dd></dl>
<p>{(({*pos}) + (({*this}))  ({*this}))} </p>

</div>
</div>
<a id="a3d87256cbfc935a932677092ec57f49a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3d87256cbfc935a932677092ec57f49a">&#9670;&nbsp;</a></span>find() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classaed2_1_1iterator_1_1iterator.html">iterator</a> aed2::iterator::find </td>
          <td>(</td>
          <td class="paramtype">const Key &amp;&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Devuelve un iterador a la posicion del valor con clave {key}. </p>
<p>Retorna un iterador apuntando a la posicion del valor con clave {key}. Si dicho valor no existe, porque la clave no fue definida, entonces el iterador retornado apunta a la posición <em>pasando-el-ultimo</em>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>clave a buscar </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">res</td><td>iterador apuntando al valor con clave {key} (o a {this}-&gt;<a class="el" href="classaed2_1_1iterator.html#a67caf9468be999e9be96b7add5d79946" title="Devuelve un iterador apuntando a la posición pasando-el-ultimo del diccionario. ">end()</a> si dicho elemento no existe)</td></tr>
  </table>
  </dd>
</dl>
<p>{Hay aliasing entre el actual(iterador) y obtener(key, *this)}</p>
<dl class="section pre"><dt>Precondition</dt><dd>{true} </dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd>{def?(key, *this)  res  crearitAux(key,inorder(*this))}</dd></dl>
<p>{((({*this}))  ({*this}))}</p>
<dl class="section attention"><dt>Attention</dt><dd>Si el objetivo es insertar un valor con clave {key} de acuerdo a alguna condición, entonces conviene usar <a class="el" href="classaed2_1_1map.html#a62075a47afdf89267c5462f88164af3d" title="Devuelve un iterador al primer valor con clave mayor o igual a {key}. ">aed2::map::lower_bound</a> para la búsqueda, dado que el resultado puede ser usado como hint, mejorando la complejidad de la inserción.<ul>
<li>Inicia el iterador en el hijo izquierdo de header.</li>
<li>Avanzo hasta que la clave sea key o, en caso de que no esté definida, hasta la posición pasando-el-último.</li>
<li>Devuelve el Iterador en esa posición. </li>
</ul>
</dd></dl>

</div>
</div>
<a id="a21b4a52c60fc70ef482e174325e8fec5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a21b4a52c60fc70ef482e174325e8fec5">&#9670;&nbsp;</a></span>find() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classaed2_1_1iterator_1_1const__iterator.html">const_iterator</a> aed2::iterator::find </td>
          <td>(</td>
          <td class="paramtype">const Key &amp;&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>

</div>
</div>
<a id="ab9446668ad5619115b6c4a10eac83d68"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab9446668ad5619115b6c4a10eac83d68">&#9670;&nbsp;</a></span>insert() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classaed2_1_1iterator_1_1iterator.html">iterator</a> aed2::iterator::insert </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classaed2_1_1iterator_1_1const__iterator.html">const_iterator</a>&#160;</td>
          <td class="paramname"><em>hint</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classaed2_1_1iterator.html#a6411a2c08b2b7c52f063bef1a168acb6">value_type</a> &amp;&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Inserta {value} en el diccionario. </p>
<p>Inserta un <b>nuevo</b> valor en el diccionario. Si {*this} ya tiene un valor con clave {value}.first, entonces la función no tiene efectos. El iterador de retorno apunta al elemento recien insertado (o aquel que previno la insercion).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>valor a insertar </td></tr>
    <tr><td class="paramname">hint</td><td>iterador apuntando al diccionario. Se espera que apunte al minimo valor mayor o igual a {value}.first (i.e., a lower_bound({value}.first)). Igualmente, la función es robusta y funciona correctamente aunque esto no ocurra. </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">res</td><td>iterador apuntando al elemento insertado o que previno la inserción</td></tr>
  </table>
  </dd>
</dl>
<p>{hay aliasing???}</p>
<dl class="section pre"><dt>Precondition</dt><dd>{true} </dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd>{def?(value.first, *this)  crearitAux(*this.first, inorder(*this) )   def?(value.first, *this)  res  agregar(crearIt(inorder(*this)), value)}</dd></dl>
<p>{</p><ul>
<li>Peor caso: ((({*this}))  ({*this})  ({value}))</li>
<li>Si {hint} apunta al primer valor con clave al menos {value}.first (o {this}-&gt;<a class="el" href="classaed2_1_1iterator.html#a67caf9468be999e9be96b7add5d79946" title="Devuelve un iterador apuntando a la posición pasando-el-ultimo del diccionario. ">end()</a> en caso de no existir): (({*this})  ({value})) amortizado. }</li>
</ul>
<dl class="section attention"><dt>Attention</dt><dd>Para garantizar que el nuevo elemento se inserte sí o sí, usar <a class="el" href="classaed2_1_1map.html#a2ef6723c183916276b0afc4a4c721475">aed2::map::insert_or_assign</a>. </dd></dl>

</div>
</div>
<a id="aa1870e8bfa4f45c82fa1ee076846922b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa1870e8bfa4f45c82fa1ee076846922b">&#9670;&nbsp;</a></span>insert() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classaed2_1_1iterator_1_1iterator.html">iterator</a> aed2::iterator::insert </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classaed2_1_1iterator.html#a6411a2c08b2b7c52f063bef1a168acb6">value_type</a> &amp;&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>

</div>
</div>
<a id="aab34e7001b3ee3ce79da8ea24d7e6351"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aab34e7001b3ee3ce79da8ea24d7e6351">&#9670;&nbsp;</a></span>insert_or_assign() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classaed2_1_1iterator_1_1iterator.html">iterator</a> aed2::iterator::insert_or_assign </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classaed2_1_1iterator_1_1const__iterator.html">const_iterator</a>&#160;</td>
          <td class="paramname"><em>hint</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classaed2_1_1iterator.html#a6411a2c08b2b7c52f063bef1a168acb6">value_type</a> &amp;&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>{</p><ul>
<li>Peor caso: ((({*this}))  ({*this})  ({value}))</li>
<li>Si {hint} apunta al primer valor con clave al menos {value}.first (o {this}-&gt;<a class="el" href="classaed2_1_1iterator.html#a67caf9468be999e9be96b7add5d79946" title="Devuelve un iterador apuntando a la posición pasando-el-ultimo del diccionario. ">end()</a> en caso de no existir): (({*this})  ({value})) amortizado. }</li>
</ul>
<dl class="section attention"><dt>Attention</dt><dd>Para prevenir que el nuevo valor redefina uno ya existente, usar <a class="el" href="classaed2_1_1map.html#a6941cde9a79c27f054b5c97a587a1854" title="Inserta {value} en el diccionario. ">aed2::map::insert</a>. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>Esta función es similar al operator[], pero tiene dos ventajas y una desventaja. Las ventajas es que 1. se puede indicar un {hint} para la búsqueda y 2. no es necesario que {Meaning} tenga constructor sin parámetros. La desventaja es que la notación no es tan bonita. </dd></dl>

</div>
</div>
<a id="af131c4b0d89978372a0c8ce38bf8f33e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af131c4b0d89978372a0c8ce38bf8f33e">&#9670;&nbsp;</a></span>insert_or_assign() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classaed2_1_1iterator_1_1iterator.html">iterator</a> aed2::iterator::insert_or_assign </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classaed2_1_1iterator.html#a6411a2c08b2b7c52f063bef1a168acb6">value_type</a> &amp;&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>

</div>
</div>
<a id="aa7366926b6328e4f2e80484944408cbc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa7366926b6328e4f2e80484944408cbc">&#9670;&nbsp;</a></span>lower_bound() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classaed2_1_1iterator_1_1const__iterator.html">const_iterator</a> aed2::iterator::lower_bound </td>
          <td>(</td>
          <td class="paramtype">const Key &amp;&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Devuelve un iterador al primer valor con clave mayor o igual a {key}. </p>
<p>Retorna un iterador apuntando a la primer posición cuyo valor tenga clave al menos {key}. Si dicho valor no existe, porque {key} es mayor a todas las claves de {*this}, entonces el iterador retornado apunta a la posición <em>pasando-el-último</em>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>clave a buscar </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">res</td><td>iterador apuntando al valor con clave al menos {key} (o a {this}-&gt;<a class="el" href="classaed2_1_1iterator.html#a67caf9468be999e9be96b7add5d79946" title="Devuelve un iterador apuntando a la posición pasando-el-ultimo del diccionario. ">end()</a> si dicho elemento no existe)</td></tr>
  </table>
  </dd>
</dl>
<p>{hay aliasing entre res y el sucesor inmediato de key}</p>
<dl class="section pre"><dt>Precondition</dt><dd>{true} </dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd>{res  crearitAux2(key,inorder(*this))(busca en la secu inorder a key y devuelve el siguiente o null si es mayor a todas las claves)}</dd></dl>
<p>{((({*this}))  ({*this}))}</p><ul>
<li>Inicia el iterador en el hijo izquierdo de header.</li>
<li>Avanzo hasta que la clave sea mayor o igual a key o, en caso de que no exista ninguna, hasta la posición pasando-el-último.</li>
<li>Devuelve el Iterador en esa posición. </li>
</ul>

</div>
</div>
<a id="ac48bbb54fea69c1fb4c093eecda02c5a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac48bbb54fea69c1fb4c093eecda02c5a">&#9670;&nbsp;</a></span>lower_bound() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classaed2_1_1iterator_1_1iterator.html">iterator</a> aed2::iterator::lower_bound </td>
          <td>(</td>
          <td class="paramtype">const Key &amp;&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>

</div>
</div>
<a id="ab55f7bc4639e905d66935b56995a5b1f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab55f7bc4639e905d66935b56995a5b1f">&#9670;&nbsp;</a></span>map() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">aed2::iterator::map </td>
          <td>(</td>
          <td class="paramtype">Compare&#160;</td>
          <td class="paramname"><em>c</em> = <code>Compare()</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Crea un diccionario vacio. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">c</td><td>comparador (functor de orden) a utilizar </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">res</td><td>diccionario recién construido</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd>{true} </dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd>{res  vacio()}</dd></dl>
<p>{(1)}</p>
<dl class="section attention"><dt>Attention</dt><dd>El parámetro formal  del TAD diccionario se establece en esta función.  = {c}.operator() ambos hijos de header apuntan a null, y padre de header apunta a null </dd></dl>

</div>
</div>
<a id="aee42bcaf809b71168f4266e1d05971e2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aee42bcaf809b71168f4266e1d05971e2">&#9670;&nbsp;</a></span>map() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">aed2::iterator::map </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classaed2_1_1map.html">map</a> &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructor por copia. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>diccionario a copiar </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">res</td><td>diccionario recien construido</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd>{true} </dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd>{res  other}</dd></dl>
<p>{(({other}))}</p>
<dl class="section attention"><dt>Attention</dt><dd>El parámetro formal  del TAD diccionario se establece en esta función.  es igual al operator() del comparador de {other} <a class="el" href="classaed2_1_1iterator.html#af8901de173468531c58458b581d345a6" title="Devuelve un iterador al primer valor del diccionario. ">begin()</a> iterador en other. mientras haya Siguiente en el iterador de other, insertar siguiente, y avanzar. </dd></dl>

</div>
</div>
<a id="aa44ca788a300603c5fae2d192e11f249"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa44ca788a300603c5fae2d192e11f249">&#9670;&nbsp;</a></span>map() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class iterator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">aed2::iterator::map </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classaed2_1_1iterator_1_1iterator.html">iterator</a>&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classaed2_1_1iterator_1_1iterator.html">iterator</a>&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Compare&#160;</td>
          <td class="paramname"><em>c</em> = <code>Compare()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Crea un diccionario con los elementos del rango [{first}, {last}) </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">iterator</td><td>clase del iterador a recorrer</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Requerimientos sobre el tipo {iterator}</dt><dd>El tipo {iterator} debe tener todas las funcionalidades de un <em>InputIterator</em> de C++. En términos de la materia, vamos a suponer que {iterator} se explica con el TAD Iterador Unidireccional(puntero(C), {value_type}) para alguna colección de tipo C.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">first</td><td>iterador al primer elemento del rango </td></tr>
    <tr><td class="paramname">last</td><td>iterador pasando el ultimo elemento del rango </td></tr>
    <tr><td class="paramname">c</td><td>comparador a utilizar </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">res</td><td>diccionario recien construido</td></tr>
  </table>
  </dd>
</dl>
<p>{{first} y {last} son iteradores que recorren la misma secuencia definida por una colección.}</p>
<dl class="section pre"><dt>Precondition</dt><dd><p class="startdd">{last} debe ser alcanzable desde {first} y en el rango [{first}, {last}) no pueden haber valores repetidos.</p>
<p class="enddd">{coleccion({first})  coleccion({last})  esSufijo(Siguientes({last}), Siguientes({first}))  (Siguientes({first})  Siguientes({last}))} </p>
</dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd><p class="startdd">Los valores definidos en {res} son aquellos que aparecen en [{first}, {last})</p>
<p class="enddd">{( k: {Key})( s: {Meaning}) (def?({res}, k)  significado({res}, k)  s  esta((k,s), Siguientes({first})  Siguientes({last}))) } </p>
</dd></dl>
<p>{</p><ul>
<li>En el peor caso: (({res})  ((({res}))  ({res}) + ({res})))</li>
<li>Si el rango [{first}, {last}) está ordenado: (({res})  (({res})+ ({res}))) }</li>
</ul>
<dl class="section attention"><dt>Attention</dt><dd>El parámetro formal  del TAD diccionario se establece en esta función.  = {c}.operator()</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a href="http://en.cppreference.com/w/cpp/concept/InputIterator">Documentación de InputIterator</a> </dd></dl>

</div>
</div>
<a id="a7cafd02350b04f7546fa29c17168c18b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7cafd02350b04f7546fa29c17168c18b">&#9670;&nbsp;</a></span>operator=()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classaed2_1_1map.html">map</a>&amp; aed2::iterator::operator= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classaed2_1_1map.html">map</a>&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Operador de asignación. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>diccionario a copiar </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">res</td><td>referencia a *this</td></tr>
  </table>
  </dd>
</dl>
<p>{no hay}</p>
<dl class="section pre"><dt>Precondition</dt><dd>{true} </dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd>{res  other}</dd></dl>
<p>{(({*this})  ({other}))}</p>
<dl class="section note"><dt>Note</dt><dd>Es importante remarcar que no se realiza ninguna comparación entre los elementos. -destruir this<ul>
<li>this-&gt;map(other) </li>
</ul>
</dd></dl>

</div>
</div>
<a id="af74d214f3278d8cd6b3a5a721e173fa3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af74d214f3278d8cd6b3a5a721e173fa3">&#9670;&nbsp;</a></span>operator[]()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Meaning&amp; aed2::iterator::operator[] </td>
          <td>(</td>
          <td class="paramtype">const Key &amp;&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Devuelve el significado asociado a {key}, asegurando su existencia. </p>
<p>Devuelve el significado asociado a {key}. Si {key} no está definido en {*this}, entonces se inserta un nuevo valor con clave {key} y significado {Meaning}(). De esta forma, podemos usar <code>operator[]</code> para definir nuevos valores o modificar los existentes.</p>
<p>Ejemplo: </p><div class="fragment"><div class="line"><a class="code" href="classaed2_1_1map.html">aed2::map&lt;int, int&gt;</a> d;</div><div class="line">d[1] = 2;      <span class="comment">//define 1 -&gt; 2</span></div><div class="line">d[1] = 3;      <span class="comment">//redefine 1 -&gt; 3</span></div><div class="line"></div><div class="line"><a class="code" href="classaed2_1_1map.html">aed2::map&lt;int, int&gt;</a> m;</div><div class="line"><span class="keywordflow">if</span>(m[1] == 3) {...} <span class="comment">//posible bug: define 1 -&gt; basura (que puede o no ser 3).</span></div></div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>clave a buscar. </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">res</td><td>referencia al significado asociado a {key}.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Requerimientos sobre el tipo {Meaning}</dt><dd>Requiere que {Meaning} tenga un constructor sin parámetros con complejidad (<em>c</em>)</dd></dl>
<p>{hay aliasing entre res y obtener(key, *this)}</p>
<dl class="section pre"><dt>Precondition</dt><dd>{true} </dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd>{def?(key, *this)  res  obtener(key, *this)}</dd></dl>
<p>{((({*this}))  ({*this}) + <em>x</em>) donde</p><ul>
<li><em>x</em> = 1 si def?(<em>self</em>, {key}), y</li>
<li><em>x</em> = <em>c</em> en caso contrario.} Comienza en la raiz y si el valor es menor sigue la recursión hacia la izquierda, sino a la derecha, hasta que encuentra un nodo con la clave (key) pasada por parámetro y devuelve el significado almacenado en ese nodo, o en el caso que la clave no esté definida, la define con el significado default y además incrementa en uno count. </li>
</ul>

</div>
</div>
<a id="a296638725dce2fc10316d18563eb3131"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a296638725dce2fc10316d18563eb3131">&#9670;&nbsp;</a></span>rbegin() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classaed2_1_1iterator.html#a07b2c0fa31611e03cd019b290acd6d80">reverse_iterator</a> aed2::iterator::rbegin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Devuelve un iterador al primer valor del diccionario, en un recorrido al revés. </p>
<p>{no hay}</p>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">res</td><td>iterador a la primer posicion en un recorrido al revés</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd>{true} </dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd>{res  CrearItMod(  , postorder(*this))}</dd></dl>
<p>{(1)}</p>
<p>Inicia un reverse_iterator en el hijo derecho de header. </p>

</div>
</div>
<a id="a633182fba99ef1a9f10f7bb836f990e0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a633182fba99ef1a9f10f7bb836f990e0">&#9670;&nbsp;</a></span>rbegin() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classaed2_1_1iterator.html#a657402896e5b5966660032f5686cc4c4">const_reverse_iterator</a> aed2::iterator::rbegin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>

</div>
</div>
<a id="a0007a7962bc6aca8dca78c2a49bd581d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0007a7962bc6aca8dca78c2a49bd581d">&#9670;&nbsp;</a></span>rend() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classaed2_1_1iterator.html#a07b2c0fa31611e03cd019b290acd6d80">reverse_iterator</a> aed2::iterator::rend </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Devuelve un iterador apuntando a la posición pasando-el-ultimo del diccionario, en un recorrido al revés. </p>
<p>{no hay}</p>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">res</td><td>iterador a la posicion pasando-al-ultimo, en un recorrido al revés</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd>{true} </dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd>{res  CrearItMod(postorder(*this),  )}</dd></dl>
<p>{(1)}</p>
<p>Inicia un reversre_iterator en el hijo izquierdo de header. </p>

</div>
</div>
<a id="ad7d43d936bf4f3957f590723e9029132"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad7d43d936bf4f3957f590723e9029132">&#9670;&nbsp;</a></span>rend() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classaed2_1_1iterator.html#a657402896e5b5966660032f5686cc4c4">const_reverse_iterator</a> aed2::iterator::rend </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>

</div>
</div>
<a id="aa07bd4de2aeca4a6936fdbe9013be2ee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa07bd4de2aeca4a6936fdbe9013be2ee">&#9670;&nbsp;</a></span>size()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t aed2::iterator::size </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Devuelve la cantidad de valores en el diccionario. </p>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">res</td><td>cantidad de valores</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd>{true} </dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd>{res  #claves(*this)}</dd></dl>
<p>{(1)} Devuelve count; </p>

</div>
</div>
<a id="a8ec2215b2dfaf6ddd57b1e0b00d8d3d2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8ec2215b2dfaf6ddd57b1e0b00d8d3d2">&#9670;&nbsp;</a></span>swap()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void aed2::iterator::swap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classaed2_1_1map.html">map</a> &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Intercambia el contenido de {*this} y {other}. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>diccionario a intercambiar con {*this}</td></tr>
  </table>
  </dd>
</dl>
<p>{Todos los iteradores, salvo aquellos que apuntan a las posiciones pasando-el-ultimo, se mantienen válidos. Aquellos iteradores que apuntan a la posición pasando-el-ultimo de {*this} pasan a apuntar a la posición pasando-el-ultimo de {other}, y viceversa.}</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>mapa a intercambiar con this</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd>{<em>self</em> = {*this}  <em>oth</em> = {other}} </dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd>{{*this}  <em>oth</em>  {other} = <em>self}</em> </dd></dl>
<p>{(1)}</p>
<dl class="section note"><dt>Note</dt><dd>La razón por la que se "invalidan" los iteradores pasando-el-fin tiene que ver con la forma en que se implementa el módulo (que emula la implementacion de C++). No hay ninguna razón técnica que impida mantener los iteradores pasando el fin, salvo por un pequeño ahorro de memoria y tiempo. En caso de querer usar los iteradores como punteros, se recomienda usar el iterador nulo de diccionario para representar al valor inválido, en lugar de usar los iteradores pasando-el-ultimo. </dd></dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li><a class="el" href="map2_8h_source.html">map2.h</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.14
</small></address>
</body>
</html>
