<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.14"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>My Project: aed2::map&lt; Key, Meaning, Compare &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">My Project
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.14 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespaceaed2.html">aed2</a></li><li class="navelem"><a class="el" href="classaed2_1_1map.html">map</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#friends">Friends</a> &#124;
<a href="classaed2_1_1map-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">aed2::map&lt; Key, Meaning, Compare &gt; Class Template Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Modulo que implementa un diccionario.  
 <a href="classaed2_1_1map.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="map_8h_source.html">map.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classaed2_1_1map_1_1const__iterator.html">const_iterator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parte del módulo que implementa los iteradores que no permiten la modificación de los significados.  <a href="classaed2_1_1map_1_1const__iterator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classaed2_1_1map_1_1iterator.html">iterator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parte del módulo que implementa los iteradores que permiten la modificación de los significados.  <a href="classaed2_1_1map_1_1iterator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a4273e8812e7105a618df58a2c8b72b7d"><td class="memItemLeft" align="right" valign="top"><a id="a4273e8812e7105a618df58a2c8b72b7d"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classaed2_1_1map.html#a4273e8812e7105a618df58a2c8b72b7d">key_type</a> = Key</td></tr>
<tr class="memdesc:a4273e8812e7105a618df58a2c8b72b7d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Renombre para poder acceder al tipo de las claves. Compatible con estándar C++. <br /></td></tr>
<tr class="separator:a4273e8812e7105a618df58a2c8b72b7d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa3e34bf624f3009884a71b18f4ddae40"><td class="memItemLeft" align="right" valign="top"><a id="aa3e34bf624f3009884a71b18f4ddae40"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classaed2_1_1map.html#aa3e34bf624f3009884a71b18f4ddae40">mapped_type</a> = Meaning</td></tr>
<tr class="memdesc:aa3e34bf624f3009884a71b18f4ddae40"><td class="mdescLeft">&#160;</td><td class="mdescRight">Renombre para poder acceder al tipo de los significados. Compatible con estándar C++. <br /></td></tr>
<tr class="separator:aa3e34bf624f3009884a71b18f4ddae40"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a719db98e0ff9a837610f76be33264680"><td class="memItemLeft" align="right" valign="top"><a id="a719db98e0ff9a837610f76be33264680"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classaed2_1_1map.html#a719db98e0ff9a837610f76be33264680">value_type</a> = std::pair&lt; const Key, Meaning &gt;</td></tr>
<tr class="memdesc:a719db98e0ff9a837610f76be33264680"><td class="mdescLeft">&#160;</td><td class="mdescRight">Renombre para poder acceder al tipo de las valores almacenados. Compatible con estándar C++. <br /></td></tr>
<tr class="separator:a719db98e0ff9a837610f76be33264680"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3efa081d3379ab76f33a5ef9fe697523"><td class="memItemLeft" align="right" valign="top"><a id="a3efa081d3379ab76f33a5ef9fe697523"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classaed2_1_1map.html#a3efa081d3379ab76f33a5ef9fe697523">key_compare</a> = Compare</td></tr>
<tr class="memdesc:a3efa081d3379ab76f33a5ef9fe697523"><td class="mdescLeft">&#160;</td><td class="mdescRight">Renombre para poder acceder al tipo del comparador. Compatible con estándar C++. <br /></td></tr>
<tr class="separator:a3efa081d3379ab76f33a5ef9fe697523"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af4f147533b3c0207ab036c86ce13ec0d"><td class="memItemLeft" align="right" valign="top"><a id="af4f147533b3c0207ab036c86ce13ec0d"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classaed2_1_1map.html#af4f147533b3c0207ab036c86ce13ec0d">reference</a> = <a class="el" href="classaed2_1_1map.html#a719db98e0ff9a837610f76be33264680">value_type</a> &amp;</td></tr>
<tr class="memdesc:af4f147533b3c0207ab036c86ce13ec0d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Renombre para poder acceder al tipo de referencia de los valores guardados. Compatible con estándar C++. <br /></td></tr>
<tr class="separator:af4f147533b3c0207ab036c86ce13ec0d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a277080d3db76f19df9319ecba16475a9"><td class="memItemLeft" align="right" valign="top"><a id="a277080d3db76f19df9319ecba16475a9"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classaed2_1_1map.html#a277080d3db76f19df9319ecba16475a9">const_reference</a> = const <a class="el" href="classaed2_1_1map.html#a719db98e0ff9a837610f76be33264680">value_type</a> &amp;</td></tr>
<tr class="memdesc:a277080d3db76f19df9319ecba16475a9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Renombre para poder acceder al tipo de referencia constante de los valores guardados. Compatible con estándar C++. <br /></td></tr>
<tr class="separator:a277080d3db76f19df9319ecba16475a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7394e98a23b86bc008ad73326b273fd5"><td class="memItemLeft" align="right" valign="top"><a id="a7394e98a23b86bc008ad73326b273fd5"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classaed2_1_1map.html#a7394e98a23b86bc008ad73326b273fd5">pointer</a> = <a class="el" href="classaed2_1_1map.html#a719db98e0ff9a837610f76be33264680">value_type</a> *</td></tr>
<tr class="memdesc:a7394e98a23b86bc008ad73326b273fd5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Renombre para poder acceder al tipo de los punteros de los valores guardados. Compatible con estándar C++. <br /></td></tr>
<tr class="separator:a7394e98a23b86bc008ad73326b273fd5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1366fc3e227a49777cb748fc6d4e022b"><td class="memItemLeft" align="right" valign="top"><a id="a1366fc3e227a49777cb748fc6d4e022b"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classaed2_1_1map.html#a1366fc3e227a49777cb748fc6d4e022b">const_pointer</a> = const <a class="el" href="classaed2_1_1map.html#a719db98e0ff9a837610f76be33264680">value_type</a> *</td></tr>
<tr class="memdesc:a1366fc3e227a49777cb748fc6d4e022b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Renombre para poder acceder al tipo de los punteros de los valores constantes guardados. Compatible con estándar C++. <br /></td></tr>
<tr class="separator:a1366fc3e227a49777cb748fc6d4e022b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8cf1c570f605e9c0ad6feb8ce12c9400"><td class="memItemLeft" align="right" valign="top"><a id="a8cf1c570f605e9c0ad6feb8ce12c9400"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classaed2_1_1map.html#a8cf1c570f605e9c0ad6feb8ce12c9400">size_type</a> = std::size_t</td></tr>
<tr class="memdesc:a8cf1c570f605e9c0ad6feb8ce12c9400"><td class="mdescLeft">&#160;</td><td class="mdescRight">Renombre para poder acceder al tipo usado para describir tamaños. Compatible con estándar C++. <br /></td></tr>
<tr class="separator:a8cf1c570f605e9c0ad6feb8ce12c9400"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2f55b88809000fcbfce1c6cfef1ba74d"><td class="memItemLeft" align="right" valign="top"><a id="a2f55b88809000fcbfce1c6cfef1ba74d"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classaed2_1_1map.html#a2f55b88809000fcbfce1c6cfef1ba74d">difference_type</a> = std::ptrdiff_t</td></tr>
<tr class="memdesc:a2f55b88809000fcbfce1c6cfef1ba74d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Renombre para poder acceder al tipo usado para describir diferencias entre punteros. Compatible con estándar C++. <br /></td></tr>
<tr class="separator:a2f55b88809000fcbfce1c6cfef1ba74d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8e6a592062260177fd73b2f9897b1dd5"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classaed2_1_1map.html#a8e6a592062260177fd73b2f9897b1dd5">reverse_iterator</a> = std::reverse_iterator&lt; <a class="el" href="classaed2_1_1map_1_1iterator.html">iterator</a> &gt;</td></tr>
<tr class="memdesc:a8e6a592062260177fd73b2f9897b1dd5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Iterador para recorrer un diccionario en orden inverso.  <a href="#a8e6a592062260177fd73b2f9897b1dd5">More...</a><br /></td></tr>
<tr class="separator:a8e6a592062260177fd73b2f9897b1dd5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed66a216549d13078a3ea6978ea0b768"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classaed2_1_1map.html#aed66a216549d13078a3ea6978ea0b768">const_reverse_iterator</a> = std::reverse_iterator&lt; <a class="el" href="classaed2_1_1map_1_1const__iterator.html">const_iterator</a> &gt;</td></tr>
<tr class="memdesc:aed66a216549d13078a3ea6978ea0b768"><td class="mdescLeft">&#160;</td><td class="mdescRight">Iterador para recorrer un diccionario constante en orden inverso.  <a href="#aed66a216549d13078a3ea6978ea0b768">More...</a><br /></td></tr>
<tr class="separator:aed66a216549d13078a3ea6978ea0b768"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4273e8812e7105a618df58a2c8b72b7d"><td class="memItemLeft" align="right" valign="top"><a id="a4273e8812e7105a618df58a2c8b72b7d"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classaed2_1_1map.html#a4273e8812e7105a618df58a2c8b72b7d">key_type</a> = Key</td></tr>
<tr class="memdesc:a4273e8812e7105a618df58a2c8b72b7d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Renombre para poder acceder al tipo de las claves. Compatible con estándar C++. <br /></td></tr>
<tr class="separator:a4273e8812e7105a618df58a2c8b72b7d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa3e34bf624f3009884a71b18f4ddae40"><td class="memItemLeft" align="right" valign="top"><a id="aa3e34bf624f3009884a71b18f4ddae40"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classaed2_1_1map.html#aa3e34bf624f3009884a71b18f4ddae40">mapped_type</a> = Meaning</td></tr>
<tr class="memdesc:aa3e34bf624f3009884a71b18f4ddae40"><td class="mdescLeft">&#160;</td><td class="mdescRight">Renombre para poder acceder al tipo de los significados. Compatible con estándar C++. <br /></td></tr>
<tr class="separator:aa3e34bf624f3009884a71b18f4ddae40"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a719db98e0ff9a837610f76be33264680"><td class="memItemLeft" align="right" valign="top"><a id="a719db98e0ff9a837610f76be33264680"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classaed2_1_1map.html#a719db98e0ff9a837610f76be33264680">value_type</a> = std::pair&lt; const Key, Meaning &gt;</td></tr>
<tr class="memdesc:a719db98e0ff9a837610f76be33264680"><td class="mdescLeft">&#160;</td><td class="mdescRight">Renombre para poder acceder al tipo de las valores almacenados. Compatible con estándar C++. <br /></td></tr>
<tr class="separator:a719db98e0ff9a837610f76be33264680"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3efa081d3379ab76f33a5ef9fe697523"><td class="memItemLeft" align="right" valign="top"><a id="a3efa081d3379ab76f33a5ef9fe697523"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classaed2_1_1map.html#a3efa081d3379ab76f33a5ef9fe697523">key_compare</a> = Compare</td></tr>
<tr class="memdesc:a3efa081d3379ab76f33a5ef9fe697523"><td class="mdescLeft">&#160;</td><td class="mdescRight">Renombre para poder acceder al tipo del comparador. Compatible con estándar C++. <br /></td></tr>
<tr class="separator:a3efa081d3379ab76f33a5ef9fe697523"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af4f147533b3c0207ab036c86ce13ec0d"><td class="memItemLeft" align="right" valign="top"><a id="af4f147533b3c0207ab036c86ce13ec0d"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classaed2_1_1map.html#af4f147533b3c0207ab036c86ce13ec0d">reference</a> = <a class="el" href="classaed2_1_1map.html#a719db98e0ff9a837610f76be33264680">value_type</a> &amp;</td></tr>
<tr class="memdesc:af4f147533b3c0207ab036c86ce13ec0d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Renombre para poder acceder al tipo de referencia de los valores guardados. Compatible con estándar C++. <br /></td></tr>
<tr class="separator:af4f147533b3c0207ab036c86ce13ec0d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a277080d3db76f19df9319ecba16475a9"><td class="memItemLeft" align="right" valign="top"><a id="a277080d3db76f19df9319ecba16475a9"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classaed2_1_1map.html#a277080d3db76f19df9319ecba16475a9">const_reference</a> = const <a class="el" href="classaed2_1_1map.html#a719db98e0ff9a837610f76be33264680">value_type</a> &amp;</td></tr>
<tr class="memdesc:a277080d3db76f19df9319ecba16475a9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Renombre para poder acceder al tipo de referencia constante de los valores guardados. Compatible con estándar C++. <br /></td></tr>
<tr class="separator:a277080d3db76f19df9319ecba16475a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7394e98a23b86bc008ad73326b273fd5"><td class="memItemLeft" align="right" valign="top"><a id="a7394e98a23b86bc008ad73326b273fd5"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classaed2_1_1map.html#a7394e98a23b86bc008ad73326b273fd5">pointer</a> = <a class="el" href="classaed2_1_1map.html#a719db98e0ff9a837610f76be33264680">value_type</a> *</td></tr>
<tr class="memdesc:a7394e98a23b86bc008ad73326b273fd5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Renombre para poder acceder al tipo de los punteros de los valores guardados. Compatible con estándar C++. <br /></td></tr>
<tr class="separator:a7394e98a23b86bc008ad73326b273fd5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1366fc3e227a49777cb748fc6d4e022b"><td class="memItemLeft" align="right" valign="top"><a id="a1366fc3e227a49777cb748fc6d4e022b"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classaed2_1_1map.html#a1366fc3e227a49777cb748fc6d4e022b">const_pointer</a> = const <a class="el" href="classaed2_1_1map.html#a719db98e0ff9a837610f76be33264680">value_type</a> *</td></tr>
<tr class="memdesc:a1366fc3e227a49777cb748fc6d4e022b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Renombre para poder acceder al tipo de los punteros de los valores constantes guardados. Compatible con estándar C++. <br /></td></tr>
<tr class="separator:a1366fc3e227a49777cb748fc6d4e022b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8cf1c570f605e9c0ad6feb8ce12c9400"><td class="memItemLeft" align="right" valign="top"><a id="a8cf1c570f605e9c0ad6feb8ce12c9400"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classaed2_1_1map.html#a8cf1c570f605e9c0ad6feb8ce12c9400">size_type</a> = std::size_t</td></tr>
<tr class="memdesc:a8cf1c570f605e9c0ad6feb8ce12c9400"><td class="mdescLeft">&#160;</td><td class="mdescRight">Renombre para poder acceder al tipo usado para describir tamaños. Compatible con estándar C++. <br /></td></tr>
<tr class="separator:a8cf1c570f605e9c0ad6feb8ce12c9400"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2f55b88809000fcbfce1c6cfef1ba74d"><td class="memItemLeft" align="right" valign="top"><a id="a2f55b88809000fcbfce1c6cfef1ba74d"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classaed2_1_1map.html#a2f55b88809000fcbfce1c6cfef1ba74d">difference_type</a> = std::ptrdiff_t</td></tr>
<tr class="memdesc:a2f55b88809000fcbfce1c6cfef1ba74d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Renombre para poder acceder al tipo usado para describir diferencias entre punteros. Compatible con estándar C++. <br /></td></tr>
<tr class="separator:a2f55b88809000fcbfce1c6cfef1ba74d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8e6a592062260177fd73b2f9897b1dd5"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classaed2_1_1map.html#a8e6a592062260177fd73b2f9897b1dd5">reverse_iterator</a> = std::reverse_iterator&lt; <a class="el" href="classaed2_1_1map_1_1iterator.html">iterator</a> &gt;</td></tr>
<tr class="memdesc:a8e6a592062260177fd73b2f9897b1dd5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Iterador para recorrer un diccionario en orden inverso.  <a href="#a8e6a592062260177fd73b2f9897b1dd5">More...</a><br /></td></tr>
<tr class="separator:a8e6a592062260177fd73b2f9897b1dd5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed66a216549d13078a3ea6978ea0b768"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classaed2_1_1map.html#aed66a216549d13078a3ea6978ea0b768">const_reverse_iterator</a> = std::reverse_iterator&lt; <a class="el" href="classaed2_1_1map_1_1const__iterator.html">const_iterator</a> &gt;</td></tr>
<tr class="memdesc:aed66a216549d13078a3ea6978ea0b768"><td class="mdescLeft">&#160;</td><td class="mdescRight">Iterador para recorrer un diccionario constante en orden inverso.  <a href="#aed66a216549d13078a3ea6978ea0b768">More...</a><br /></td></tr>
<tr class="separator:aed66a216549d13078a3ea6978ea0b768"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a2ef6723c183916276b0afc4a4c721475"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classaed2_1_1map_1_1iterator.html">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classaed2_1_1map.html#a2ef6723c183916276b0afc4a4c721475">insert_or_assign</a> (<a class="el" href="classaed2_1_1map_1_1const__iterator.html">const_iterator</a> hint, const <a class="el" href="classaed2_1_1map.html#a719db98e0ff9a837610f76be33264680">value_type</a> &amp;value)</td></tr>
<tr class="separator:a2ef6723c183916276b0afc4a4c721475"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9128a806713bcc999ebd8a97ab77e765"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classaed2_1_1map_1_1iterator.html">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classaed2_1_1map.html#a9128a806713bcc999ebd8a97ab77e765">insert_or_assign</a> (const <a class="el" href="classaed2_1_1map.html#a719db98e0ff9a837610f76be33264680">value_type</a> &amp;value)</td></tr>
<tr class="separator:a9128a806713bcc999ebd8a97ab77e765"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad8e796bf9c9c558e5ce6b61e116253fe"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classaed2_1_1map_1_1iterator.html">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classaed2_1_1map.html#ad8e796bf9c9c558e5ce6b61e116253fe">erase</a> (<a class="el" href="classaed2_1_1map_1_1const__iterator.html">const_iterator</a> pos)</td></tr>
<tr class="memdesc:ad8e796bf9c9c558e5ce6b61e116253fe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Elimina el valor apuntado por {pos}.  <a href="#ad8e796bf9c9c558e5ce6b61e116253fe">More...</a><br /></td></tr>
<tr class="separator:ad8e796bf9c9c558e5ce6b61e116253fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a98b9f200c64ce02dfb67902ee00e375a"><td class="memItemLeft" align="right" valign="top"><a id="a98b9f200c64ce02dfb67902ee00e375a"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>transplant</b> (Node *u, Node *v)</td></tr>
<tr class="separator:a98b9f200c64ce02dfb67902ee00e375a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2ffadb42cd5f0bc7b3752ff159b75334"><td class="memItemLeft" align="right" valign="top"><a id="a2ffadb42cd5f0bc7b3752ff159b75334"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>erase</b> (const Key &amp;key)</td></tr>
<tr class="separator:a2ffadb42cd5f0bc7b3752ff159b75334"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2bfa5165825979bf2431db55bc6bc9ca"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classaed2_1_1map.html#a2bfa5165825979bf2431db55bc6bc9ca">clear</a> ()</td></tr>
<tr class="memdesc:a2bfa5165825979bf2431db55bc6bc9ca"><td class="mdescLeft">&#160;</td><td class="mdescRight">Vacia el diccionario.  <a href="#a2bfa5165825979bf2431db55bc6bc9ca">More...</a><br /></td></tr>
<tr class="separator:a2bfa5165825979bf2431db55bc6bc9ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a43ddb71cc91e5c6021a7a1f243d6cc4a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classaed2_1_1map.html#a43ddb71cc91e5c6021a7a1f243d6cc4a">swap</a> (<a class="el" href="classaed2_1_1map.html">map</a> &amp;other)</td></tr>
<tr class="memdesc:a43ddb71cc91e5c6021a7a1f243d6cc4a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Intercambia el contenido de {*this} y {other}.  <a href="#a43ddb71cc91e5c6021a7a1f243d6cc4a">More...</a><br /></td></tr>
<tr class="separator:a43ddb71cc91e5c6021a7a1f243d6cc4a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2ef6723c183916276b0afc4a4c721475"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classaed2_1_1map_1_1iterator.html">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classaed2_1_1map.html#a2ef6723c183916276b0afc4a4c721475">insert_or_assign</a> (<a class="el" href="classaed2_1_1map_1_1const__iterator.html">const_iterator</a> hint, const <a class="el" href="classaed2_1_1map.html#a719db98e0ff9a837610f76be33264680">value_type</a> &amp;value)</td></tr>
<tr class="separator:a2ef6723c183916276b0afc4a4c721475"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9128a806713bcc999ebd8a97ab77e765"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classaed2_1_1map_1_1iterator.html">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classaed2_1_1map.html#a9128a806713bcc999ebd8a97ab77e765">insert_or_assign</a> (const <a class="el" href="classaed2_1_1map.html#a719db98e0ff9a837610f76be33264680">value_type</a> &amp;value)</td></tr>
<tr class="separator:a9128a806713bcc999ebd8a97ab77e765"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad8e796bf9c9c558e5ce6b61e116253fe"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classaed2_1_1map_1_1iterator.html">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classaed2_1_1map.html#ad8e796bf9c9c558e5ce6b61e116253fe">erase</a> (<a class="el" href="classaed2_1_1map_1_1const__iterator.html">const_iterator</a> pos)</td></tr>
<tr class="memdesc:ad8e796bf9c9c558e5ce6b61e116253fe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Elimina el valor apuntado por {pos}.  <a href="#ad8e796bf9c9c558e5ce6b61e116253fe">More...</a><br /></td></tr>
<tr class="separator:ad8e796bf9c9c558e5ce6b61e116253fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a98b9f200c64ce02dfb67902ee00e375a"><td class="memItemLeft" align="right" valign="top"><a id="a98b9f200c64ce02dfb67902ee00e375a"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>transplant</b> (Node *u, Node *v)</td></tr>
<tr class="separator:a98b9f200c64ce02dfb67902ee00e375a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Construcción, asignación y destrucción</div></td></tr>
<tr class="memitem:a64da1d965b13eb28cdb3837bc17a18cf"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classaed2_1_1map.html#a64da1d965b13eb28cdb3837bc17a18cf">map</a> (Compare c=Compare())</td></tr>
<tr class="memdesc:a64da1d965b13eb28cdb3837bc17a18cf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Crea un diccionario vacio.  <a href="#a64da1d965b13eb28cdb3837bc17a18cf">More...</a><br /></td></tr>
<tr class="separator:a64da1d965b13eb28cdb3837bc17a18cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7a77950a3d8e637bfa7cf5dcd904f257"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classaed2_1_1map.html#a7a77950a3d8e637bfa7cf5dcd904f257">map</a> (const <a class="el" href="classaed2_1_1map.html">map</a> &amp;other)</td></tr>
<tr class="memdesc:a7a77950a3d8e637bfa7cf5dcd904f257"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor por copia.  <a href="#a7a77950a3d8e637bfa7cf5dcd904f257">More...</a><br /></td></tr>
<tr class="separator:a7a77950a3d8e637bfa7cf5dcd904f257"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5d336f3248572beb56be383dcc95cfeb"><td class="memTemplParams" colspan="2">template&lt;class iterator &gt; </td></tr>
<tr class="memitem:a5d336f3248572beb56be383dcc95cfeb"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classaed2_1_1map.html#a5d336f3248572beb56be383dcc95cfeb">map</a> (<a class="el" href="classaed2_1_1map_1_1iterator.html">iterator</a> first, <a class="el" href="classaed2_1_1map_1_1iterator.html">iterator</a> last, Compare c=Compare())</td></tr>
<tr class="memdesc:a5d336f3248572beb56be383dcc95cfeb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Crea un diccionario con los elementos del rango [{first}, {last})  <a href="#a5d336f3248572beb56be383dcc95cfeb">More...</a><br /></td></tr>
<tr class="separator:a5d336f3248572beb56be383dcc95cfeb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac606d334809066929522964d45e76317"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classaed2_1_1map.html">map</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classaed2_1_1map.html#ac606d334809066929522964d45e76317">operator=</a> (<a class="el" href="classaed2_1_1map.html">map</a> other)</td></tr>
<tr class="memdesc:ac606d334809066929522964d45e76317"><td class="mdescLeft">&#160;</td><td class="mdescRight">Operador de asignación.  <a href="#ac606d334809066929522964d45e76317">More...</a><br /></td></tr>
<tr class="separator:ac606d334809066929522964d45e76317"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab22c9a85c2dadbc286cd30e97069a8e6"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classaed2_1_1map.html#ab22c9a85c2dadbc286cd30e97069a8e6">~map</a> ()</td></tr>
<tr class="memdesc:ab22c9a85c2dadbc286cd30e97069a8e6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destructor.  <a href="#ab22c9a85c2dadbc286cd30e97069a8e6">More...</a><br /></td></tr>
<tr class="separator:ab22c9a85c2dadbc286cd30e97069a8e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a64da1d965b13eb28cdb3837bc17a18cf"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classaed2_1_1map.html#a64da1d965b13eb28cdb3837bc17a18cf">map</a> (Compare c=Compare())</td></tr>
<tr class="memdesc:a64da1d965b13eb28cdb3837bc17a18cf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Crea un diccionario vacio.  <a href="#a64da1d965b13eb28cdb3837bc17a18cf">More...</a><br /></td></tr>
<tr class="separator:a64da1d965b13eb28cdb3837bc17a18cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7a77950a3d8e637bfa7cf5dcd904f257"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classaed2_1_1map.html#a7a77950a3d8e637bfa7cf5dcd904f257">map</a> (const <a class="el" href="classaed2_1_1map.html">map</a> &amp;other)</td></tr>
<tr class="memdesc:a7a77950a3d8e637bfa7cf5dcd904f257"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor por copia.  <a href="#a7a77950a3d8e637bfa7cf5dcd904f257">More...</a><br /></td></tr>
<tr class="separator:a7a77950a3d8e637bfa7cf5dcd904f257"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5d336f3248572beb56be383dcc95cfeb"><td class="memTemplParams" colspan="2">template&lt;class iterator &gt; </td></tr>
<tr class="memitem:a5d336f3248572beb56be383dcc95cfeb"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classaed2_1_1map.html#a5d336f3248572beb56be383dcc95cfeb">map</a> (<a class="el" href="classaed2_1_1map_1_1iterator.html">iterator</a> first, <a class="el" href="classaed2_1_1map_1_1iterator.html">iterator</a> last, Compare c=Compare())</td></tr>
<tr class="memdesc:a5d336f3248572beb56be383dcc95cfeb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Crea un diccionario con los elementos del rango [{first}, {last})  <a href="#a5d336f3248572beb56be383dcc95cfeb">More...</a><br /></td></tr>
<tr class="separator:a5d336f3248572beb56be383dcc95cfeb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac606d334809066929522964d45e76317"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classaed2_1_1map.html">map</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classaed2_1_1map.html#ac606d334809066929522964d45e76317">operator=</a> (<a class="el" href="classaed2_1_1map.html">map</a> other)</td></tr>
<tr class="memdesc:ac606d334809066929522964d45e76317"><td class="mdescLeft">&#160;</td><td class="mdescRight">Operador de asignación.  <a href="#ac606d334809066929522964d45e76317">More...</a><br /></td></tr>
<tr class="separator:ac606d334809066929522964d45e76317"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab22c9a85c2dadbc286cd30e97069a8e6"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classaed2_1_1map.html#ab22c9a85c2dadbc286cd30e97069a8e6">~map</a> ()</td></tr>
<tr class="memdesc:ab22c9a85c2dadbc286cd30e97069a8e6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destructor.  <a href="#ab22c9a85c2dadbc286cd30e97069a8e6">More...</a><br /></td></tr>
<tr class="separator:ab22c9a85c2dadbc286cd30e97069a8e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Busqueda y acceso a los valores</div></td></tr>
<tr class="memitem:a579c9179b42175c23a1013ac7f1b876c"><td class="memItemLeft" align="right" valign="top">const Meaning &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classaed2_1_1map.html#a579c9179b42175c23a1013ac7f1b876c">at</a> (const Key &amp;key) const</td></tr>
<tr class="memdesc:a579c9179b42175c23a1013ac7f1b876c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Devuelve el significado asociado a {key}.  <a href="#a579c9179b42175c23a1013ac7f1b876c">More...</a><br /></td></tr>
<tr class="separator:a579c9179b42175c23a1013ac7f1b876c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b21c09f59a83b6ee45432dcfa61f4a1"><td class="memItemLeft" align="right" valign="top">Meaning &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classaed2_1_1map.html#a6b21c09f59a83b6ee45432dcfa61f4a1">at</a> (const Key &amp;key)</td></tr>
<tr class="separator:a6b21c09f59a83b6ee45432dcfa61f4a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a96f23896164ab47bee48c26b803f9801"><td class="memItemLeft" align="right" valign="top">Meaning &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classaed2_1_1map.html#a96f23896164ab47bee48c26b803f9801">operator[]</a> (const Key &amp;key)</td></tr>
<tr class="memdesc:a96f23896164ab47bee48c26b803f9801"><td class="mdescLeft">&#160;</td><td class="mdescRight">Devuelve el significado asociado a {key}, asegurando su existencia.  <a href="#a96f23896164ab47bee48c26b803f9801">More...</a><br /></td></tr>
<tr class="separator:a96f23896164ab47bee48c26b803f9801"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afd0fc1a8234888e61e0e615de7e245b8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classaed2_1_1map_1_1iterator.html">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classaed2_1_1map.html#afd0fc1a8234888e61e0e615de7e245b8">find</a> (const Key &amp;key)</td></tr>
<tr class="memdesc:afd0fc1a8234888e61e0e615de7e245b8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Devuelve un iterador a la posicion del valor con clave {key}.  <a href="#afd0fc1a8234888e61e0e615de7e245b8">More...</a><br /></td></tr>
<tr class="separator:afd0fc1a8234888e61e0e615de7e245b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adbf6f4ce01a16ca506e3c75fc2843882"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classaed2_1_1map_1_1const__iterator.html">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classaed2_1_1map.html#adbf6f4ce01a16ca506e3c75fc2843882">find</a> (const Key &amp;key) const</td></tr>
<tr class="separator:adbf6f4ce01a16ca506e3c75fc2843882"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a62075a47afdf89267c5462f88164af3d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classaed2_1_1map_1_1const__iterator.html">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classaed2_1_1map.html#a62075a47afdf89267c5462f88164af3d">lower_bound</a> (const Key &amp;key) const</td></tr>
<tr class="memdesc:a62075a47afdf89267c5462f88164af3d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Devuelve un iterador al primer valor con clave mayor o igual a {key}.  <a href="#a62075a47afdf89267c5462f88164af3d">More...</a><br /></td></tr>
<tr class="separator:a62075a47afdf89267c5462f88164af3d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a07b3dd65557c59ee085e5f211269c6b3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classaed2_1_1map_1_1iterator.html">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classaed2_1_1map.html#a07b3dd65557c59ee085e5f211269c6b3">lower_bound</a> (const Key &amp;key)</td></tr>
<tr class="separator:a07b3dd65557c59ee085e5f211269c6b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a579c9179b42175c23a1013ac7f1b876c"><td class="memItemLeft" align="right" valign="top">const Meaning &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classaed2_1_1map.html#a579c9179b42175c23a1013ac7f1b876c">at</a> (const Key &amp;key) const</td></tr>
<tr class="memdesc:a579c9179b42175c23a1013ac7f1b876c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Devuelve el significado asociado a {key}.  <a href="#a579c9179b42175c23a1013ac7f1b876c">More...</a><br /></td></tr>
<tr class="separator:a579c9179b42175c23a1013ac7f1b876c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b21c09f59a83b6ee45432dcfa61f4a1"><td class="memItemLeft" align="right" valign="top">Meaning &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classaed2_1_1map.html#a6b21c09f59a83b6ee45432dcfa61f4a1">at</a> (const Key &amp;key)</td></tr>
<tr class="separator:a6b21c09f59a83b6ee45432dcfa61f4a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a96f23896164ab47bee48c26b803f9801"><td class="memItemLeft" align="right" valign="top">Meaning &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classaed2_1_1map.html#a96f23896164ab47bee48c26b803f9801">operator[]</a> (const Key &amp;key)</td></tr>
<tr class="memdesc:a96f23896164ab47bee48c26b803f9801"><td class="mdescLeft">&#160;</td><td class="mdescRight">Devuelve el significado asociado a {key}, asegurando su existencia.  <a href="#a96f23896164ab47bee48c26b803f9801">More...</a><br /></td></tr>
<tr class="separator:a96f23896164ab47bee48c26b803f9801"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afd0fc1a8234888e61e0e615de7e245b8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classaed2_1_1map_1_1iterator.html">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classaed2_1_1map.html#afd0fc1a8234888e61e0e615de7e245b8">find</a> (const Key &amp;key)</td></tr>
<tr class="memdesc:afd0fc1a8234888e61e0e615de7e245b8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Devuelve un iterador a la posicion del valor con clave {key}.  <a href="#afd0fc1a8234888e61e0e615de7e245b8">More...</a><br /></td></tr>
<tr class="separator:afd0fc1a8234888e61e0e615de7e245b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adbf6f4ce01a16ca506e3c75fc2843882"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classaed2_1_1map_1_1const__iterator.html">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classaed2_1_1map.html#adbf6f4ce01a16ca506e3c75fc2843882">find</a> (const Key &amp;key) const</td></tr>
<tr class="separator:adbf6f4ce01a16ca506e3c75fc2843882"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a62075a47afdf89267c5462f88164af3d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classaed2_1_1map_1_1const__iterator.html">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classaed2_1_1map.html#a62075a47afdf89267c5462f88164af3d">lower_bound</a> (const Key &amp;key) const</td></tr>
<tr class="memdesc:a62075a47afdf89267c5462f88164af3d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Devuelve un iterador al primer valor con clave mayor o igual a {key}.  <a href="#a62075a47afdf89267c5462f88164af3d">More...</a><br /></td></tr>
<tr class="separator:a62075a47afdf89267c5462f88164af3d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a07b3dd65557c59ee085e5f211269c6b3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classaed2_1_1map_1_1iterator.html">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classaed2_1_1map.html#a07b3dd65557c59ee085e5f211269c6b3">lower_bound</a> (const Key &amp;key)</td></tr>
<tr class="separator:a07b3dd65557c59ee085e5f211269c6b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Tamaño del diccionario</div></td></tr>
<tr class="memitem:a0dcb39283f4877ae59cb756ed1d0c048"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classaed2_1_1map.html#a0dcb39283f4877ae59cb756ed1d0c048">empty</a> () const</td></tr>
<tr class="memdesc:a0dcb39283f4877ae59cb756ed1d0c048"><td class="mdescLeft">&#160;</td><td class="mdescRight">Indica si el diccionario esta vacío.  <a href="#a0dcb39283f4877ae59cb756ed1d0c048">More...</a><br /></td></tr>
<tr class="separator:a0dcb39283f4877ae59cb756ed1d0c048"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa6e806b3be6dc0da79adbfae08b571bf"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classaed2_1_1map.html#aa6e806b3be6dc0da79adbfae08b571bf">size</a> () const</td></tr>
<tr class="memdesc:aa6e806b3be6dc0da79adbfae08b571bf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Devuelve la cantidad de valores en el diccionario.  <a href="#aa6e806b3be6dc0da79adbfae08b571bf">More...</a><br /></td></tr>
<tr class="separator:aa6e806b3be6dc0da79adbfae08b571bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0dcb39283f4877ae59cb756ed1d0c048"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classaed2_1_1map.html#a0dcb39283f4877ae59cb756ed1d0c048">empty</a> () const</td></tr>
<tr class="memdesc:a0dcb39283f4877ae59cb756ed1d0c048"><td class="mdescLeft">&#160;</td><td class="mdescRight">Indica si el diccionario esta vacío.  <a href="#a0dcb39283f4877ae59cb756ed1d0c048">More...</a><br /></td></tr>
<tr class="separator:a0dcb39283f4877ae59cb756ed1d0c048"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa6e806b3be6dc0da79adbfae08b571bf"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classaed2_1_1map.html#aa6e806b3be6dc0da79adbfae08b571bf">size</a> () const</td></tr>
<tr class="memdesc:aa6e806b3be6dc0da79adbfae08b571bf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Devuelve la cantidad de valores en el diccionario.  <a href="#aa6e806b3be6dc0da79adbfae08b571bf">More...</a><br /></td></tr>
<tr class="separator:aa6e806b3be6dc0da79adbfae08b571bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Inserción, borrado y modificación</div></td></tr>
<tr class="memitem:a6941cde9a79c27f054b5c97a587a1854"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classaed2_1_1map_1_1iterator.html">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classaed2_1_1map.html#a6941cde9a79c27f054b5c97a587a1854">insert</a> (<a class="el" href="classaed2_1_1map_1_1const__iterator.html">const_iterator</a> hint, const <a class="el" href="classaed2_1_1map.html#a719db98e0ff9a837610f76be33264680">value_type</a> &amp;value)</td></tr>
<tr class="memdesc:a6941cde9a79c27f054b5c97a587a1854"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserta {value} en el diccionario.  <a href="#a6941cde9a79c27f054b5c97a587a1854">More...</a><br /></td></tr>
<tr class="separator:a6941cde9a79c27f054b5c97a587a1854"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a71e3ecf911958188e1e2fd7d76b2b1e9"><td class="memItemLeft" align="right" valign="top"><a id="a71e3ecf911958188e1e2fd7d76b2b1e9"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>insert_fixup</b> (<a class="el" href="classaed2_1_1map_1_1iterator.html">iterator</a> it, const <a class="el" href="classaed2_1_1map.html#a719db98e0ff9a837610f76be33264680">value_type</a> &amp;value)</td></tr>
<tr class="separator:a71e3ecf911958188e1e2fd7d76b2b1e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1f4b383ece3e22680802d27aa11b623a"><td class="memItemLeft" align="right" valign="top"><a id="a1f4b383ece3e22680802d27aa11b623a"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>left_rotate</b> (<a class="el" href="classaed2_1_1map_1_1iterator.html">iterator</a> it)</td></tr>
<tr class="separator:a1f4b383ece3e22680802d27aa11b623a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af339eb8e0af78bc07ad55ddd97938ee7"><td class="memItemLeft" align="right" valign="top"><a id="af339eb8e0af78bc07ad55ddd97938ee7"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>right_rotate</b> (<a class="el" href="classaed2_1_1map_1_1iterator.html">iterator</a> it)</td></tr>
<tr class="separator:af339eb8e0af78bc07ad55ddd97938ee7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a60aacba06b1579630b3c8e996cf248c8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classaed2_1_1map_1_1iterator.html">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classaed2_1_1map.html#a60aacba06b1579630b3c8e996cf248c8">insert</a> (const <a class="el" href="classaed2_1_1map.html#a719db98e0ff9a837610f76be33264680">value_type</a> &amp;value)</td></tr>
<tr class="separator:a60aacba06b1579630b3c8e996cf248c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6941cde9a79c27f054b5c97a587a1854"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classaed2_1_1map_1_1iterator.html">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classaed2_1_1map.html#a6941cde9a79c27f054b5c97a587a1854">insert</a> (<a class="el" href="classaed2_1_1map_1_1const__iterator.html">const_iterator</a> hint, const <a class="el" href="classaed2_1_1map.html#a719db98e0ff9a837610f76be33264680">value_type</a> &amp;value)</td></tr>
<tr class="memdesc:a6941cde9a79c27f054b5c97a587a1854"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserta {value} en el diccionario.  <a href="#a6941cde9a79c27f054b5c97a587a1854">More...</a><br /></td></tr>
<tr class="separator:a6941cde9a79c27f054b5c97a587a1854"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a905aa80287bf2a97cca5a9dda1c8ab12"><td class="memItemLeft" align="right" valign="top"><a id="a905aa80287bf2a97cca5a9dda1c8ab12"></a>
void <a class="el" href="classaed2_1_1map.html#a6941cde9a79c27f054b5c97a587a1854">insert</a>&#160;</td><td class="memItemRight" valign="bottom"><b>fixup</b> (<a class="el" href="classaed2_1_1map_1_1iterator.html">iterator</a> it, const <a class="el" href="classaed2_1_1map.html#a719db98e0ff9a837610f76be33264680">value_type</a> &amp;value)</td></tr>
<tr class="separator:a905aa80287bf2a97cca5a9dda1c8ab12"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1f4b383ece3e22680802d27aa11b623a"><td class="memItemLeft" align="right" valign="top"><a id="a1f4b383ece3e22680802d27aa11b623a"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>left_rotate</b> (<a class="el" href="classaed2_1_1map_1_1iterator.html">iterator</a> it)</td></tr>
<tr class="separator:a1f4b383ece3e22680802d27aa11b623a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af339eb8e0af78bc07ad55ddd97938ee7"><td class="memItemLeft" align="right" valign="top"><a id="af339eb8e0af78bc07ad55ddd97938ee7"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>right_rotate</b> (<a class="el" href="classaed2_1_1map_1_1iterator.html">iterator</a> it)</td></tr>
<tr class="separator:af339eb8e0af78bc07ad55ddd97938ee7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a60aacba06b1579630b3c8e996cf248c8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classaed2_1_1map_1_1iterator.html">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classaed2_1_1map.html#a60aacba06b1579630b3c8e996cf248c8">insert</a> (const <a class="el" href="classaed2_1_1map.html#a719db98e0ff9a837610f76be33264680">value_type</a> &amp;value)</td></tr>
<tr class="separator:a60aacba06b1579630b3c8e996cf248c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Recorridos e iteradores</div></td></tr>
<tr class="memitem:a58a95705d54b3dda7f775ce5a22225cb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classaed2_1_1map_1_1iterator.html">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classaed2_1_1map.html#a58a95705d54b3dda7f775ce5a22225cb">begin</a> ()</td></tr>
<tr class="memdesc:a58a95705d54b3dda7f775ce5a22225cb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Devuelve un iterador al primer valor del diccionario.  <a href="#a58a95705d54b3dda7f775ce5a22225cb">More...</a><br /></td></tr>
<tr class="separator:a58a95705d54b3dda7f775ce5a22225cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af3b1818c2b44e37221cc3b131768555b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classaed2_1_1map_1_1const__iterator.html">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classaed2_1_1map.html#af3b1818c2b44e37221cc3b131768555b">begin</a> () const</td></tr>
<tr class="separator:af3b1818c2b44e37221cc3b131768555b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab96ad892caa28f193481a578f4956a2a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classaed2_1_1map_1_1const__iterator.html">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classaed2_1_1map.html#ab96ad892caa28f193481a578f4956a2a">cbegin</a> ()</td></tr>
<tr class="separator:ab96ad892caa28f193481a578f4956a2a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a76023e6a56cb625513e1b5ea028bf983"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classaed2_1_1map_1_1iterator.html">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classaed2_1_1map.html#a76023e6a56cb625513e1b5ea028bf983">end</a> ()</td></tr>
<tr class="memdesc:a76023e6a56cb625513e1b5ea028bf983"><td class="mdescLeft">&#160;</td><td class="mdescRight">Devuelve un iterador apuntando a la posición pasando-el-ultimo del diccionario.  <a href="#a76023e6a56cb625513e1b5ea028bf983">More...</a><br /></td></tr>
<tr class="separator:a76023e6a56cb625513e1b5ea028bf983"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a91e7cad1a638c55659c169d5574cd5d7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classaed2_1_1map_1_1const__iterator.html">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classaed2_1_1map.html#a91e7cad1a638c55659c169d5574cd5d7">end</a> () const</td></tr>
<tr class="separator:a91e7cad1a638c55659c169d5574cd5d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7bb91e94cbc875f1a011b142ef877912"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classaed2_1_1map_1_1const__iterator.html">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classaed2_1_1map.html#a7bb91e94cbc875f1a011b142ef877912">cend</a> ()</td></tr>
<tr class="separator:a7bb91e94cbc875f1a011b142ef877912"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac412d3902112122c1bffe2d4283a4e9d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classaed2_1_1map.html#a8e6a592062260177fd73b2f9897b1dd5">reverse_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classaed2_1_1map.html#ac412d3902112122c1bffe2d4283a4e9d">rbegin</a> ()</td></tr>
<tr class="memdesc:ac412d3902112122c1bffe2d4283a4e9d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Devuelve un iterador al primer valor del diccionario, en un recorrido al revés.  <a href="#ac412d3902112122c1bffe2d4283a4e9d">More...</a><br /></td></tr>
<tr class="separator:ac412d3902112122c1bffe2d4283a4e9d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a71ab53ab04f5e35a189c6576fddeb483"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classaed2_1_1map.html#aed66a216549d13078a3ea6978ea0b768">const_reverse_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classaed2_1_1map.html#a71ab53ab04f5e35a189c6576fddeb483">rbegin</a> () const</td></tr>
<tr class="separator:a71ab53ab04f5e35a189c6576fddeb483"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6ad62765a2b2e00247b9e35a7542b448"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classaed2_1_1map.html#aed66a216549d13078a3ea6978ea0b768">const_reverse_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classaed2_1_1map.html#a6ad62765a2b2e00247b9e35a7542b448">crbegin</a> ()</td></tr>
<tr class="separator:a6ad62765a2b2e00247b9e35a7542b448"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a277f03b4f4b6b98879e4e4921081801f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classaed2_1_1map.html#a8e6a592062260177fd73b2f9897b1dd5">reverse_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classaed2_1_1map.html#a277f03b4f4b6b98879e4e4921081801f">rend</a> ()</td></tr>
<tr class="memdesc:a277f03b4f4b6b98879e4e4921081801f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Devuelve un iterador apuntando a la posición pasando-el-ultimo del diccionario, en un recorrido al revés.  <a href="#a277f03b4f4b6b98879e4e4921081801f">More...</a><br /></td></tr>
<tr class="separator:a277f03b4f4b6b98879e4e4921081801f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7cf14a4b505505d0f074034b7399fb24"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classaed2_1_1map.html#aed66a216549d13078a3ea6978ea0b768">const_reverse_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classaed2_1_1map.html#a7cf14a4b505505d0f074034b7399fb24">rend</a> () const</td></tr>
<tr class="separator:a7cf14a4b505505d0f074034b7399fb24"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a40933b2efe1cb479de9195ea947244d1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classaed2_1_1map.html#aed66a216549d13078a3ea6978ea0b768">const_reverse_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classaed2_1_1map.html#a40933b2efe1cb479de9195ea947244d1">crend</a> ()</td></tr>
<tr class="separator:a40933b2efe1cb479de9195ea947244d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="friends"></a>
Friends</h2></td></tr>
<tr class="memitem:a67171474c4da6cc8efe0c7fafefd2b2d"><td class="memItemLeft" align="right" valign="top"><a id="a67171474c4da6cc8efe0c7fafefd2b2d"></a>
class&#160;</td><td class="memItemRight" valign="bottom"><b>iterator</b></td></tr>
<tr class="separator:a67171474c4da6cc8efe0c7fafefd2b2d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac220ce1c155db1ac44146c12d178056f"><td class="memItemLeft" align="right" valign="top"><a id="ac220ce1c155db1ac44146c12d178056f"></a>
class&#160;</td><td class="memItemRight" valign="bottom"><b>const_iterator</b></td></tr>
<tr class="separator:ac220ce1c155db1ac44146c12d178056f"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="related"></a>
Related Functions</h2></td></tr>
<tr><td class="ititle" colspan="2"><p>(Note that these are not member functions.) </p>
</td></tr>
<tr><td colspan="2"><div class="groupHeader">Operadores de comparación</div></td></tr>
<tr class="memitem:abfc51b39670220e79037ac067006e933"><td class="memTemplParams" colspan="2">template&lt;class K , class V , class C &gt; </td></tr>
<tr class="memitem:abfc51b39670220e79037ac067006e933"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classaed2_1_1map.html#abfc51b39670220e79037ac067006e933">operator==</a> (const <a class="el" href="classaed2_1_1map.html">map</a>&lt; K, V, C &gt; &amp;m1, const <a class="el" href="classaed2_1_1map.html">map</a>&lt; K, V, C &gt; &amp;m2)</td></tr>
<tr class="memdesc:abfc51b39670220e79037ac067006e933"><td class="mdescLeft">&#160;</td><td class="mdescRight">Operador de igualdad entre dos diccionarios.  <a href="#abfc51b39670220e79037ac067006e933">More...</a><br /></td></tr>
<tr class="separator:abfc51b39670220e79037ac067006e933"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abce0fa35c5b25fd67111c2e704616f09"><td class="memTemplParams" colspan="2">template&lt;class K , class V , class C &gt; </td></tr>
<tr class="memitem:abce0fa35c5b25fd67111c2e704616f09"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classaed2_1_1map.html#abce0fa35c5b25fd67111c2e704616f09">operator!=</a> (const <a class="el" href="classaed2_1_1map.html">map</a>&lt; K, V, C &gt; &amp;m1, const <a class="el" href="classaed2_1_1map.html">map</a>&lt; K, V, C &gt; &amp;m2)</td></tr>
<tr class="memdesc:abce0fa35c5b25fd67111c2e704616f09"><td class="mdescLeft">&#160;</td><td class="mdescRight">Renombre de not({m1} == {m2})  <a href="#abce0fa35c5b25fd67111c2e704616f09">More...</a><br /></td></tr>
<tr class="separator:abce0fa35c5b25fd67111c2e704616f09"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8ff07f6a24c290ea7e8f63ec7ab24f8d"><td class="memTemplParams" colspan="2">template&lt;class K , class V , class C &gt; </td></tr>
<tr class="memitem:a8ff07f6a24c290ea7e8f63ec7ab24f8d"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classaed2_1_1map.html#a8ff07f6a24c290ea7e8f63ec7ab24f8d">operator&lt;</a> (const <a class="el" href="classaed2_1_1map.html">map</a>&lt; K, V, C &gt; &amp;m1, const <a class="el" href="classaed2_1_1map.html">map</a>&lt; K, V, C &gt; &amp;m2)</td></tr>
<tr class="memdesc:a8ff07f6a24c290ea7e8f63ec7ab24f8d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Operador de orden lexicografico entre diccionarios.  <a href="#a8ff07f6a24c290ea7e8f63ec7ab24f8d">More...</a><br /></td></tr>
<tr class="separator:a8ff07f6a24c290ea7e8f63ec7ab24f8d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2000cd874b72034ce7fe730c811b6c63"><td class="memTemplParams" colspan="2">template&lt;class K , class V , class C &gt; </td></tr>
<tr class="memitem:a2000cd874b72034ce7fe730c811b6c63"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classaed2_1_1map.html#a2000cd874b72034ce7fe730c811b6c63">operator&gt;</a> (const <a class="el" href="classaed2_1_1map.html">map</a>&lt; K, V, C &gt; &amp;m1, const <a class="el" href="classaed2_1_1map.html">map</a>&lt; K, V, C &gt; &amp;m2)</td></tr>
<tr class="memdesc:a2000cd874b72034ce7fe730c811b6c63"><td class="mdescLeft">&#160;</td><td class="mdescRight">Renombre de {m2} &lt; {m1}.  <a href="#a2000cd874b72034ce7fe730c811b6c63">More...</a><br /></td></tr>
<tr class="separator:a2000cd874b72034ce7fe730c811b6c63"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afe374b37f17263d0cad3ee19a590d208"><td class="memTemplParams" colspan="2">template&lt;class K , class V , class C &gt; </td></tr>
<tr class="memitem:afe374b37f17263d0cad3ee19a590d208"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classaed2_1_1map.html#afe374b37f17263d0cad3ee19a590d208">operator&lt;=</a> (const <a class="el" href="classaed2_1_1map.html">map</a>&lt; K, V, C &gt; &amp;m1, const <a class="el" href="classaed2_1_1map.html">map</a>&lt; K, V, C &gt; &amp;m2)</td></tr>
<tr class="memdesc:afe374b37f17263d0cad3ee19a590d208"><td class="mdescLeft">&#160;</td><td class="mdescRight">Renombre de not({m2} &lt; {m1})  <a href="#afe374b37f17263d0cad3ee19a590d208">More...</a><br /></td></tr>
<tr class="separator:afe374b37f17263d0cad3ee19a590d208"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a093a6d1a055339c5fc6297a1d47a9159"><td class="memTemplParams" colspan="2">template&lt;class K , class V , class C &gt; </td></tr>
<tr class="memitem:a093a6d1a055339c5fc6297a1d47a9159"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classaed2_1_1map.html#a093a6d1a055339c5fc6297a1d47a9159">operator&gt;=</a> (const <a class="el" href="classaed2_1_1map.html">map</a>&lt; K, V, C &gt; &amp;m1, const <a class="el" href="classaed2_1_1map.html">map</a>&lt; K, V, C &gt; &amp;m2)</td></tr>
<tr class="memdesc:a093a6d1a055339c5fc6297a1d47a9159"><td class="mdescLeft">&#160;</td><td class="mdescRight">Renombre de not({m1} &lt; {m2})  <a href="#a093a6d1a055339c5fc6297a1d47a9159">More...</a><br /></td></tr>
<tr class="separator:a093a6d1a055339c5fc6297a1d47a9159"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab32f94f4767358534ab704c98d23ad89"><td class="memTemplParams" colspan="2">template&lt;class K , class V , class C &gt; </td></tr>
<tr class="memitem:ab32f94f4767358534ab704c98d23ad89"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classaed2_1_1map.html#ab32f94f4767358534ab704c98d23ad89">operator==</a> (const <a class="el" href="classaed2_1_1map.html">map</a>&lt; K, V, C &gt; &amp;m)</td></tr>
<tr class="memdesc:ab32f94f4767358534ab704c98d23ad89"><td class="mdescLeft">&#160;</td><td class="mdescRight">Operador de igualdad entre dos diccionarios.  <a href="#ab32f94f4767358534ab704c98d23ad89">More...</a><br /></td></tr>
<tr class="separator:ab32f94f4767358534ab704c98d23ad89"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a11627296a0eb71c87e69caa89fbd94eb"><td class="memTemplParams" colspan="2">template&lt;class K , class V , class C &gt; </td></tr>
<tr class="memitem:a11627296a0eb71c87e69caa89fbd94eb"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classaed2_1_1map.html#a11627296a0eb71c87e69caa89fbd94eb">operator!=</a> (const <a class="el" href="classaed2_1_1map.html">map</a>&lt; K, V, C &gt; &amp;m)</td></tr>
<tr class="memdesc:a11627296a0eb71c87e69caa89fbd94eb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Renombre de not({m1} == {m2})  <a href="#a11627296a0eb71c87e69caa89fbd94eb">More...</a><br /></td></tr>
<tr class="separator:a11627296a0eb71c87e69caa89fbd94eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d766795e9a996ed79f8c08fbd1676cd"><td class="memTemplParams" colspan="2">template&lt;class K , class V , class C &gt; </td></tr>
<tr class="memitem:a4d766795e9a996ed79f8c08fbd1676cd"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classaed2_1_1map.html#a4d766795e9a996ed79f8c08fbd1676cd">operator&lt;</a> (const <a class="el" href="classaed2_1_1map.html">map</a>&lt; K, V, C &gt; &amp;m)</td></tr>
<tr class="memdesc:a4d766795e9a996ed79f8c08fbd1676cd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Operador de orden lexicografico entre diccionarios.  <a href="#a4d766795e9a996ed79f8c08fbd1676cd">More...</a><br /></td></tr>
<tr class="separator:a4d766795e9a996ed79f8c08fbd1676cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a964e8d831c17d77f457eb87a2f22d0d0"><td class="memTemplParams" colspan="2">template&lt;class K , class V , class C &gt; </td></tr>
<tr class="memitem:a964e8d831c17d77f457eb87a2f22d0d0"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classaed2_1_1map.html#a964e8d831c17d77f457eb87a2f22d0d0">operator&gt;</a> (const <a class="el" href="classaed2_1_1map.html">map</a>&lt; K, V, C &gt; &amp;m)</td></tr>
<tr class="memdesc:a964e8d831c17d77f457eb87a2f22d0d0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Renombre de {m2} &lt; {m1}.  <a href="#a964e8d831c17d77f457eb87a2f22d0d0">More...</a><br /></td></tr>
<tr class="separator:a964e8d831c17d77f457eb87a2f22d0d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a42f66578aa7e80b91eded54ac6b745cf"><td class="memTemplParams" colspan="2">template&lt;class K , class V , class C &gt; </td></tr>
<tr class="memitem:a42f66578aa7e80b91eded54ac6b745cf"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classaed2_1_1map.html#a42f66578aa7e80b91eded54ac6b745cf">operator&lt;=</a> (const <a class="el" href="classaed2_1_1map.html">map</a>&lt; K, V, C &gt; &amp;m)</td></tr>
<tr class="memdesc:a42f66578aa7e80b91eded54ac6b745cf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Renombre de not({m2} &lt; {m1})  <a href="#a42f66578aa7e80b91eded54ac6b745cf">More...</a><br /></td></tr>
<tr class="separator:a42f66578aa7e80b91eded54ac6b745cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a68bf5a52b77446e43584fb67d22c365e"><td class="memTemplParams" colspan="2">template&lt;class K , class V , class C &gt; </td></tr>
<tr class="memitem:a68bf5a52b77446e43584fb67d22c365e"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classaed2_1_1map.html#a68bf5a52b77446e43584fb67d22c365e">operator&gt;=</a> (const <a class="el" href="classaed2_1_1map.html">map</a>&lt; K, V, C &gt; &amp;m)</td></tr>
<tr class="memdesc:a68bf5a52b77446e43584fb67d22c365e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Renombre de not({m1} &lt; {m2})  <a href="#a68bf5a52b77446e43584fb67d22c365e">More...</a><br /></td></tr>
<tr class="separator:a68bf5a52b77446e43584fb67d22c365e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Implementación de swappable</div></td></tr>
<tr class="memitem:a119cb2938bbc11c25ebd4fb824782a72"><td class="memTemplParams" colspan="2">template&lt;class K , class V , class C &gt; </td></tr>
<tr class="memitem:a119cb2938bbc11c25ebd4fb824782a72"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classaed2_1_1map.html#a119cb2938bbc11c25ebd4fb824782a72">swap</a> (<a class="el" href="classaed2_1_1map.html">map</a>&lt; K, V, C &gt; &amp;m1, <a class="el" href="classaed2_1_1map.html">map</a>&lt; K, V, C &gt; &amp;m2)</td></tr>
<tr class="memdesc:a119cb2938bbc11c25ebd4fb824782a72"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implementa la función swap para cumplir con el concepto swappable.  <a href="#a119cb2938bbc11c25ebd4fb824782a72">More...</a><br /></td></tr>
<tr class="separator:a119cb2938bbc11c25ebd4fb824782a72"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae9604c72935a908c0c98a9f40bc38eda"><td class="memTemplParams" colspan="2">template&lt;class K , class V , class C &gt; </td></tr>
<tr class="memitem:ae9604c72935a908c0c98a9f40bc38eda"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classaed2_1_1map.html#ae9604c72935a908c0c98a9f40bc38eda">swap</a> (<a class="el" href="classaed2_1_1map.html">map</a>&lt; K, V, C &gt; &amp;m)</td></tr>
<tr class="memdesc:ae9604c72935a908c0c98a9f40bc38eda"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implementa la función swap para cumplir con el concepto swappable.  <a href="#ae9604c72935a908c0c98a9f40bc38eda">More...</a><br /></td></tr>
<tr class="separator:ae9604c72935a908c0c98a9f40bc38eda"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;class Key, class Meaning, class Compare = std::less&lt;Key&gt;&gt;<br />
class aed2::map&lt; Key, Meaning, Compare &gt;</h3>

<p>Modulo que implementa un diccionario. </p>
<p>El módulo <a class="el" href="classaed2_1_1map.html" title="Modulo que implementa un diccionario. ">aed2::map</a> implementa un diccionario <b>ordenado</b> que permite la inserción, modificación, borrado y búsqueda de valores en tiempo logarítmico. Asimismo, permite el acceso y modificación del primer y último valor en tiempo constante, al igual que el borrado e inserción del primer y último valor en tiempo constante amortizado. En forma concisa, este módulo implementa lo que se conoce como un árbol red-black, donde los nodos tienen punteros a los padres y se puede acceder al primer y último nodo de la secuencia inorder.</p>
<p>En cuanto al recorrido de los elementos, se provee un iterador bidireccional con el cual se puede eliminar y agregar elementos en tiempo constante amortizado. De esta forma, se pueden aplicar filtros recorriendo una única vez la estructura. Este iterador sigue la interfaz de C++, con lo cual el iterador siempre se encuentra <em>sobre</em> un elemento. El iterador se puede inicializar tanto apuntando al inicio como al fin. En consecuencia, se puede recorrer el reverso de la secuencia inorder en forma eficiente. Siendo un iterador de C++, disponemos de una posición <em>pasando-el-último</em> que se utiliza para indicar el fin del recorrido o si la posición es inválida.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Key</td><td>tipo de la clave. Ver <a class="el" href="Interfaz.html">Descripción de la interfaz</a>. </td></tr>
    <tr><td class="paramname">Meaning</td><td>tipo del significado. Ver <a class="el" href="Interfaz.html">Descripción de la interfaz</a>. </td></tr>
    <tr><td class="paramname">Compare</td><td>tipo del comparador. Ver <a class="el" href="Interfaz.html">Descripción de la interfaz</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Terminología para describir las complejidades temporales</dt><dd>Para describir la complejidad temporal de las operaciones, vamos a llamar:<ul>
<li>(<em>d</em>): a la cantidad de elementos del diccionario <em>d</em> </li>
<li>(<em>v1</em>, <em>v2</em>): al costo de comparar dos valores <em>v1</em> y <em>v2</em> </li>
<li>(<em>d</em>): al maximo costo posible para las comparaciones de elementos en <em>d</em> </li>
<li>(<em>v</em>): al costo de copiar un valor <em>v</em> </li>
<li>(<em>d</em>): a la sumatoria de los costo de copiar todos los elementos de <em>d</em> </li>
<li>(<em>v</em>): al costo de destruir un valor <em>v</em> </li>
<li>(<em>d</em>): a la sumatoria de los costos de destruir todos los elementos de <em>d</em> </li>
</ul>
</dd></dl>
<dl class="section user"><dt>Funciones esperadas en los parámetros del template</dt><dd><p class="startdd">Vamos a usar el renombre value_type = std::pair&lt;const Key,Meaning&gt;</p>
<div class="fragment"><div class="line"><span class="comment">//Constructor por copia de valores.</span></div><div class="line"><span class="comment">//Complejidad: O(copy(other))</span></div><div class="line"><a class="code" href="classaed2_1_1map.html#a719db98e0ff9a837610f76be33264680">value_type</a>(<span class="keyword">const</span> value_type&amp; other);</div><div class="line"></div><div class="line"><span class="comment">//Destructor de los valores</span></div><div class="line"><span class="comment">//Complejidad: O(del(*this))</span></div><div class="line">~value_type();</div><div class="line"></div><div class="line"><span class="keyword">struct </span>Compare {</div><div class="line">  <span class="comment">//Comparacion de dos valores</span></div><div class="line">  <span class="comment">//Complejidad: O(cmp(v1, v2))</span></div><div class="line">  <span class="keywordtype">bool</span> operator()(<span class="keyword">const</span> value_type&amp; v1, <span class="keyword">const</span> value_type&amp; v2) <span class="keyword">const</span>;</div><div class="line">};</div></div><!-- fragment --> </dd></dl>
<dl class="section user"><dt>Aspectos generales de aliasing</dt><dd>Ninguna operación invalida un iterador asociado a un valor de la estructura, salvo que se elimine el valor apuntado por dicho iterador. Asimismo, niguna operación, salvo swap y el destructor, invalida el puntero pasando-el-último.</dd></dl>
<dl class="section user"><dt>Se explica con</dt><dd>Diccionario({Key}, {Meaning}) con parámetro formal  = f.operator() para algún f de tipo {Compare}.</dd></dl>
<dl class="section attention"><dt>Attention</dt><dd>No tenemos forma en AED2 de decir que el parámetro formal se define en tiempo de ejecución, como ocurre en este caso. </dd></dl>
</div><h2 class="groupheader">Member Typedef Documentation</h2>
<a id="aed66a216549d13078a3ea6978ea0b768"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aed66a216549d13078a3ea6978ea0b768">&#9670;&nbsp;</a></span>const_reverse_iterator <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key, class Meaning, class Compare = std::less&lt;Key&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classaed2_1_1map.html">aed2::map</a>&lt; Key, Meaning, Compare &gt;::<a class="el" href="classaed2_1_1map.html#aed66a216549d13078a3ea6978ea0b768">const_reverse_iterator</a> =  std::reverse_iterator&lt;<a class="el" href="classaed2_1_1map_1_1const__iterator.html">const_iterator</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Iterador para recorrer un diccionario constante en orden inverso. </p>
<p>Este tipo implementa un iterador que puede recorrer el diccionario en el orden inverso. Es un renombre, porque nos aprovechamos del adaptador <code>std::reverse_iterator</code> que implementa un iterador reverso para <b>cualquier</b> iterador bidireccional que respete el estándar C++. Su interfaz y complejidades puede consultarse en la documentación de la biblioteca estándar</p>
<dl class="section see"><dt>See also</dt><dd><a href="http://en.cppreference.com/w/cpp/iterator/reverse_iterator">Documentación de <code>std::reverse_iterator</code></a> </dd></dl>

</div>
</div>
<a id="aed66a216549d13078a3ea6978ea0b768"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aed66a216549d13078a3ea6978ea0b768">&#9670;&nbsp;</a></span>const_reverse_iterator <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key, class Meaning, class Compare = std::less&lt;Key&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classaed2_1_1map.html">aed2::map</a>&lt; Key, Meaning, Compare &gt;::<a class="el" href="classaed2_1_1map.html#aed66a216549d13078a3ea6978ea0b768">const_reverse_iterator</a> =  std::reverse_iterator&lt;<a class="el" href="classaed2_1_1map_1_1const__iterator.html">const_iterator</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Iterador para recorrer un diccionario constante en orden inverso. </p>
<p>Este tipo implementa un iterador que puede recorrer el diccionario en el orden inverso. Es un renombre, porque nos aprovechamos del adaptador <code>std::reverse_iterator</code> que implementa un iterador reverso para <b>cualquier</b> iterador bidireccional que respete el estándar C++. Su interfaz y complejidades puede consultarse en la documentación de la biblioteca estándar</p>
<dl class="section see"><dt>See also</dt><dd><a href="http://en.cppreference.com/w/cpp/iterator/reverse_iterator">Documentación de <code>std::reverse_iterator</code></a> </dd></dl>

</div>
</div>
<a id="a8e6a592062260177fd73b2f9897b1dd5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8e6a592062260177fd73b2f9897b1dd5">&#9670;&nbsp;</a></span>reverse_iterator <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key, class Meaning, class Compare = std::less&lt;Key&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classaed2_1_1map.html">aed2::map</a>&lt; Key, Meaning, Compare &gt;::<a class="el" href="classaed2_1_1map.html#a8e6a592062260177fd73b2f9897b1dd5">reverse_iterator</a> =  std::reverse_iterator&lt;<a class="el" href="classaed2_1_1map_1_1iterator.html">iterator</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Iterador para recorrer un diccionario en orden inverso. </p>
<p>Este tipo implementa un iterador que puede recorrer el diccionario en el orden inverso. Es un renombre, porque nos aprovechamos del adaptador <code>std::reverse_iterator</code> que implementa un iterador reverso para <b>cualquier</b> iterador bidireccional que respete el estándar C++. Su interfaz y complejidades pueden consultarse en la documentación de la biblioteca estándar</p>
<dl class="section see"><dt>See also</dt><dd><a href="http://en.cppreference.com/w/cpp/iterator/reverse_iterator">Documentación de <code>std::reverse_iterator</code></a> </dd></dl>

</div>
</div>
<a id="a8e6a592062260177fd73b2f9897b1dd5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8e6a592062260177fd73b2f9897b1dd5">&#9670;&nbsp;</a></span>reverse_iterator <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key, class Meaning, class Compare = std::less&lt;Key&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classaed2_1_1map.html">aed2::map</a>&lt; Key, Meaning, Compare &gt;::<a class="el" href="classaed2_1_1map.html#a8e6a592062260177fd73b2f9897b1dd5">reverse_iterator</a> =  std::reverse_iterator&lt;<a class="el" href="classaed2_1_1map_1_1iterator.html">iterator</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Iterador para recorrer un diccionario en orden inverso. </p>
<p>Este tipo implementa un iterador que puede recorrer el diccionario en el orden inverso. Es un renombre, porque nos aprovechamos del adaptador <code>std::reverse_iterator</code> que implementa un iterador reverso para <b>cualquier</b> iterador bidireccional que respete el estándar C++. Su interfaz y complejidades pueden consultarse en la documentación de la biblioteca estándar</p>
<dl class="section see"><dt>See also</dt><dd><a href="http://en.cppreference.com/w/cpp/iterator/reverse_iterator">Documentación de <code>std::reverse_iterator</code></a> </dd></dl>

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a64da1d965b13eb28cdb3837bc17a18cf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a64da1d965b13eb28cdb3837bc17a18cf">&#9670;&nbsp;</a></span>map() <span class="overload">[1/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key, class Meaning, class Compare = std::less&lt;Key&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classaed2_1_1map.html">aed2::map</a>&lt; Key, Meaning, Compare &gt;::<a class="el" href="classaed2_1_1map.html">map</a> </td>
          <td>(</td>
          <td class="paramtype">Compare&#160;</td>
          <td class="paramname"><em>c</em> = <code>Compare()</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Crea un diccionario vacio. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">c</td><td>comparador (functor de orden) a utilizar </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">res</td><td>diccionario recién construido</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd>{true} </dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd>{res $$ vacio()}</dd></dl>
<p>{(1)}</p>
<dl class="section attention"><dt>Attention</dt><dd>El parámetro formal  del TAD diccionario se establece en esta función.  = {c}.operator() ambos hijos de header apuntan a null, y padre de header apunta a null </dd></dl>

</div>
</div>
<a id="a7a77950a3d8e637bfa7cf5dcd904f257"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7a77950a3d8e637bfa7cf5dcd904f257">&#9670;&nbsp;</a></span>map() <span class="overload">[2/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key, class Meaning, class Compare = std::less&lt;Key&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classaed2_1_1map.html">aed2::map</a>&lt; Key, Meaning, Compare &gt;::<a class="el" href="classaed2_1_1map.html">map</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classaed2_1_1map.html">map</a>&lt; Key, Meaning, Compare &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructor por copia. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>diccionario a copiar </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">res</td><td>diccionario recien construido</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd>{true} </dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd>{res  other}</dd></dl>
<p>{(({other}))}</p>
<dl class="section attention"><dt>Attention</dt><dd>El parámetro formal  del TAD diccionario se establece en esta función.  es igual al operator() del comparador de {other} <a class="el" href="classaed2_1_1map.html#a58a95705d54b3dda7f775ce5a22225cb" title="Devuelve un iterador al primer valor del diccionario. ">begin()</a> iterador en other. mientras haya Siguiente en el iterador de other, insertar siguiente, y avanzar. </dd></dl>

</div>
</div>
<a id="a5d336f3248572beb56be383dcc95cfeb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5d336f3248572beb56be383dcc95cfeb">&#9670;&nbsp;</a></span>map() <span class="overload">[3/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key, class Meaning, class Compare = std::less&lt;Key&gt;&gt; </div>
<div class="memtemplate">
template&lt;class iterator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classaed2_1_1map.html">aed2::map</a>&lt; Key, Meaning, Compare &gt;::<a class="el" href="classaed2_1_1map.html">map</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classaed2_1_1map_1_1iterator.html">iterator</a>&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classaed2_1_1map_1_1iterator.html">iterator</a>&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Compare&#160;</td>
          <td class="paramname"><em>c</em> = <code>Compare()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Crea un diccionario con los elementos del rango [{first}, {last}) </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">iterator</td><td>clase del iterador a recorrer</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Requerimientos sobre el tipo {iterator}</dt><dd>El tipo {iterator} debe tener todas las funcionalidades de un <em>InputIterator</em> de C++. En términos de la materia, vamos a suponer que {iterator} se explica con el TAD Iterador Unidireccional(puntero(C), {value_type}) para alguna colección de tipo C.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">first</td><td>iterador al primer elemento del rango </td></tr>
    <tr><td class="paramname">last</td><td>iterador pasando el ultimo elemento del rango </td></tr>
    <tr><td class="paramname">c</td><td>comparador a utilizar </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">res</td><td>diccionario recien construido</td></tr>
  </table>
  </dd>
</dl>
<p>{{first} y {last} son iteradores que recorren la misma secuencia definida por una colección.}</p>
<dl class="section pre"><dt>Precondition</dt><dd><p class="startdd">{last} debe ser alcanzable desde {first} y en el rango [{first}, {last}) no pueden haber valores repetidos.</p>
<p class="enddd">{coleccion({first})  coleccion({last})  esSufijo(Siguientes({last}), Siguientes({first}))  (Siguientes({first})  Siguientes({last}))} </p>
</dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd><p class="startdd">Los valores definidos en {res} son aquellos que aparecen en [{first}, {last})</p>
<p class="enddd">{( k: {Key})( s: {Meaning}) (def?({res}, k)  significado({res}, k)  s  esta((k,s), Siguientes({first})  Siguientes({last}))) } </p>
</dd></dl>
<p>{</p><ul>
<li>En el peor caso: (({res})  ((({res}))  ({res}) + ({res})))</li>
<li>Si el rango [{first}, {last}) está ordenado: (({res})  (({res})+ ({res}))) }</li>
</ul>
<dl class="section attention"><dt>Attention</dt><dd>El parámetro formal  del TAD diccionario se establece en esta función.  = {c}.operator()</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a href="http://en.cppreference.com/w/cpp/concept/InputIterator">Documentación de InputIterator</a> </dd></dl>

</div>
</div>
<a id="ab22c9a85c2dadbc286cd30e97069a8e6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab22c9a85c2dadbc286cd30e97069a8e6">&#9670;&nbsp;</a></span>~map() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key, class Meaning, class Compare = std::less&lt;Key&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classaed2_1_1map.html">aed2::map</a>&lt; Key, Meaning, Compare &gt;::~<a class="el" href="classaed2_1_1map.html">map</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Destructor. </p>
<p>{completar}</p>
<dl class="section pre"><dt>Precondition</dt><dd>{true} </dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd>{true}</dd></dl>
<p>{(({*this}))}</p>
<dl class="section attention"><dt>Attention</dt><dd>Como se explicita, esta función no hace nada, porque no tiene un objetivo funcional. De hecho, su implementación es innecesaria bajo la hipótesis de infinitud de memoria (que muchos sistemas de especificación, e.g. nuestros TADs, asumen por simplicidad). Sin embargo, esta función tiene un comportamiento real y es liberar la memoria usada. Claramente, esta funcionalidad depende del sistema en que estemos trabajando. Suponiendo que tuvieramos acceso a la implementación de las tablas de memoria del sistema operativo (o al mapa de memoria de la computadora), podríamos expresar la funcionalidad estableciendo la liberación de la memoria inicializa iterador con <a class="el" href="classaed2_1_1map.html#a58a95705d54b3dda7f775ce5a22225cb" title="Devuelve un iterador al primer valor del diccionario. ">begin()</a> mientras hay Siguiente, borra (siguiente) </dd></dl>

</div>
</div>
<a id="a64da1d965b13eb28cdb3837bc17a18cf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a64da1d965b13eb28cdb3837bc17a18cf">&#9670;&nbsp;</a></span>map() <span class="overload">[4/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key, class Meaning, class Compare = std::less&lt;Key&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classaed2_1_1map.html">aed2::map</a>&lt; Key, Meaning, Compare &gt;::<a class="el" href="classaed2_1_1map.html">map</a> </td>
          <td>(</td>
          <td class="paramtype">Compare&#160;</td>
          <td class="paramname"><em>c</em> = <code>Compare()</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Crea un diccionario vacio. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">c</td><td>comparador (functor de orden) a utilizar </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">res</td><td>diccionario recién construido</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd>{true} </dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd>{res  vacio()}</dd></dl>
<p>{(1)}</p>
<dl class="section attention"><dt>Attention</dt><dd>El parámetro formal  del TAD diccionario se establece en esta función.  = {c}.operator() ambos hijos de header apuntan a null, y padre de header apunta a null </dd></dl>

</div>
</div>
<a id="a7a77950a3d8e637bfa7cf5dcd904f257"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7a77950a3d8e637bfa7cf5dcd904f257">&#9670;&nbsp;</a></span>map() <span class="overload">[5/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key, class Meaning, class Compare = std::less&lt;Key&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classaed2_1_1map.html">aed2::map</a>&lt; Key, Meaning, Compare &gt;::<a class="el" href="classaed2_1_1map.html">map</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classaed2_1_1map.html">map</a>&lt; Key, Meaning, Compare &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructor por copia. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>diccionario a copiar </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">res</td><td>diccionario recien construido</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd>{true} </dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd>{res  other}</dd></dl>
<p>{(({other}))}</p>
<dl class="section attention"><dt>Attention</dt><dd>El parámetro formal  del TAD diccionario se establece en esta función.  es igual al operator() del comparador de {other} <a class="el" href="classaed2_1_1map.html#a58a95705d54b3dda7f775ce5a22225cb" title="Devuelve un iterador al primer valor del diccionario. ">begin()</a> iterador en other. mientras haya Siguiente en el iterador de other, insertar siguiente, y avanzar. </dd></dl>

</div>
</div>
<a id="a5d336f3248572beb56be383dcc95cfeb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5d336f3248572beb56be383dcc95cfeb">&#9670;&nbsp;</a></span>map() <span class="overload">[6/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key, class Meaning, class Compare = std::less&lt;Key&gt;&gt; </div>
<div class="memtemplate">
template&lt;class iterator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classaed2_1_1map.html">aed2::map</a>&lt; Key, Meaning, Compare &gt;::<a class="el" href="classaed2_1_1map.html">map</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classaed2_1_1map_1_1iterator.html">iterator</a>&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classaed2_1_1map_1_1iterator.html">iterator</a>&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Compare&#160;</td>
          <td class="paramname"><em>c</em> = <code>Compare()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Crea un diccionario con los elementos del rango [{first}, {last}) </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">iterator</td><td>clase del iterador a recorrer</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Requerimientos sobre el tipo {iterator}</dt><dd>El tipo {iterator} debe tener todas las funcionalidades de un <em>InputIterator</em> de C++. En términos de la materia, vamos a suponer que {iterator} se explica con el TAD Iterador Unidireccional(puntero(C), {value_type}) para alguna colección de tipo C.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">first</td><td>iterador al primer elemento del rango </td></tr>
    <tr><td class="paramname">last</td><td>iterador pasando el ultimo elemento del rango </td></tr>
    <tr><td class="paramname">c</td><td>comparador a utilizar </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">res</td><td>diccionario recien construido</td></tr>
  </table>
  </dd>
</dl>
<p>{{first} y {last} son iteradores que recorren la misma secuencia definida por una colección.}</p>
<dl class="section pre"><dt>Precondition</dt><dd><p class="startdd">{last} debe ser alcanzable desde {first} y en el rango [{first}, {last}) no pueden haber valores repetidos.</p>
<p class="enddd">{coleccion({first})  coleccion({last})  esSufijo(Siguientes({last}), Siguientes({first}))  (Siguientes({first})  Siguientes({last}))} </p>
</dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd><p class="startdd">Los valores definidos en {res} son aquellos que aparecen en [{first}, {last})</p>
<p class="enddd">{( k: {Key})( s: {Meaning}) (def?({res}, k)  significado({res}, k)  s  esta((k,s), Siguientes({first})  Siguientes({last}))) } </p>
</dd></dl>
<p>{</p><ul>
<li>En el peor caso: (({res})  ((({res}))  ({res}) + ({res})))</li>
<li>Si el rango [{first}, {last}) está ordenado: (({res})  (({res})+ ({res}))) }</li>
</ul>
<dl class="section attention"><dt>Attention</dt><dd>El parámetro formal  del TAD diccionario se establece en esta función.  = {c}.operator()</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a href="http://en.cppreference.com/w/cpp/concept/InputIterator">Documentación de InputIterator</a> </dd></dl>

</div>
</div>
<a id="ab22c9a85c2dadbc286cd30e97069a8e6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab22c9a85c2dadbc286cd30e97069a8e6">&#9670;&nbsp;</a></span>~map() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key, class Meaning, class Compare = std::less&lt;Key&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classaed2_1_1map.html">aed2::map</a>&lt; Key, Meaning, Compare &gt;::~<a class="el" href="classaed2_1_1map.html">map</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Destructor. </p>
<p>{completar}</p>
<dl class="section pre"><dt>Precondition</dt><dd>{true} </dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd>{true}</dd></dl>
<p>{(({*this}))}</p>
<dl class="section attention"><dt>Attention</dt><dd>Como se explicita, esta función no hace nada, porque no tiene un objetivo funcional. De hecho, su implementación es innecesaria bajo la hipótesis de infinitud de memoria (que muchos sistemas de especificación, e.g. nuestros TADs, asumen por simplicidad). Sin embargo, esta función tiene un comportamiento real y es liberar la memoria usada. Claramente, esta funcionalidad depende del sistema en que estemos trabajando. Suponiendo que tuvieramos acceso a la implementación de las tablas de memoria del sistema operativo (o al mapa de memoria de la computadora), podríamos expresar la funcionalidad estableciendo la liberación de la memoria inicializa iterador con <a class="el" href="classaed2_1_1map.html#a58a95705d54b3dda7f775ce5a22225cb" title="Devuelve un iterador al primer valor del diccionario. ">begin()</a> mientras hay Siguiente, borra (siguiente) </dd></dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a579c9179b42175c23a1013ac7f1b876c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a579c9179b42175c23a1013ac7f1b876c">&#9670;&nbsp;</a></span>at() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key, class Meaning, class Compare = std::less&lt;Key&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const Meaning&amp; <a class="el" href="classaed2_1_1map.html">aed2::map</a>&lt; Key, Meaning, Compare &gt;::at </td>
          <td>(</td>
          <td class="paramtype">const Key &amp;&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Devuelve el significado asociado a {key}. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>clave a buscar. </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">res</td><td>referencia al significado asociado a {key}.</td></tr>
  </table>
  </dd>
</dl>
<p>{completar}</p>
<dl class="section pre"><dt>Precondition</dt><dd>{def?(key,*this)}</dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd>{res  obtener(key,*this)}</dd></dl>
<p>{((({*this})  ({*this}))}</p>
<dl class="section remark"><dt>Remarks</dt><dd>Esta función, que se asemeja más a la forma de programar propuesta en AED2 que al estándar C++, fue incluida en el estándar C++11. Antes era obligación recurrir a la función find. Comienza en la raiz y si el valor es menor sigue la recursión hacia la izquierda, sino a la derecha, hasta que encuentra un nodo con la clave (key) pasada por parámetro y devuelve el significado almacenado en ese nodo. </dd></dl>

</div>
</div>
<a id="a579c9179b42175c23a1013ac7f1b876c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a579c9179b42175c23a1013ac7f1b876c">&#9670;&nbsp;</a></span>at() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key, class Meaning, class Compare = std::less&lt;Key&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const Meaning&amp; <a class="el" href="classaed2_1_1map.html">aed2::map</a>&lt; Key, Meaning, Compare &gt;::at </td>
          <td>(</td>
          <td class="paramtype">const Key &amp;&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Devuelve el significado asociado a {key}. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>clave a buscar. </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">res</td><td>referencia al significado asociado a {key}.</td></tr>
  </table>
  </dd>
</dl>
<p>{completar}</p>
<dl class="section pre"><dt>Precondition</dt><dd>{def?(key,*this)}</dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd>{res  obtener(key,*this)}</dd></dl>
<p>{((({*this})  ({*this}))}</p>
<dl class="section remark"><dt>Remarks</dt><dd>Esta función, que se asemeja más a la forma de programar propuesta en AED2 que al estándar C++, fue incluida en el estándar C++11. Antes era obligación recurrir a la función find. Comienza en la raiz y si el valor es menor sigue la recursión hacia la izquierda, sino a la derecha, hasta que encuentra un nodo con la clave (key) pasada por parámetro y devuelve el significado almacenado en ese nodo. </dd></dl>

</div>
</div>
<a id="a6b21c09f59a83b6ee45432dcfa61f4a1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6b21c09f59a83b6ee45432dcfa61f4a1">&#9670;&nbsp;</a></span>at() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key, class Meaning, class Compare = std::less&lt;Key&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Meaning&amp; <a class="el" href="classaed2_1_1map.html">aed2::map</a>&lt; Key, Meaning, Compare &gt;::at </td>
          <td>(</td>
          <td class="paramtype">const Key &amp;&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>

</div>
</div>
<a id="a6b21c09f59a83b6ee45432dcfa61f4a1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6b21c09f59a83b6ee45432dcfa61f4a1">&#9670;&nbsp;</a></span>at() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key, class Meaning, class Compare = std::less&lt;Key&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Meaning&amp; <a class="el" href="classaed2_1_1map.html">aed2::map</a>&lt; Key, Meaning, Compare &gt;::at </td>
          <td>(</td>
          <td class="paramtype">const Key &amp;&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>

</div>
</div>
<a id="a58a95705d54b3dda7f775ce5a22225cb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a58a95705d54b3dda7f775ce5a22225cb">&#9670;&nbsp;</a></span>begin() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key, class Meaning, class Compare = std::less&lt;Key&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classaed2_1_1map_1_1iterator.html">iterator</a> <a class="el" href="classaed2_1_1map.html">aed2::map</a>&lt; Key, Meaning, Compare &gt;::begin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Devuelve un iterador al primer valor del diccionario. </p>
<p>{no hay}</p>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">res</td><td>iterador al primer valor</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd>{true} </dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd>{res  CrearItMod(inorder(*this))}</dd></dl>
<p>{(1)} Inicia un iterador en header-&gt;izq. </p>

</div>
</div>
<a id="af3b1818c2b44e37221cc3b131768555b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af3b1818c2b44e37221cc3b131768555b">&#9670;&nbsp;</a></span>begin() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key, class Meaning, class Compare = std::less&lt;Key&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classaed2_1_1map_1_1const__iterator.html">const_iterator</a> <a class="el" href="classaed2_1_1map.html">aed2::map</a>&lt; Key, Meaning, Compare &gt;::begin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>

</div>
</div>
<a id="ab96ad892caa28f193481a578f4956a2a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab96ad892caa28f193481a578f4956a2a">&#9670;&nbsp;</a></span>cbegin()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key, class Meaning, class Compare = std::less&lt;Key&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classaed2_1_1map_1_1const__iterator.html">const_iterator</a> <a class="el" href="classaed2_1_1map.html">aed2::map</a>&lt; Key, Meaning, Compare &gt;::cbegin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>

</div>
</div>
<a id="a7bb91e94cbc875f1a011b142ef877912"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7bb91e94cbc875f1a011b142ef877912">&#9670;&nbsp;</a></span>cend()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key, class Meaning, class Compare = std::less&lt;Key&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classaed2_1_1map_1_1const__iterator.html">const_iterator</a> <a class="el" href="classaed2_1_1map.html">aed2::map</a>&lt; Key, Meaning, Compare &gt;::cend </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>

</div>
</div>
<a id="a2bfa5165825979bf2431db55bc6bc9ca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2bfa5165825979bf2431db55bc6bc9ca">&#9670;&nbsp;</a></span>clear()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key, class Meaning, class Compare = std::less&lt;Key&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classaed2_1_1map.html">aed2::map</a>&lt; Key, Meaning, Compare &gt;::clear </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Vacia el diccionario. </p>
<p>{Se invalidan todos los iteradores asociados a {*this}, con excepcion de aquellos que apuntan a la posicion pasando-el-ultimo.}</p>
<dl class="section pre"><dt>Precondition</dt><dd>{true} </dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd>{{*this}  vacio}</dd></dl>
<p>{(({*this}))} Mientras count sea distinto de 0, va eliminando con la función erase todos los elementos del árbol. </p>

</div>
</div>
<a id="a6ad62765a2b2e00247b9e35a7542b448"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6ad62765a2b2e00247b9e35a7542b448">&#9670;&nbsp;</a></span>crbegin()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key, class Meaning, class Compare = std::less&lt;Key&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classaed2_1_1map.html#aed66a216549d13078a3ea6978ea0b768">const_reverse_iterator</a> <a class="el" href="classaed2_1_1map.html">aed2::map</a>&lt; Key, Meaning, Compare &gt;::crbegin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>

</div>
</div>
<a id="a40933b2efe1cb479de9195ea947244d1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a40933b2efe1cb479de9195ea947244d1">&#9670;&nbsp;</a></span>crend()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key, class Meaning, class Compare = std::less&lt;Key&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classaed2_1_1map.html#aed66a216549d13078a3ea6978ea0b768">const_reverse_iterator</a> <a class="el" href="classaed2_1_1map.html">aed2::map</a>&lt; Key, Meaning, Compare &gt;::crend </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>

</div>
</div>
<a id="a0dcb39283f4877ae59cb756ed1d0c048"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0dcb39283f4877ae59cb756ed1d0c048">&#9670;&nbsp;</a></span>empty() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key, class Meaning, class Compare = std::less&lt;Key&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classaed2_1_1map.html">aed2::map</a>&lt; Key, Meaning, Compare &gt;::empty </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Indica si el diccionario esta vacío. </p>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">res</td><td>denota true si y solo si el diccionario está vacío</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd>{true} </dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd>{res   ?(claves(*this))}</dd></dl>
<p>{(1)} Inicia en raíz, y si la misma es distinta de null devuelve false. </p>

</div>
</div>
<a id="a0dcb39283f4877ae59cb756ed1d0c048"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0dcb39283f4877ae59cb756ed1d0c048">&#9670;&nbsp;</a></span>empty() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key, class Meaning, class Compare = std::less&lt;Key&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classaed2_1_1map.html">aed2::map</a>&lt; Key, Meaning, Compare &gt;::empty </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Indica si el diccionario esta vacío. </p>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">res</td><td>denota true si y solo si el diccionario está vacío</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd>{true} </dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd>{res   ?(claves(*this))}</dd></dl>
<p>{(1)} Inicia en raíz, y si la misma es distinta de null devuelve false. </p>

</div>
</div>
<a id="a76023e6a56cb625513e1b5ea028bf983"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a76023e6a56cb625513e1b5ea028bf983">&#9670;&nbsp;</a></span>end() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key, class Meaning, class Compare = std::less&lt;Key&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classaed2_1_1map_1_1iterator.html">iterator</a> <a class="el" href="classaed2_1_1map.html">aed2::map</a>&lt; Key, Meaning, Compare &gt;::end </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Devuelve un iterador apuntando a la posición pasando-el-ultimo del diccionario. </p>
<p>{no hay}</p>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">res</td><td>iterador a la posicion pasando-al-ultimo</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd>{true} </dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd>{res  CrearItMod(inorder(*this),  )}</dd></dl>
<p>{(1)}</p>
<p>Inicia un iterador en nullptr. </p>

</div>
</div>
<a id="a91e7cad1a638c55659c169d5574cd5d7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a91e7cad1a638c55659c169d5574cd5d7">&#9670;&nbsp;</a></span>end() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key, class Meaning, class Compare = std::less&lt;Key&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classaed2_1_1map_1_1const__iterator.html">const_iterator</a> <a class="el" href="classaed2_1_1map.html">aed2::map</a>&lt; Key, Meaning, Compare &gt;::end </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>

</div>
</div>
<a id="ad8e796bf9c9c558e5ce6b61e116253fe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad8e796bf9c9c558e5ce6b61e116253fe">&#9670;&nbsp;</a></span>erase() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key, class Meaning, class Compare = std::less&lt;Key&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classaed2_1_1map_1_1iterator.html">iterator</a> <a class="el" href="classaed2_1_1map.html">aed2::map</a>&lt; Key, Meaning, Compare &gt;::erase </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classaed2_1_1map_1_1const__iterator.html">const_iterator</a>&#160;</td>
          <td class="paramname"><em>pos</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Elimina el valor apuntado por {pos}. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pos</td><td>iterador apuntando al valor a eliminar. </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">res</td><td>iterador apuntando al primer valor con clave mayor a {pos} (o {this}-&gt;<a class="el" href="classaed2_1_1map.html#a76023e6a56cb625513e1b5ea028bf983" title="Devuelve un iterador apuntando a la posición pasando-el-ultimo del diccionario. ">end()</a>, si dicho valor no existe).</td></tr>
  </table>
  </dd>
</dl>
<p>{complertar}.</p>
<dl class="section pre"><dt>Precondition</dt><dd>{HayMas?(pos)} </dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd>{Eliminar(pos)}</dd></dl>
<p>{</p><ul>
<li>Peor caso: (({*pos}) + (({*this})))</li>
<li>Peor caso amortizado: (({*pos})) } </li>
</ul>

</div>
</div>
<a id="ad8e796bf9c9c558e5ce6b61e116253fe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad8e796bf9c9c558e5ce6b61e116253fe">&#9670;&nbsp;</a></span>erase() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key, class Meaning, class Compare = std::less&lt;Key&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classaed2_1_1map_1_1iterator.html">iterator</a> <a class="el" href="classaed2_1_1map.html">aed2::map</a>&lt; Key, Meaning, Compare &gt;::erase </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classaed2_1_1map_1_1const__iterator.html">const_iterator</a>&#160;</td>
          <td class="paramname"><em>pos</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Elimina el valor apuntado por {pos}. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pos</td><td>iterador apuntando al valor a eliminar. </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">res</td><td>iterador apuntando al primer valor con clave mayor a {pos} (o {this}-&gt;<a class="el" href="classaed2_1_1map.html#a76023e6a56cb625513e1b5ea028bf983" title="Devuelve un iterador apuntando a la posición pasando-el-ultimo del diccionario. ">end()</a>, si dicho valor no existe).</td></tr>
  </table>
  </dd>
</dl>
<p>{complertar}.</p>
<dl class="section pre"><dt>Precondition</dt><dd>{HayMas?(pos)} </dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd>{Eliminar(pos)}</dd></dl>
<p>{</p><ul>
<li>Peor caso: (({*pos}) + (({*this})))</li>
<li>Peor caso amortizado: (({*pos})) } </li>
</ul>

</div>
</div>
<a id="afd0fc1a8234888e61e0e615de7e245b8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afd0fc1a8234888e61e0e615de7e245b8">&#9670;&nbsp;</a></span>find() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key, class Meaning, class Compare = std::less&lt;Key&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classaed2_1_1map_1_1iterator.html">iterator</a> <a class="el" href="classaed2_1_1map.html">aed2::map</a>&lt; Key, Meaning, Compare &gt;::find </td>
          <td>(</td>
          <td class="paramtype">const Key &amp;&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Devuelve un iterador a la posicion del valor con clave {key}. </p>
<p>Retorna un iterador apuntando a la posicion del valor con clave {key}. Si dicho valor no existe, porque la clave no fue definida, entonces el iterador retornado apunta a la posición <em>pasando-el-ultimo</em>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>clave a buscar </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">res</td><td>iterador apuntando al valor con clave {key} (o a {this}-&gt;<a class="el" href="classaed2_1_1map.html#a76023e6a56cb625513e1b5ea028bf983" title="Devuelve un iterador apuntando a la posición pasando-el-ultimo del diccionario. ">end()</a> si dicho elemento no existe)</td></tr>
  </table>
  </dd>
</dl>
<p>{Hay aliasing entre el actual(iterador) y obtener(key, *this)}</p>
<dl class="section pre"><dt>Precondition</dt><dd>{true} </dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd>{def?(key, *this)  res  crearitAux(key,inorder(*this))}</dd></dl>
<p>{((({*this}))  ({*this}))}</p>
<dl class="section attention"><dt>Attention</dt><dd>Si el objetivo es insertar un valor con clave {key} de acuerdo a alguna condición, entonces conviene usar <a class="el" href="classaed2_1_1map.html#a62075a47afdf89267c5462f88164af3d" title="Devuelve un iterador al primer valor con clave mayor o igual a {key}. ">aed2::map::lower_bound</a> para la búsqueda, dado que el resultado puede ser usado como hint, mejorando la complejidad de la inserción.<ul>
<li>Inicia el iterador en el hijo izquierdo de header.</li>
<li>Avanzo hasta que la clave sea key o, en caso de que no esté definida, hasta la posición pasando-el-último.</li>
<li>Devuelve el Iterador en esa posición. </li>
</ul>
</dd></dl>

</div>
</div>
<a id="afd0fc1a8234888e61e0e615de7e245b8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afd0fc1a8234888e61e0e615de7e245b8">&#9670;&nbsp;</a></span>find() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key, class Meaning, class Compare = std::less&lt;Key&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classaed2_1_1map_1_1iterator.html">iterator</a> <a class="el" href="classaed2_1_1map.html">aed2::map</a>&lt; Key, Meaning, Compare &gt;::find </td>
          <td>(</td>
          <td class="paramtype">const Key &amp;&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Devuelve un iterador a la posicion del valor con clave {key}. </p>
<p>Retorna un iterador apuntando a la posicion del valor con clave {key}. Si dicho valor no existe, porque la clave no fue definida, entonces el iterador retornado apunta a la posición <em>pasando-el-ultimo</em>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>clave a buscar </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">res</td><td>iterador apuntando al valor con clave {key} (o a {this}-&gt;<a class="el" href="classaed2_1_1map.html#a76023e6a56cb625513e1b5ea028bf983" title="Devuelve un iterador apuntando a la posición pasando-el-ultimo del diccionario. ">end()</a> si dicho elemento no existe)</td></tr>
  </table>
  </dd>
</dl>
<p>{Hay aliasing entre el actual(iterador) y obtener(key, *this)}</p>
<dl class="section pre"><dt>Precondition</dt><dd>{true} </dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd>{def?(key, *this)  res  crearitAux(key,inorder(*this))}</dd></dl>
<p>{((({*this}))  ({*this}))}</p>
<dl class="section attention"><dt>Attention</dt><dd>Si el objetivo es insertar un valor con clave {key} de acuerdo a alguna condición, entonces conviene usar <a class="el" href="classaed2_1_1map.html#a62075a47afdf89267c5462f88164af3d" title="Devuelve un iterador al primer valor con clave mayor o igual a {key}. ">aed2::map::lower_bound</a> para la búsqueda, dado que el resultado puede ser usado como hint, mejorando la complejidad de la inserción.<ul>
<li>Inicia el iterador en el hijo izquierdo de header.</li>
<li>Avanzo hasta que la clave sea key o, en caso de que no esté definida, hasta la posición pasando-el-último.</li>
<li>Devuelve el Iterador en esa posición. </li>
</ul>
</dd></dl>

</div>
</div>
<a id="adbf6f4ce01a16ca506e3c75fc2843882"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adbf6f4ce01a16ca506e3c75fc2843882">&#9670;&nbsp;</a></span>find() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key, class Meaning, class Compare = std::less&lt;Key&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classaed2_1_1map_1_1const__iterator.html">const_iterator</a> <a class="el" href="classaed2_1_1map.html">aed2::map</a>&lt; Key, Meaning, Compare &gt;::find </td>
          <td>(</td>
          <td class="paramtype">const Key &amp;&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>

</div>
</div>
<a id="adbf6f4ce01a16ca506e3c75fc2843882"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adbf6f4ce01a16ca506e3c75fc2843882">&#9670;&nbsp;</a></span>find() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key, class Meaning, class Compare = std::less&lt;Key&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classaed2_1_1map_1_1const__iterator.html">const_iterator</a> <a class="el" href="classaed2_1_1map.html">aed2::map</a>&lt; Key, Meaning, Compare &gt;::find </td>
          <td>(</td>
          <td class="paramtype">const Key &amp;&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>

</div>
</div>
<a id="a6941cde9a79c27f054b5c97a587a1854"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6941cde9a79c27f054b5c97a587a1854">&#9670;&nbsp;</a></span>insert() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key, class Meaning, class Compare = std::less&lt;Key&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classaed2_1_1map_1_1iterator.html">iterator</a> <a class="el" href="classaed2_1_1map.html">aed2::map</a>&lt; Key, Meaning, Compare &gt;::insert </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classaed2_1_1map_1_1const__iterator.html">const_iterator</a>&#160;</td>
          <td class="paramname"><em>hint</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classaed2_1_1map.html#a719db98e0ff9a837610f76be33264680">value_type</a> &amp;&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Inserta {value} en el diccionario. </p>
<p>Inserta un <b>nuevo</b> valor en el diccionario. Si {*this} ya tiene un valor con clave {value}.first, entonces la función no tiene efectos. El iterador de retorno apunta al elemento recien insertado (o aquel que previno la insercion).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>valor a insertar </td></tr>
    <tr><td class="paramname">hint</td><td>iterador apuntando al diccionario. Se espera que apunte al minimo valor mayor o igual a {value}.first (i.e., a lower_bound({value}.first)). Igualmente, la función es robusta y funciona correctamente aunque esto no ocurra. </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">res</td><td>iterador apuntando al elemento insertado o que previno la inserción</td></tr>
  </table>
  </dd>
</dl>
<p>{hay aliasing???}</p>
<dl class="section pre"><dt>Precondition</dt><dd>{true} </dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd>{def?(value.first, *this)  crearitAux(*this.first, inorder(*this) )   def?(value.first, *this)  res  agregar(crearIt(inorder(*this)), value)}</dd></dl>
<p>{</p><ul>
<li>Peor caso: ((({*this}))  ({*this})  ({value}))</li>
<li>Si {hint} apunta al primer valor con clave al menos {value}.first (o {this}-&gt;<a class="el" href="classaed2_1_1map.html#a76023e6a56cb625513e1b5ea028bf983" title="Devuelve un iterador apuntando a la posición pasando-el-ultimo del diccionario. ">end()</a> en caso de no existir): (({*this})  ({value})) amortizado. }</li>
</ul>
<dl class="section attention"><dt>Attention</dt><dd>Para garantizar que el nuevo elemento se inserte sí o sí, usar <a class="el" href="classaed2_1_1map.html#a2ef6723c183916276b0afc4a4c721475">aed2::map::insert_or_assign</a>. </dd></dl>

</div>
</div>
<a id="a6941cde9a79c27f054b5c97a587a1854"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6941cde9a79c27f054b5c97a587a1854">&#9670;&nbsp;</a></span>insert() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key, class Meaning, class Compare = std::less&lt;Key&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classaed2_1_1map_1_1iterator.html">iterator</a> <a class="el" href="classaed2_1_1map.html">aed2::map</a>&lt; Key, Meaning, Compare &gt;::insert </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classaed2_1_1map_1_1const__iterator.html">const_iterator</a>&#160;</td>
          <td class="paramname"><em>hint</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classaed2_1_1map.html#a719db98e0ff9a837610f76be33264680">value_type</a> &amp;&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Inserta {value} en el diccionario. </p>
<p>Inserta un <b>nuevo</b> valor en el diccionario. Si {*this} ya tiene un valor con clave {value}.first, entonces la función no tiene efectos. El iterador de retorno apunta al elemento recien insertado (o aquel que previno la insercion).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>valor a insertar </td></tr>
    <tr><td class="paramname">hint</td><td>iterador apuntando al diccionario. Se espera que apunte al minimo valor mayor o igual a {value}.first (i.e., a lower_bound({value}.first)). Igualmente, la función es robusta y funciona correctamente aunque esto no ocurra. </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">res</td><td>iterador apuntando al elemento insertado o que previno la inserción</td></tr>
  </table>
  </dd>
</dl>
<p>{hay aliasing???}</p>
<dl class="section pre"><dt>Precondition</dt><dd>{true} </dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd>{def?(value.first, *this)  crearitAux(*this.first, inorder(*this) )   def?(value.first, *this)  res  agregar(crearIt(inorder(*this)), value)}</dd></dl>
<p>{</p><ul>
<li>Peor caso: ((({*this}))  ({*this})  ({value}))</li>
<li>Si {hint} apunta al primer valor con clave al menos {value}.first (o {this}-&gt;<a class="el" href="classaed2_1_1map.html#a76023e6a56cb625513e1b5ea028bf983" title="Devuelve un iterador apuntando a la posición pasando-el-ultimo del diccionario. ">end()</a> en caso de no existir): (({*this})  ({value})) amortizado. }</li>
</ul>
<dl class="section attention"><dt>Attention</dt><dd>Para garantizar que el nuevo elemento se inserte sí o sí, usar <a class="el" href="classaed2_1_1map.html#a2ef6723c183916276b0afc4a4c721475">aed2::map::insert_or_assign</a>. </dd></dl>

</div>
</div>
<a id="a60aacba06b1579630b3c8e996cf248c8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a60aacba06b1579630b3c8e996cf248c8">&#9670;&nbsp;</a></span>insert() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key, class Meaning, class Compare = std::less&lt;Key&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classaed2_1_1map_1_1iterator.html">iterator</a> <a class="el" href="classaed2_1_1map.html">aed2::map</a>&lt; Key, Meaning, Compare &gt;::insert </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classaed2_1_1map.html#a719db98e0ff9a837610f76be33264680">value_type</a> &amp;&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>

</div>
</div>
<a id="a60aacba06b1579630b3c8e996cf248c8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a60aacba06b1579630b3c8e996cf248c8">&#9670;&nbsp;</a></span>insert() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key, class Meaning, class Compare = std::less&lt;Key&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classaed2_1_1map_1_1iterator.html">iterator</a> <a class="el" href="classaed2_1_1map.html">aed2::map</a>&lt; Key, Meaning, Compare &gt;::insert </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classaed2_1_1map.html#a719db98e0ff9a837610f76be33264680">value_type</a> &amp;&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>

</div>
</div>
<a id="a2ef6723c183916276b0afc4a4c721475"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2ef6723c183916276b0afc4a4c721475">&#9670;&nbsp;</a></span>insert_or_assign() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key, class Meaning, class Compare = std::less&lt;Key&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classaed2_1_1map_1_1iterator.html">iterator</a> <a class="el" href="classaed2_1_1map.html">aed2::map</a>&lt; Key, Meaning, Compare &gt;::insert_or_assign </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classaed2_1_1map_1_1const__iterator.html">const_iterator</a>&#160;</td>
          <td class="paramname"><em>hint</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classaed2_1_1map.html#a719db98e0ff9a837610f76be33264680">value_type</a> &amp;&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>{</p><ul>
<li>Peor caso: ((({*this}))  ({*this})  ({value}))</li>
<li>Si {hint} apunta al primer valor con clave al menos {value}.first (o {this}-&gt;<a class="el" href="classaed2_1_1map.html#a76023e6a56cb625513e1b5ea028bf983" title="Devuelve un iterador apuntando a la posición pasando-el-ultimo del diccionario. ">end()</a> en caso de no existir): (({*this})  ({value})) amortizado. }</li>
</ul>
<dl class="section attention"><dt>Attention</dt><dd>Para prevenir que el nuevo valor redefina uno ya existente, usar <a class="el" href="classaed2_1_1map.html#a6941cde9a79c27f054b5c97a587a1854" title="Inserta {value} en el diccionario. ">aed2::map::insert</a>. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>Esta función es similar al operator[], pero tiene dos ventajas y una desventaja. Las ventajas es que 1. se puede indicar un {hint} para la búsqueda y 2. no es necesario que {Meaning} tenga constructor sin parámetros. La desventaja es que la notación no es tan bonita. </dd></dl>

</div>
</div>
<a id="a2ef6723c183916276b0afc4a4c721475"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2ef6723c183916276b0afc4a4c721475">&#9670;&nbsp;</a></span>insert_or_assign() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key, class Meaning, class Compare = std::less&lt;Key&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classaed2_1_1map_1_1iterator.html">iterator</a> <a class="el" href="classaed2_1_1map.html">aed2::map</a>&lt; Key, Meaning, Compare &gt;::insert_or_assign </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classaed2_1_1map_1_1const__iterator.html">const_iterator</a>&#160;</td>
          <td class="paramname"><em>hint</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classaed2_1_1map.html#a719db98e0ff9a837610f76be33264680">value_type</a> &amp;&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>{</p><ul>
<li>Peor caso: ((({*this}))  ({*this})  ({value}))</li>
<li>Si {hint} apunta al primer valor con clave al menos {value}.first (o {this}-&gt;<a class="el" href="classaed2_1_1map.html#a76023e6a56cb625513e1b5ea028bf983" title="Devuelve un iterador apuntando a la posición pasando-el-ultimo del diccionario. ">end()</a> en caso de no existir): (({*this})  ({value})) amortizado. }</li>
</ul>
<dl class="section attention"><dt>Attention</dt><dd>Para prevenir que el nuevo valor redefina uno ya existente, usar <a class="el" href="classaed2_1_1map.html#a6941cde9a79c27f054b5c97a587a1854" title="Inserta {value} en el diccionario. ">aed2::map::insert</a>. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>Esta función es similar al operator[], pero tiene dos ventajas y una desventaja. Las ventajas es que 1. se puede indicar un {hint} para la búsqueda y 2. no es necesario que {Meaning} tenga constructor sin parámetros. La desventaja es que la notación no es tan bonita. </dd></dl>

</div>
</div>
<a id="a9128a806713bcc999ebd8a97ab77e765"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9128a806713bcc999ebd8a97ab77e765">&#9670;&nbsp;</a></span>insert_or_assign() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key, class Meaning, class Compare = std::less&lt;Key&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classaed2_1_1map_1_1iterator.html">iterator</a> <a class="el" href="classaed2_1_1map.html">aed2::map</a>&lt; Key, Meaning, Compare &gt;::insert_or_assign </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classaed2_1_1map.html#a719db98e0ff9a837610f76be33264680">value_type</a> &amp;&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>

</div>
</div>
<a id="a9128a806713bcc999ebd8a97ab77e765"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9128a806713bcc999ebd8a97ab77e765">&#9670;&nbsp;</a></span>insert_or_assign() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key, class Meaning, class Compare = std::less&lt;Key&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classaed2_1_1map_1_1iterator.html">iterator</a> <a class="el" href="classaed2_1_1map.html">aed2::map</a>&lt; Key, Meaning, Compare &gt;::insert_or_assign </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classaed2_1_1map.html#a719db98e0ff9a837610f76be33264680">value_type</a> &amp;&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>

</div>
</div>
<a id="a62075a47afdf89267c5462f88164af3d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a62075a47afdf89267c5462f88164af3d">&#9670;&nbsp;</a></span>lower_bound() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key, class Meaning, class Compare = std::less&lt;Key&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classaed2_1_1map_1_1const__iterator.html">const_iterator</a> <a class="el" href="classaed2_1_1map.html">aed2::map</a>&lt; Key, Meaning, Compare &gt;::lower_bound </td>
          <td>(</td>
          <td class="paramtype">const Key &amp;&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Devuelve un iterador al primer valor con clave mayor o igual a {key}. </p>
<p>Retorna un iterador apuntando a la primer posición cuyo valor tenga clave al menos {key}. Si dicho valor no existe, porque {key} es mayor a todas las claves de {*this}, entonces el iterador retornado apunta a la posición <em>pasando-el-último</em>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>clave a buscar </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">res</td><td>iterador apuntando al valor con clave al menos {key} (o a {this}-&gt;<a class="el" href="classaed2_1_1map.html#a76023e6a56cb625513e1b5ea028bf983" title="Devuelve un iterador apuntando a la posición pasando-el-ultimo del diccionario. ">end()</a> si dicho elemento no existe)</td></tr>
  </table>
  </dd>
</dl>
<p>{hay aliasing entre res y el sucesor inmediato de key}</p>
<dl class="section pre"><dt>Precondition</dt><dd>{true} </dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd>{res  crearitAux2(key,inorder(*this))(busca en la secu inorder a key y devuelve el siguiente o null si es mayor a todas las claves)}</dd></dl>
<p>{((({*this}))  ({*this}))}</p><ul>
<li>Inicia el iterador en el hijo izquierdo de header.</li>
<li>Avanzo hasta que la clave sea mayor o igual a key o, en caso de que no exista ninguna, hasta la posición pasando-el-último.</li>
<li>Devuelve el Iterador en esa posición. </li>
</ul>

</div>
</div>
<a id="a62075a47afdf89267c5462f88164af3d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a62075a47afdf89267c5462f88164af3d">&#9670;&nbsp;</a></span>lower_bound() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key, class Meaning, class Compare = std::less&lt;Key&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classaed2_1_1map_1_1const__iterator.html">const_iterator</a> <a class="el" href="classaed2_1_1map.html">aed2::map</a>&lt; Key, Meaning, Compare &gt;::lower_bound </td>
          <td>(</td>
          <td class="paramtype">const Key &amp;&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Devuelve un iterador al primer valor con clave mayor o igual a {key}. </p>
<p>Retorna un iterador apuntando a la primer posición cuyo valor tenga clave al menos {key}. Si dicho valor no existe, porque {key} es mayor a todas las claves de {*this}, entonces el iterador retornado apunta a la posición <em>pasando-el-último</em>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>clave a buscar </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">res</td><td>iterador apuntando al valor con clave al menos {key} (o a {this}-&gt;<a class="el" href="classaed2_1_1map.html#a76023e6a56cb625513e1b5ea028bf983" title="Devuelve un iterador apuntando a la posición pasando-el-ultimo del diccionario. ">end()</a> si dicho elemento no existe)</td></tr>
  </table>
  </dd>
</dl>
<p>{hay aliasing entre res y el sucesor inmediato de key}</p>
<dl class="section pre"><dt>Precondition</dt><dd>{true} </dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd>{res  crearitAux2(key,inorder(*this))(busca en la secu inorder a key y devuelve el siguiente o null si es mayor a todas las claves)}</dd></dl>
<p>{((({*this}))  ({*this}))}</p><ul>
<li>Inicia el iterador en el hijo izquierdo de header.</li>
<li>Avanzo hasta que la clave sea mayor o igual a key o, en caso de que no exista ninguna, hasta la posición pasando-el-último.</li>
<li>Devuelve el Iterador en esa posición. </li>
</ul>

</div>
</div>
<a id="a07b3dd65557c59ee085e5f211269c6b3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a07b3dd65557c59ee085e5f211269c6b3">&#9670;&nbsp;</a></span>lower_bound() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key, class Meaning, class Compare = std::less&lt;Key&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classaed2_1_1map_1_1iterator.html">iterator</a> <a class="el" href="classaed2_1_1map.html">aed2::map</a>&lt; Key, Meaning, Compare &gt;::lower_bound </td>
          <td>(</td>
          <td class="paramtype">const Key &amp;&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>

</div>
</div>
<a id="a07b3dd65557c59ee085e5f211269c6b3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a07b3dd65557c59ee085e5f211269c6b3">&#9670;&nbsp;</a></span>lower_bound() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key, class Meaning, class Compare = std::less&lt;Key&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classaed2_1_1map_1_1iterator.html">iterator</a> <a class="el" href="classaed2_1_1map.html">aed2::map</a>&lt; Key, Meaning, Compare &gt;::lower_bound </td>
          <td>(</td>
          <td class="paramtype">const Key &amp;&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>

</div>
</div>
<a id="ac606d334809066929522964d45e76317"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac606d334809066929522964d45e76317">&#9670;&nbsp;</a></span>operator=() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key, class Meaning, class Compare = std::less&lt;Key&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classaed2_1_1map.html">map</a>&amp; <a class="el" href="classaed2_1_1map.html">aed2::map</a>&lt; Key, Meaning, Compare &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classaed2_1_1map.html">map</a>&lt; Key, Meaning, Compare &gt;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Operador de asignación. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>diccionario a copiar </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">res</td><td>referencia a *this</td></tr>
  </table>
  </dd>
</dl>
<p>{no hay}</p>
<dl class="section pre"><dt>Precondition</dt><dd>{true} </dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd>{res  other}</dd></dl>
<p>{(({*this})  ({other}))}</p>
<dl class="section note"><dt>Note</dt><dd>Es importante remarcar que no se realiza ninguna comparación entre los elementos. -destruir this<ul>
<li>this-&gt;map(other) </li>
</ul>
</dd></dl>

</div>
</div>
<a id="ac606d334809066929522964d45e76317"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac606d334809066929522964d45e76317">&#9670;&nbsp;</a></span>operator=() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key, class Meaning, class Compare = std::less&lt;Key&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classaed2_1_1map.html">map</a>&amp; <a class="el" href="classaed2_1_1map.html">aed2::map</a>&lt; Key, Meaning, Compare &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classaed2_1_1map.html">map</a>&lt; Key, Meaning, Compare &gt;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Operador de asignación. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>diccionario a copiar </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">res</td><td>referencia a *this</td></tr>
  </table>
  </dd>
</dl>
<p>{no hay}</p>
<dl class="section pre"><dt>Precondition</dt><dd>{true} </dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd>{res  other}</dd></dl>
<p>{(({*this})  ({other}))}</p>
<dl class="section note"><dt>Note</dt><dd>Es importante remarcar que no se realiza ninguna comparación entre los elementos. -destruir this<ul>
<li>this-&gt;map(other) </li>
</ul>
</dd></dl>

</div>
</div>
<a id="a96f23896164ab47bee48c26b803f9801"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a96f23896164ab47bee48c26b803f9801">&#9670;&nbsp;</a></span>operator[]() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key, class Meaning, class Compare = std::less&lt;Key&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Meaning&amp; <a class="el" href="classaed2_1_1map.html">aed2::map</a>&lt; Key, Meaning, Compare &gt;::operator[] </td>
          <td>(</td>
          <td class="paramtype">const Key &amp;&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Devuelve el significado asociado a {key}, asegurando su existencia. </p>
<p>Devuelve el significado asociado a {key}. Si {key} no está definido en {*this}, entonces se inserta un nuevo valor con clave {key} y significado {Meaning}(). De esta forma, podemos usar <code>operator[]</code> para definir nuevos valores o modificar los existentes.</p>
<p>Ejemplo: </p><div class="fragment"><div class="line"><a class="code" href="classaed2_1_1map.html">aed2::map&lt;int, int&gt;</a> d;</div><div class="line">d[1] = 2;      <span class="comment">//define 1 -&gt; 2</span></div><div class="line">d[1] = 3;      <span class="comment">//redefine 1 -&gt; 3</span></div><div class="line"></div><div class="line"><a class="code" href="classaed2_1_1map.html">aed2::map&lt;int, int&gt;</a> m;</div><div class="line"><span class="keywordflow">if</span>(m[1] == 3) {...} <span class="comment">//posible bug: define 1 -&gt; basura (que puede o no ser 3).</span></div></div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>clave a buscar. </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">res</td><td>referencia al significado asociado a {key}.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Requerimientos sobre el tipo {Meaning}</dt><dd>Requiere que {Meaning} tenga un constructor sin parámetros con complejidad (<em>c</em>)</dd></dl>
<p>{hay aliasing entre res y obtener(key, *this)}</p>
<dl class="section pre"><dt>Precondition</dt><dd>{true} </dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd>{def?(key, *this)  res  obtener(key, *this)}</dd></dl>
<p>{((({*this}))  ({*this}) + <em>x</em>) donde</p><ul>
<li><em>x</em> = 1 si def?(<em>self</em>, {key}), y</li>
<li><em>x</em> = <em>c</em> en caso contrario.} Comienza en la raiz y si el valor es menor sigue la recursión hacia la izquierda, sino a la derecha, hasta que encuentra un nodo con la clave (key) pasada por parámetro y devuelve el significado almacenado en ese nodo, o en el caso que la clave no esté definida, la define con el significado default y además incrementa en uno count. </li>
</ul>

</div>
</div>
<a id="a96f23896164ab47bee48c26b803f9801"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a96f23896164ab47bee48c26b803f9801">&#9670;&nbsp;</a></span>operator[]() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key, class Meaning, class Compare = std::less&lt;Key&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Meaning&amp; <a class="el" href="classaed2_1_1map.html">aed2::map</a>&lt; Key, Meaning, Compare &gt;::operator[] </td>
          <td>(</td>
          <td class="paramtype">const Key &amp;&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Devuelve el significado asociado a {key}, asegurando su existencia. </p>
<p>Devuelve el significado asociado a {key}. Si {key} no está definido en {*this}, entonces se inserta un nuevo valor con clave {key} y significado {Meaning}(). De esta forma, podemos usar <code>operator[]</code> para definir nuevos valores o modificar los existentes.</p>
<p>Ejemplo: </p><div class="fragment"><div class="line"><a class="code" href="classaed2_1_1map.html">aed2::map&lt;int, int&gt;</a> d;</div><div class="line">d[1] = 2;      <span class="comment">//define 1 -&gt; 2</span></div><div class="line">d[1] = 3;      <span class="comment">//redefine 1 -&gt; 3</span></div><div class="line"></div><div class="line"><a class="code" href="classaed2_1_1map.html">aed2::map&lt;int, int&gt;</a> m;</div><div class="line"><span class="keywordflow">if</span>(m[1] == 3) {...} <span class="comment">//posible bug: define 1 -&gt; basura (que puede o no ser 3).</span></div></div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>clave a buscar. </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">res</td><td>referencia al significado asociado a {key}.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Requerimientos sobre el tipo {Meaning}</dt><dd>Requiere que {Meaning} tenga un constructor sin parámetros con complejidad (<em>c</em>)</dd></dl>
<p>{hay aliasing entre res y obtener(key, *this)}</p>
<dl class="section pre"><dt>Precondition</dt><dd>{true} </dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd>{def?(key, *this)  res  obtener(key, *this)}</dd></dl>
<p>{((({*this}))  ({*this}) + <em>x</em>) donde</p><ul>
<li><em>x</em> = 1 si def?(<em>self</em>, {key}), y</li>
<li><em>x</em> = <em>c</em> en caso contrario.} Comienza en la raiz y si el valor es menor sigue la recursión hacia la izquierda, sino a la derecha, hasta que encuentra un nodo con la clave (key) pasada por parámetro y devuelve el significado almacenado en ese nodo, o en el caso que la clave no esté definida, la define con el significado default y además incrementa en uno count. </li>
</ul>

</div>
</div>
<a id="ac412d3902112122c1bffe2d4283a4e9d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac412d3902112122c1bffe2d4283a4e9d">&#9670;&nbsp;</a></span>rbegin() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key, class Meaning, class Compare = std::less&lt;Key&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classaed2_1_1map.html#a8e6a592062260177fd73b2f9897b1dd5">reverse_iterator</a> <a class="el" href="classaed2_1_1map.html">aed2::map</a>&lt; Key, Meaning, Compare &gt;::rbegin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Devuelve un iterador al primer valor del diccionario, en un recorrido al revés. </p>
<p>{no hay}</p>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">res</td><td>iterador a la primer posicion en un recorrido al revés</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd>{true} </dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd>{res  CrearItMod(  , postorder(*this))}</dd></dl>
<p>{(1)}</p>
<p>Inicia un reverse_iterator en el hijo derecho de header. </p>

</div>
</div>
<a id="a71ab53ab04f5e35a189c6576fddeb483"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a71ab53ab04f5e35a189c6576fddeb483">&#9670;&nbsp;</a></span>rbegin() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key, class Meaning, class Compare = std::less&lt;Key&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classaed2_1_1map.html#aed66a216549d13078a3ea6978ea0b768">const_reverse_iterator</a> <a class="el" href="classaed2_1_1map.html">aed2::map</a>&lt; Key, Meaning, Compare &gt;::rbegin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>

</div>
</div>
<a id="a277f03b4f4b6b98879e4e4921081801f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a277f03b4f4b6b98879e4e4921081801f">&#9670;&nbsp;</a></span>rend() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key, class Meaning, class Compare = std::less&lt;Key&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classaed2_1_1map.html#a8e6a592062260177fd73b2f9897b1dd5">reverse_iterator</a> <a class="el" href="classaed2_1_1map.html">aed2::map</a>&lt; Key, Meaning, Compare &gt;::rend </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Devuelve un iterador apuntando a la posición pasando-el-ultimo del diccionario, en un recorrido al revés. </p>
<p>{no hay}</p>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">res</td><td>iterador a la posicion pasando-al-ultimo, en un recorrido al revés</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd>{true} </dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd>{res  CrearItMod(postorder(*this),  )}</dd></dl>
<p>{(1)}</p>
<p>Inicia un reversre_iterator en el hijo izquierdo de header. </p>

</div>
</div>
<a id="a7cf14a4b505505d0f074034b7399fb24"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7cf14a4b505505d0f074034b7399fb24">&#9670;&nbsp;</a></span>rend() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key, class Meaning, class Compare = std::less&lt;Key&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classaed2_1_1map.html#aed66a216549d13078a3ea6978ea0b768">const_reverse_iterator</a> <a class="el" href="classaed2_1_1map.html">aed2::map</a>&lt; Key, Meaning, Compare &gt;::rend </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>

</div>
</div>
<a id="aa6e806b3be6dc0da79adbfae08b571bf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa6e806b3be6dc0da79adbfae08b571bf">&#9670;&nbsp;</a></span>size() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key, class Meaning, class Compare = std::less&lt;Key&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t <a class="el" href="classaed2_1_1map.html">aed2::map</a>&lt; Key, Meaning, Compare &gt;::size </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Devuelve la cantidad de valores en el diccionario. </p>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">res</td><td>cantidad de valores</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd>{true} </dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd>{res  #claves(*this)}</dd></dl>
<p>{(1)} Devuelve count; </p>

</div>
</div>
<a id="aa6e806b3be6dc0da79adbfae08b571bf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa6e806b3be6dc0da79adbfae08b571bf">&#9670;&nbsp;</a></span>size() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key, class Meaning, class Compare = std::less&lt;Key&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t <a class="el" href="classaed2_1_1map.html">aed2::map</a>&lt; Key, Meaning, Compare &gt;::size </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Devuelve la cantidad de valores en el diccionario. </p>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">res</td><td>cantidad de valores</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd>{true} </dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd>{res  #claves(*this)}</dd></dl>
<p>{(1)} Devuelve count; </p>

</div>
</div>
<a id="a43ddb71cc91e5c6021a7a1f243d6cc4a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a43ddb71cc91e5c6021a7a1f243d6cc4a">&#9670;&nbsp;</a></span>swap()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key, class Meaning, class Compare = std::less&lt;Key&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classaed2_1_1map.html">aed2::map</a>&lt; Key, Meaning, Compare &gt;::swap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classaed2_1_1map.html">map</a>&lt; Key, Meaning, Compare &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Intercambia el contenido de {*this} y {other}. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>diccionario a intercambiar con {*this}</td></tr>
  </table>
  </dd>
</dl>
<p>{Todos los iteradores, salvo aquellos que apuntan a las posiciones pasando-el-ultimo, se mantienen válidos. Aquellos iteradores que apuntan a la posición pasando-el-ultimo de {*this} pasan a apuntar a la posición pasando-el-ultimo de {other}, y viceversa.}</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>mapa a intercambiar con this</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd>{<em>self</em> = {*this}  <em>oth</em> = {other}} </dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd>{{*this}  <em>oth</em>  {other} = <em>self}</em> </dd></dl>
<p>{(1)}</p>
<dl class="section note"><dt>Note</dt><dd>La razón por la que se "invalidan" los iteradores pasando-el-fin tiene que ver con la forma en que se implementa el módulo (que emula la implementacion de C++). No hay ninguna razón técnica que impida mantener los iteradores pasando el fin, salvo por un pequeño ahorro de memoria y tiempo. En caso de querer usar los iteradores como punteros, se recomienda usar el iterador nulo de diccionario para representar al valor inválido, en lugar de usar los iteradores pasando-el-ultimo. </dd></dl>

</div>
</div>
<h2 class="groupheader">Friends And Related Function Documentation</h2>
<a id="abce0fa35c5b25fd67111c2e704616f09"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abce0fa35c5b25fd67111c2e704616f09">&#9670;&nbsp;</a></span>operator!=() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class K , class V , class C &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool operator!= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classaed2_1_1map.html">map</a>&lt; K, V, C &gt; &amp;&#160;</td>
          <td class="paramname"><em>m1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classaed2_1_1map.html">map</a>&lt; K, V, C &gt; &amp;&#160;</td>
          <td class="paramname"><em>m2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Renombre de not({m1} == {m2}) </p>
<dl class="section see"><dt>See also</dt><dd>aed2::operator==() </dd></dl>

</div>
</div>
<a id="a11627296a0eb71c87e69caa89fbd94eb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a11627296a0eb71c87e69caa89fbd94eb">&#9670;&nbsp;</a></span>operator!=() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class K , class V , class C &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool operator!= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classaed2_1_1map.html">map</a>&lt; K, V, C &gt; &amp;&#160;</td>
          <td class="paramname"><em>m</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Renombre de not({m1} == {m2}) </p>
<dl class="section see"><dt>See also</dt><dd>aed2::operator==() </dd></dl>

</div>
</div>
<a id="a8ff07f6a24c290ea7e8f63ec7ab24f8d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8ff07f6a24c290ea7e8f63ec7ab24f8d">&#9670;&nbsp;</a></span>operator<() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class K , class V , class C &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool operator&lt; </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classaed2_1_1map.html">map</a>&lt; K, V, C &gt; &amp;&#160;</td>
          <td class="paramname"><em>m1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classaed2_1_1map.html">map</a>&lt; K, V, C &gt; &amp;&#160;</td>
          <td class="paramname"><em>m2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Operador de orden lexicografico entre diccionarios. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">K</td><td>clave del diccionario </td></tr>
    <tr><td class="paramname">V</td><td>signficado del diccionario </td></tr>
    <tr><td class="paramname">C</td><td>tipo del comparador</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Requerimientos sobre los tipos</dt><dd>{K} y {V} tienen operator&lt;; vamos a usar  para describir los costos de comparación.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">m1</td><td>diccionario a comparar </td></tr>
    <tr><td class="paramname">m2</td><td>diccionario a comparar </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">res</td><td>true si m1 es menor a m2 en el orden lexicografico</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd>{completar} </dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd>{completar}</dd></dl>
<p>{ (((m1) + (m2))  ((m1) + (m2)))}</p>
<dl class="section attention"><dt>Attention</dt><dd>Para determinar la comparación de las claves no se utiliza el functor de comparación (que podrian ser distintos entre los diccionarios), sino si los valores son los mismos con respecto al operator&lt; de {K} y T{V}. </dd></dl>

</div>
</div>
<a id="a4d766795e9a996ed79f8c08fbd1676cd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4d766795e9a996ed79f8c08fbd1676cd">&#9670;&nbsp;</a></span>operator<() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class K , class V , class C &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool operator&lt; </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classaed2_1_1map.html">map</a>&lt; K, V, C &gt; &amp;&#160;</td>
          <td class="paramname"><em>m</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Operador de orden lexicografico entre diccionarios. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">K</td><td>clave del diccionario </td></tr>
    <tr><td class="paramname">V</td><td>signficado del diccionario </td></tr>
    <tr><td class="paramname">C</td><td>tipo del comparador</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Requerimientos sobre los tipos</dt><dd>{K} y {V} tienen operator&lt;; vamos a usar  para describir los costos de comparación.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">m1</td><td>diccionario a comparar </td></tr>
    <tr><td class="paramname">m2</td><td>diccionario a comparar </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">res</td><td>true si m1 es menor a m2 en el orden lexicografico</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd>{completar} </dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd>{completar}</dd></dl>
<p>{ (((m1) + (m2))  ((m1) + (m2)))}</p>
<dl class="section attention"><dt>Attention</dt><dd>Para determinar la comparación de las claves no se utiliza el functor de comparación (que podrian ser distintos entre los diccionarios), sino si los valores son los mismos con respecto al operator&lt; de {K} y T{V}. </dd></dl>

</div>
</div>
<a id="afe374b37f17263d0cad3ee19a590d208"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afe374b37f17263d0cad3ee19a590d208">&#9670;&nbsp;</a></span>operator<=() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class K , class V , class C &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool operator&lt;= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classaed2_1_1map.html">map</a>&lt; K, V, C &gt; &amp;&#160;</td>
          <td class="paramname"><em>m1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classaed2_1_1map.html">map</a>&lt; K, V, C &gt; &amp;&#160;</td>
          <td class="paramname"><em>m2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Renombre de not({m2} &lt; {m1}) </p>
<dl class="section see"><dt>See also</dt><dd>aed2::operator&lt;() </dd></dl>

</div>
</div>
<a id="a42f66578aa7e80b91eded54ac6b745cf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a42f66578aa7e80b91eded54ac6b745cf">&#9670;&nbsp;</a></span>operator<=() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class K , class V , class C &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool operator&lt;= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classaed2_1_1map.html">map</a>&lt; K, V, C &gt; &amp;&#160;</td>
          <td class="paramname"><em>m</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Renombre de not({m2} &lt; {m1}) </p>
<dl class="section see"><dt>See also</dt><dd>aed2::operator&lt;() </dd></dl>

</div>
</div>
<a id="abfc51b39670220e79037ac067006e933"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abfc51b39670220e79037ac067006e933">&#9670;&nbsp;</a></span>operator==() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class K , class V , class C &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classaed2_1_1map.html">map</a>&lt; K, V, C &gt; &amp;&#160;</td>
          <td class="paramname"><em>m1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classaed2_1_1map.html">map</a>&lt; K, V, C &gt; &amp;&#160;</td>
          <td class="paramname"><em>m2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Operador de igualdad entre dos diccionarios. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">K</td><td>clave del diccionario </td></tr>
    <tr><td class="paramname">V</td><td>signficado del diccionario </td></tr>
    <tr><td class="paramname">C</td><td>tipo del comparador</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Requerimientos sobre los tipos</dt><dd>{K} y {V} tienen operator==; vamos a usar  para describir los costos de comparación.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">m1</td><td>diccionario a comparar </td></tr>
    <tr><td class="paramname">m2</td><td>diccionario a comparar </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">res</td><td>true si los diccionarios son iguales</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd>{completar} </dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd>{completar}</dd></dl>
<p>{ (((m1) + (m2))  ((m1) + (m2)))}</p>
<dl class="section attention"><dt>Attention</dt><dd>Para determinar la igualdad de las claves no se utiliza el functor de comparación (que podrian ser distintos entre los diccionarios), sino si los valores son los mismos con respecto al operator== de {K} y T{V}. </dd></dl>

</div>
</div>
<a id="ab32f94f4767358534ab704c98d23ad89"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab32f94f4767358534ab704c98d23ad89">&#9670;&nbsp;</a></span>operator==() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class K , class V , class C &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classaed2_1_1map.html">map</a>&lt; K, V, C &gt; &amp;&#160;</td>
          <td class="paramname"><em>m</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Operador de igualdad entre dos diccionarios. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">K</td><td>clave del diccionario </td></tr>
    <tr><td class="paramname">V</td><td>signficado del diccionario </td></tr>
    <tr><td class="paramname">C</td><td>tipo del comparador</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Requerimientos sobre los tipos</dt><dd>{K} y {V} tienen operator==; vamos a usar  para describir los costos de comparación.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">m1</td><td>diccionario a comparar </td></tr>
    <tr><td class="paramname">m2</td><td>diccionario a comparar </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">res</td><td>true si los diccionarios son iguales</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd>{completar} </dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd>{completar}</dd></dl>
<p>{ (((m1) + (m2))  ((m1) + (m2)))}</p>
<dl class="section attention"><dt>Attention</dt><dd>Para determinar la igualdad de las claves no se utiliza el functor de comparación (que podrian ser distintos entre los diccionarios), sino si los valores son los mismos con respecto al operator== de {K} y T{V}. </dd></dl>

</div>
</div>
<a id="a2000cd874b72034ce7fe730c811b6c63"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2000cd874b72034ce7fe730c811b6c63">&#9670;&nbsp;</a></span>operator>() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class K , class V , class C &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool operator&gt; </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classaed2_1_1map.html">map</a>&lt; K, V, C &gt; &amp;&#160;</td>
          <td class="paramname"><em>m1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classaed2_1_1map.html">map</a>&lt; K, V, C &gt; &amp;&#160;</td>
          <td class="paramname"><em>m2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Renombre de {m2} &lt; {m1}. </p>
<dl class="section see"><dt>See also</dt><dd>aed2::operator&lt;() </dd></dl>

</div>
</div>
<a id="a964e8d831c17d77f457eb87a2f22d0d0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a964e8d831c17d77f457eb87a2f22d0d0">&#9670;&nbsp;</a></span>operator>() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class K , class V , class C &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool operator&gt; </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classaed2_1_1map.html">map</a>&lt; K, V, C &gt; &amp;&#160;</td>
          <td class="paramname"><em>m</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Renombre de {m2} &lt; {m1}. </p>
<dl class="section see"><dt>See also</dt><dd>aed2::operator&lt;() </dd></dl>

</div>
</div>
<a id="a093a6d1a055339c5fc6297a1d47a9159"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a093a6d1a055339c5fc6297a1d47a9159">&#9670;&nbsp;</a></span>operator>=() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class K , class V , class C &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool operator&gt;= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classaed2_1_1map.html">map</a>&lt; K, V, C &gt; &amp;&#160;</td>
          <td class="paramname"><em>m1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classaed2_1_1map.html">map</a>&lt; K, V, C &gt; &amp;&#160;</td>
          <td class="paramname"><em>m2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Renombre de not({m1} &lt; {m2}) </p>
<dl class="section see"><dt>See also</dt><dd>aed2::operator&lt;() </dd></dl>

</div>
</div>
<a id="a68bf5a52b77446e43584fb67d22c365e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a68bf5a52b77446e43584fb67d22c365e">&#9670;&nbsp;</a></span>operator>=() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class K , class V , class C &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool operator&gt;= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classaed2_1_1map.html">map</a>&lt; K, V, C &gt; &amp;&#160;</td>
          <td class="paramname"><em>m</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Renombre de not({m1} &lt; {m2}) </p>
<dl class="section see"><dt>See also</dt><dd>aed2::operator&lt;() </dd></dl>

</div>
</div>
<a id="a119cb2938bbc11c25ebd4fb824782a72"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a119cb2938bbc11c25ebd4fb824782a72">&#9670;&nbsp;</a></span>swap() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class K , class V , class C &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void swap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classaed2_1_1map.html">map</a>&lt; K, V, C &gt; &amp;&#160;</td>
          <td class="paramname"><em>m1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classaed2_1_1map.html">map</a>&lt; K, V, C &gt; &amp;&#160;</td>
          <td class="paramname"><em>m2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Implementa la función swap para cumplir con el concepto swappable. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">K</td><td>clave del diccionario </td></tr>
    <tr><td class="paramname">V</td><td>signficado del diccionario </td></tr>
    <tr><td class="paramname">C</td><td>tipo del comparador</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">m1</td><td>diccionario a intercambiar </td></tr>
    <tr><td class="paramname">m2</td><td>diccionario a intercambiar</td></tr>
  </table>
  </dd>
</dl>
<p>{(1)}</p>
<dl class="section see"><dt>See also</dt><dd><a href="http://en.cppreference.com/w/cpp/concept/Swappable">Swappable</a> </dd></dl>

</div>
</div>
<a id="ae9604c72935a908c0c98a9f40bc38eda"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae9604c72935a908c0c98a9f40bc38eda">&#9670;&nbsp;</a></span>swap() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class K , class V , class C &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void swap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classaed2_1_1map.html">map</a>&lt; K, V, C &gt; &amp;&#160;</td>
          <td class="paramname"><em>m</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Implementa la función swap para cumplir con el concepto swappable. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">K</td><td>clave del diccionario </td></tr>
    <tr><td class="paramname">V</td><td>signficado del diccionario </td></tr>
    <tr><td class="paramname">C</td><td>tipo del comparador</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">m1</td><td>diccionario a intercambiar </td></tr>
    <tr><td class="paramname">m2</td><td>diccionario a intercambiar</td></tr>
  </table>
  </dd>
</dl>
<p>{(1)}</p>
<dl class="section see"><dt>See also</dt><dd><a href="http://en.cppreference.com/w/cpp/concept/Swappable">Swappable</a> </dd></dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li><a class="el" href="map_8h_source.html">map.h</a></li>
<li><a class="el" href="map2_8h_source.html">map2.h</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.14
</small></address>
</body>
</html>
