<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<title>My Project: aed2::map&lt; Key, Meaning, Compare &gt; Class Template Reference</title>

<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css" />

<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>

</head>
<body>
<div id="top"><!-- do not remove this div! -->


<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  
  
  <td style="padding-left: 0.5em;">
   <div id="projectname">My Project
   
   </div>
   
  </td>
  
  
  
 </tr>
 </tbody>
</table>
</div>

<!-- Generated by Doxygen 1.7.6.1 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Friends</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

  <div id="nav-path" class="navpath">
    <ul>
      <li class="navelem"><a class="el" href="namespaceaed2.html">aed2</a>      </li>
      <li class="navelem"><a class="el" href="classaed2_1_1map.html">map</a>      </li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#friends">Friends</a>  </div>
  <div class="headertitle">
<div class="title">aed2::map&lt; Key, Meaning, Compare &gt; Class Template Reference</div>  </div>
</div><!--header-->
<div class="contents">
<!-- doxytag: class="aed2::map" -->
<p>Modulo que implementa un diccionario.  
 <a href="classaed2_1_1map.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="map_8h_source.html">map.h</a>&gt;</code></p>

<p><a href="classaed2_1_1map-members.html">List of all members.</a></p>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classaed2_1_1map_1_1const__iterator.html">const_iterator</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Parte del módulo que implementa los iteradores que no permiten la modificación de los significados.  <a href="classaed2_1_1map_1_1const__iterator.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><b>InnerNode</b></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Estructura (privada) de un nodo no cabecera del árbol red-black. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classaed2_1_1map_1_1iterator.html">iterator</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Parte del módulo que implementa los iteradores que permiten la modificación de los significados.  <a href="classaed2_1_1map_1_1iterator.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><b>Node</b></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Estructura (privada) de un nodo del árbol red-black. <br/></td></tr>
<tr><td colspan="2"><h2><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classaed2_1_1map_1_1iterator.html">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classaed2_1_1map.html#a2ef6723c183916276b0afc4a4c721475">insert_or_assign</a> (<a class="el" href="classaed2_1_1map_1_1const__iterator.html">const_iterator</a> hint, const value_type &amp;value)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classaed2_1_1map_1_1iterator.html">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classaed2_1_1map.html#a9128a806713bcc999ebd8a97ab77e765">insert_or_assign</a> (const value_type &amp;value)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classaed2_1_1map_1_1iterator.html">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classaed2_1_1map.html#ad8e796bf9c9c558e5ce6b61e116253fe">erase</a> (<a class="el" href="classaed2_1_1map_1_1const__iterator.html">const_iterator</a> pos)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Elimina el valor apuntado por {pos}.  <a href="#ad8e796bf9c9c558e5ce6b61e116253fe"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classaed2_1_1map.html#a2ffadb42cd5f0bc7b3752ff159b75334">erase</a> (const Key &amp;key)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Elimina el valor cuya clave es {key}.  <a href="#a2ffadb42cd5f0bc7b3752ff159b75334"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classaed2_1_1map.html#a2bfa5165825979bf2431db55bc6bc9ca">clear</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Vacia el diccionario.  <a href="#a2bfa5165825979bf2431db55bc6bc9ca"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classaed2_1_1map.html#a43ddb71cc91e5c6021a7a1f243d6cc4a">swap</a> (<a class="el" href="classaed2_1_1map.html">map</a> &amp;other)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Intercambia el contenido de {*this} y {other}.  <a href="#a43ddb71cc91e5c6021a7a1f243d6cc4a"></a><br/></td></tr>
<tr><td colspan="2"><div class="groupHeader">Construcción, asignación y destrucción</div></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classaed2_1_1map.html#a64da1d965b13eb28cdb3837bc17a18cf">map</a> (Compare c=Compare())</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Crea un diccionario vacio.  <a href="#a64da1d965b13eb28cdb3837bc17a18cf"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classaed2_1_1map.html#a7a77950a3d8e637bfa7cf5dcd904f257">map</a> (const <a class="el" href="classaed2_1_1map.html">map</a> &amp;other)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor por copia.  <a href="#a7a77950a3d8e637bfa7cf5dcd904f257"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class iterator &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classaed2_1_1map.html#a5d336f3248572beb56be383dcc95cfeb">map</a> (<a class="el" href="classaed2_1_1map_1_1iterator.html">iterator</a> first, <a class="el" href="classaed2_1_1map_1_1iterator.html">iterator</a> last, Compare c=Compare())</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Crea un diccionario con los elementos del rango [{first}, {last})  <a href="#a5d336f3248572beb56be383dcc95cfeb"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classaed2_1_1map.html">map</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classaed2_1_1map.html#ac606d334809066929522964d45e76317">operator=</a> (<a class="el" href="classaed2_1_1map.html">map</a> other)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Operador de asignación.  <a href="#ac606d334809066929522964d45e76317"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classaed2_1_1map.html#ab22c9a85c2dadbc286cd30e97069a8e6">~map</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Destructor.  <a href="#ab22c9a85c2dadbc286cd30e97069a8e6"></a><br/></td></tr>
<tr><td colspan="2"><div class="groupHeader">Busqueda y acceso a los valores</div></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const Meaning &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classaed2_1_1map.html#a0b0a11f906da2926f9eb342fcee79fd7">at</a> (const Key &amp;key) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Devuelve el significado asociado a {key}.  <a href="#a0b0a11f906da2926f9eb342fcee79fd7"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">Meaning &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classaed2_1_1map.html#a6b21c09f59a83b6ee45432dcfa61f4a1">at</a> (const Key &amp;key)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">Meaning &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classaed2_1_1map.html#a96f23896164ab47bee48c26b803f9801">operator[]</a> (const Key &amp;key)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Devuelve el significado asociado a {key}, asegurando su existencia.  <a href="#a96f23896164ab47bee48c26b803f9801"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classaed2_1_1map_1_1iterator.html">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classaed2_1_1map.html#afd0fc1a8234888e61e0e615de7e245b8">find</a> (const Key &amp;key)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Devuelve un iterador a la posicion del valor con clave {key}.  <a href="#afd0fc1a8234888e61e0e615de7e245b8"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classaed2_1_1map_1_1const__iterator.html">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classaed2_1_1map.html#ab8f3e41b1a0d7b74645836f8d2e1acfc">find</a> (const Key &amp;key) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classaed2_1_1map_1_1const__iterator.html">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classaed2_1_1map.html#a3399d36fdd5a880b494f3a5795d3f18f">lower_bound</a> (const Key &amp;key) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Devuelve un iterador al primer valor con clave mayor o igual a {key}.  <a href="#a3399d36fdd5a880b494f3a5795d3f18f"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classaed2_1_1map_1_1iterator.html">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classaed2_1_1map.html#a07b3dd65557c59ee085e5f211269c6b3">lower_bound</a> (const Key &amp;key)</td></tr>
<tr><td colspan="2"><div class="groupHeader">Tamaño del diccionario</div></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classaed2_1_1map.html#af5320ca0a7df4d16015441d5d055a7ee">empty</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Indica si el diccionario esta vacío.  <a href="#af5320ca0a7df4d16015441d5d055a7ee"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classaed2_1_1map.html#a89f2613f926ac13293eafe65889d6021">size</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Devuelve la cantidad de valores en el diccionario.  <a href="#a89f2613f926ac13293eafe65889d6021"></a><br/></td></tr>
<tr><td colspan="2"><div class="groupHeader">Inserción, borrado y modificación</div></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classaed2_1_1map_1_1iterator.html">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classaed2_1_1map.html#a6941cde9a79c27f054b5c97a587a1854">insert</a> (<a class="el" href="classaed2_1_1map_1_1const__iterator.html">const_iterator</a> hint, const value_type &amp;value)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserta {value} en el diccionario.  <a href="#a6941cde9a79c27f054b5c97a587a1854"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classaed2_1_1map_1_1iterator.html">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classaed2_1_1map.html#a60aacba06b1579630b3c8e996cf248c8">insert</a> (const value_type &amp;value)</td></tr>
<tr><td colspan="2"><div class="groupHeader">Recorridos e iteradores</div></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classaed2_1_1map_1_1iterator.html">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classaed2_1_1map.html#a58a95705d54b3dda7f775ce5a22225cb">begin</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Devuelve un iterador al primer valor del diccionario.  <a href="#a58a95705d54b3dda7f775ce5a22225cb"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classaed2_1_1map_1_1const__iterator.html">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classaed2_1_1map.html#a1d10432d305bcb5f1af6ab7b75c27c1c">begin</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classaed2_1_1map_1_1const__iterator.html">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classaed2_1_1map.html#ab96ad892caa28f193481a578f4956a2a">cbegin</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classaed2_1_1map_1_1iterator.html">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classaed2_1_1map.html#a76023e6a56cb625513e1b5ea028bf983">end</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Devuelve un iterador apuntando a la posición pasando-el-ultimo del diccionario.  <a href="#a76023e6a56cb625513e1b5ea028bf983"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classaed2_1_1map_1_1const__iterator.html">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classaed2_1_1map.html#a1f847ad4fd46883ac60d764967172179">end</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classaed2_1_1map_1_1const__iterator.html">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classaed2_1_1map.html#a7bb91e94cbc875f1a011b142ef877912">cend</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">reverse_iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classaed2_1_1map.html#ac412d3902112122c1bffe2d4283a4e9d">rbegin</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Devuelve un iterador al primer valor del diccionario, en un recorrido al revés.  <a href="#ac412d3902112122c1bffe2d4283a4e9d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const_reverse_iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classaed2_1_1map.html#aa68b6888ae3e256203d4ef273c293586">rbegin</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const_reverse_iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classaed2_1_1map.html#a6ad62765a2b2e00247b9e35a7542b448">crbegin</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">reverse_iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classaed2_1_1map.html#a277f03b4f4b6b98879e4e4921081801f">rend</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Devuelve un iterador apuntando a la posición pasando-el-ultimo del diccionario, en un recorrido al revés.  <a href="#a277f03b4f4b6b98879e4e4921081801f"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const_reverse_iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classaed2_1_1map.html#aafce6e53c53c460897613747fec89f9d">rend</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const_reverse_iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classaed2_1_1map.html#a40933b2efe1cb479de9195ea947244d1">crend</a> ()</td></tr>
<tr><td colspan="2"><h2><a name="friends"></a>
Friends</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a67171474c4da6cc8efe0c7fafefd2b2d"></a><!-- doxytag: member="aed2::map::iterator" ref="a67171474c4da6cc8efe0c7fafefd2b2d" args="" -->
class&#160;</td><td class="memItemRight" valign="bottom"><b>iterator</b></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac220ce1c155db1ac44146c12d178056f"></a><!-- doxytag: member="aed2::map::const_iterator" ref="ac220ce1c155db1ac44146c12d178056f" args="" -->
class&#160;</td><td class="memItemRight" valign="bottom"><b>const_iterator</b></td></tr>
<tr><td colspan="2"><h2><a name="related"></a>
Related Functions</h2></td></tr>
<tr><td class="ititle" colspan="2"><p>(Note that these are not member functions.) </p>
</td></tr>
<tr><td colspan="2"><div class="groupHeader">Operadores de comparación</div></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class K , class V , class C &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classaed2_1_1map.html#abfc51b39670220e79037ac067006e933">operator==</a> (const <a class="el" href="classaed2_1_1map.html">map</a>&lt; K, V, C &gt; &amp;m1, const <a class="el" href="classaed2_1_1map.html">map</a>&lt; K, V, C &gt; &amp;m2)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Operador de igualdad entre dos diccionarios.  <a href="#abfc51b39670220e79037ac067006e933"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class K , class V , class C &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classaed2_1_1map.html#abce0fa35c5b25fd67111c2e704616f09">operator!=</a> (const <a class="el" href="classaed2_1_1map.html">map</a>&lt; K, V, C &gt; &amp;m1, const <a class="el" href="classaed2_1_1map.html">map</a>&lt; K, V, C &gt; &amp;m2)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Renombre de not({m1} == {m2})  <a href="#abce0fa35c5b25fd67111c2e704616f09"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class K , class V , class C &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classaed2_1_1map.html#a8ff07f6a24c290ea7e8f63ec7ab24f8d">operator&lt;</a> (const <a class="el" href="classaed2_1_1map.html">map</a>&lt; K, V, C &gt; &amp;m1, const <a class="el" href="classaed2_1_1map.html">map</a>&lt; K, V, C &gt; &amp;m2)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Operador de orden lexicografico entre diccionarios.  <a href="#a8ff07f6a24c290ea7e8f63ec7ab24f8d"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class K , class V , class C &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classaed2_1_1map.html#a2000cd874b72034ce7fe730c811b6c63">operator&gt;</a> (const <a class="el" href="classaed2_1_1map.html">map</a>&lt; K, V, C &gt; &amp;m1, const <a class="el" href="classaed2_1_1map.html">map</a>&lt; K, V, C &gt; &amp;m2)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Renombre de {m2} &lt; {m1}.  <a href="#a2000cd874b72034ce7fe730c811b6c63"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class K , class V , class C &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classaed2_1_1map.html#afe374b37f17263d0cad3ee19a590d208">operator&lt;=</a> (const <a class="el" href="classaed2_1_1map.html">map</a>&lt; K, V, C &gt; &amp;m1, const <a class="el" href="classaed2_1_1map.html">map</a>&lt; K, V, C &gt; &amp;m2)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Renombre de not({m2} &lt; {m1})  <a href="#afe374b37f17263d0cad3ee19a590d208"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class K , class V , class C &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classaed2_1_1map.html#a093a6d1a055339c5fc6297a1d47a9159">operator&gt;=</a> (const <a class="el" href="classaed2_1_1map.html">map</a>&lt; K, V, C &gt; &amp;m1, const <a class="el" href="classaed2_1_1map.html">map</a>&lt; K, V, C &gt; &amp;m2)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Renombre de not({m1} &lt; {m2})  <a href="#a093a6d1a055339c5fc6297a1d47a9159"></a><br/></td></tr>
<tr><td colspan="2"><div class="groupHeader">Implementación de swappable</div></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class K , class V , class C &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classaed2_1_1map.html#a119cb2938bbc11c25ebd4fb824782a72">swap</a> (<a class="el" href="classaed2_1_1map.html">map</a>&lt; K, V, C &gt; &amp;m1, <a class="el" href="classaed2_1_1map.html">map</a>&lt; K, V, C &gt; &amp;m2)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Implementa la función swap para cumplir con el concepto swappable.  <a href="#a119cb2938bbc11c25ebd4fb824782a72"></a><br/></td></tr>
</table>
<hr/><a name="details" id="details"></a><h2>Detailed Description</h2>
<div class="textblock"><h3>template&lt;class Key, class Meaning, class Compare = std::less&lt;Key&gt;&gt;<br/>
class aed2::map&lt; Key, Meaning, Compare &gt;</h3>

<p>Modulo que implementa un diccionario. </p>
<p>El módulo <a class="el" href="classaed2_1_1map.html" title="Modulo que implementa un diccionario.">aed2::map</a> implementa un diccionario <b>ordenado</b> que permite la inserción, modificación, borrado y búsqueda de valores en tiempo logarítmico. Asimismo, permite el acceso y modificación del primer y último valor en tiempo constante, al igual que el borrado e inserción del primer y último valor en tiempo constante amortizado. En forma concisa, este módulo implementa lo que se conoce como un árbol red-black, donde los nodos tienen punteros a los padres y se puede acceder al primer y último nodo de la secuencia inorder.</p>
<p>En cuanto al recorrido de los elementos, se provee un iterador bidireccional con el cual se puede eliminar y agregar elementos en tiempo constante amortizado. De esta forma, se pueden aplicar filtros recorriendo una única vez la estructura. Este iterador sigue la interfaz de C++, con lo cual el iterador siempre se encuentra <em>sobre</em> un elemento. El iterador se puede inicializar tanto apuntando al inicio como al fin. En consecuencia, se puede recorrer el reverso de la secuencia inorder en forma eficiente. Siendo un iterador de C++, disponemos de una posición <em>pasando-el-último</em> que se utiliza para indicar el fin del recorrido o si la posición es inválida.</p>
<dl class=""><dt><b>Template Parameters:</b></dt><dd>
  <table class="">
    <tr><td class="paramname">Key</td><td>tipo de la clave. Ver <a class="el" href="Interfaz.html">Descripción de la interfaz</a>. </td></tr>
    <tr><td class="paramname">Meaning</td><td>tipo del significado. Ver <a class="el" href="Interfaz.html">Descripción de la interfaz</a>. </td></tr>
    <tr><td class="paramname">Compare</td><td>tipo del comparador. Ver <a class="el" href="Interfaz.html">Descripción de la interfaz</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="user"><dt><b>Terminología para describir las complejidades temporales</b></dt><dd>Para describir la complejidad temporal de las operaciones, vamos a llamar:<ul>
<li>(<em>d</em>): a la cantidad de elementos del diccionario <em>d</em> </li>
<li>(<em>v1</em>, <em>v2</em>): al costo de comparar dos valores <em>v1</em> y <em>v2</em> </li>
<li>(<em>d</em>): al maximo costo posible para las comparaciones de elementos en <em>d</em> </li>
<li>(<em>v</em>): al costo de copiar un valor <em>v</em> </li>
<li>(<em>d</em>): a la sumatoria de los costo de copiar todos los elementos de <em>d</em> </li>
<li>(<em>v</em>): al costo de destruir un valor <em>v</em> </li>
<li>(<em>d</em>): a la sumatoria de los costos de destruir todos los elementos de <em>d</em> </li>
</ul>
</dd></dl>
<dl class="user"><dt><b>Funciones esperadas en los parámetros del template</b></dt><dd>Vamos a usar el renombre value_type = std::pair&lt;const Key,Meaning&gt;</dd></dl>
<div class="fragment"><pre class="fragment"> {.cpp}
 <span class="comment">//Constructor por copia de valores.</span>
 <span class="comment">//Complejidad: O(copy(other))</span>
 value_type(<span class="keyword">const</span> value_type&amp; other);

 <span class="comment">//Destructor de los valores</span>
 <span class="comment">//Complejidad: O(del(*this))</span>
 ~value_type();

 <span class="keyword">struct </span>Compare {
   <span class="comment">//Comparacion de dos valores</span>
   <span class="comment">//Complejidad: O(cmp(v1, v2))</span>
   <span class="keywordtype">bool</span> operator()(<span class="keyword">const</span> value_type&amp; v1, <span class="keyword">const</span> value_type&amp; v2) <span class="keyword">const</span>;
 };
</pre></div> <dl class="user"><dt><b>Aspectos generales de aliasing</b></dt><dd>Ninguna operación invalida un iterador asociado a un valor de la estructura, salvo que se elimine el valor apuntado por dicho iterador. Asimismo, niguna operación, salvo swap y el destructor, invalida el puntero pasando-el-último.</dd></dl>
<dl class="user"><dt><b>Se explica con</b></dt><dd>Diccionario({Key}, {Meaning}) con parámetro formal  = f.operator() para algún f de tipo {Compare}.</dd></dl>
<dl class="attention"><dt><b>Attention:</b></dt><dd>No tenemos forma en AED2 de decir que el parámetro formal se define en tiempo de ejecución, como ocurre en este caso. </dd></dl>
</div><hr/><h2>Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="a64da1d965b13eb28cdb3837bc17a18cf"></a><!-- doxytag: member="aed2::map::map" ref="a64da1d965b13eb28cdb3837bc17a18cf" args="(Compare c=Compare())" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key, class Meaning, class Compare = std::less&lt;Key&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classaed2_1_1map.html">aed2::map</a>&lt; Key, Meaning, Compare &gt;::<a class="el" href="classaed2_1_1map.html">map</a> </td>
          <td>(</td>
          <td class="paramtype">Compare&#160;</td>
          <td class="paramname"><em>c</em> = <code>Compare()</code></td><td>)</td>
          <td><code> [inline, explicit]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Crea un diccionario vacio. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">c</td><td>comparador (functor de orden) a utilizar </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt><b>Return values:</b></dt><dd>
  <table class="retval">
    <tr><td class="paramname">res</td><td>diccionario recién construido</td></tr>
  </table>
  </dd>
</dl>
<dl class="pre"><dt><b>Precondition:</b></dt><dd>{true} </dd></dl>
<dl class="post"><dt><b>Postcondition:</b></dt><dd>{res  vacio()}</dd></dl>
<p>{(1)}</p>
<dl class="attention"><dt><b>Attention:</b></dt><dd>El parámetro formal  del TAD diccionario se establece en esta función.  = {c}.operator() ambos hijos de header apuntan a null, y padre de header apunta a null </dd></dl>

</div>
</div>
<a class="anchor" id="a7a77950a3d8e637bfa7cf5dcd904f257"></a><!-- doxytag: member="aed2::map::map" ref="a7a77950a3d8e637bfa7cf5dcd904f257" args="(const map &amp;other)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key, class Meaning, class Compare = std::less&lt;Key&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classaed2_1_1map.html">aed2::map</a>&lt; Key, Meaning, Compare &gt;::<a class="el" href="classaed2_1_1map.html">map</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classaed2_1_1map.html">map</a>&lt; Key, Meaning, Compare &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Constructor por copia. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>diccionario a copiar </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt><b>Return values:</b></dt><dd>
  <table class="retval">
    <tr><td class="paramname">res</td><td>diccionario recien construido</td></tr>
  </table>
  </dd>
</dl>
<dl class="pre"><dt><b>Precondition:</b></dt><dd>{true} </dd></dl>
<dl class="post"><dt><b>Postcondition:</b></dt><dd>{res  other}</dd></dl>
<p>{(({other}))}</p>
<dl class="attention"><dt><b>Attention:</b></dt><dd>El parámetro formal  del TAD diccionario se establece en esta función.  es igual al operator() del comparador de {other} <a class="el" href="classaed2_1_1map.html#a58a95705d54b3dda7f775ce5a22225cb" title="Devuelve un iterador al primer valor del diccionario.">begin()</a> iterador en other. mientras haya Siguiente en el iterador de other, insertar siguiente, y avanzar. </dd></dl>

</div>
</div>
<a class="anchor" id="a5d336f3248572beb56be383dcc95cfeb"></a><!-- doxytag: member="aed2::map::map" ref="a5d336f3248572beb56be383dcc95cfeb" args="(iterator first, iterator last, Compare c=Compare())" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key, class Meaning, class Compare = std::less&lt;Key&gt;&gt; </div>
<div class="memtemplate">
template&lt;class iterator &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classaed2_1_1map.html">aed2::map</a>&lt; Key, Meaning, Compare &gt;::<a class="el" href="classaed2_1_1map.html">map</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classaed2_1_1map_1_1iterator.html">iterator</a>&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classaed2_1_1map_1_1iterator.html">iterator</a>&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Compare&#160;</td>
          <td class="paramname"><em>c</em> = <code>Compare()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Crea un diccionario con los elementos del rango [{first}, {last}) </p>
<dl class=""><dt><b>Template Parameters:</b></dt><dd>
  <table class="">
    <tr><td class="paramname">iterator</td><td>clase del iterador a recorrer</td></tr>
  </table>
  </dd>
</dl>
<dl class="user"><dt><b>Requerimientos sobre el tipo {iterator}</b></dt><dd>El tipo {iterator} debe tener todas las funcionalidades de un <em>InputIterator</em> de C++. En términos de la materia, vamos a suponer que {iterator} se explica con el TAD Iterador Unidireccional(puntero(C), {value_type}) para alguna colección de tipo C.</dd></dl>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">first</td><td>iterador al primer elemento del rango </td></tr>
    <tr><td class="paramname">last</td><td>iterador pasando el ultimo elemento del rango </td></tr>
    <tr><td class="paramname">c</td><td>comparador a utilizar </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt><b>Return values:</b></dt><dd>
  <table class="retval">
    <tr><td class="paramname">res</td><td>diccionario recien construido</td></tr>
  </table>
  </dd>
</dl>
<p>{{first} y {last} son iteradores que recorren la misma secuencia definida por una colección.}</p>
<dl class="pre"><dt><b>Precondition:</b></dt><dd>{last} debe ser alcanzable desde {first} y en el rango [{first}, {last}) no pueden haber valores repetidos.</dd></dl>
<p>{coleccion({first})  coleccion({last})  esSufijo(Siguientes({last}), Siguientes({first}))  (Siguientes({first})  Siguientes({last}))} </p>
<dl class="post"><dt><b>Postcondition:</b></dt><dd>Los valores definidos en {res} son aquellos que aparecen en [{first}, {last})</dd></dl>
<p>{( k: {Key})( s: {Meaning}) (def?({res}, k)  significado({res}, k)  s  esta((k,s), Siguientes({first})  Siguientes({last}))) } </p>
<p>{</p>
<ul>
<li>En el peor caso: (({res})  ((({res}))  ({res}) + ({res})))</li>
<li>Si el rango [{first}, {last}) está ordenado: (({res})  (({res})+ ({res}))) }</li>
</ul>
<dl class="attention"><dt><b>Attention:</b></dt><dd>El parámetro formal  del TAD diccionario se establece en esta función.  = {c}.operator()</dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd>[Documentación de InputIterator](<a href="http://en.cppreference.com/w/cpp/concept/InputIterator">http://en.cppreference.com/w/cpp/concept/InputIterator</a>) </dd></dl>

</div>
</div>
<a class="anchor" id="ab22c9a85c2dadbc286cd30e97069a8e6"></a><!-- doxytag: member="aed2::map::~map" ref="ab22c9a85c2dadbc286cd30e97069a8e6" args="()" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key, class Meaning, class Compare = std::less&lt;Key&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classaed2_1_1map.html">aed2::map</a>&lt; Key, Meaning, Compare &gt;::~<a class="el" href="classaed2_1_1map.html">map</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Destructor. </p>
<p>{completar}</p>
<dl class="pre"><dt><b>Precondition:</b></dt><dd>{true} </dd></dl>
<dl class="post"><dt><b>Postcondition:</b></dt><dd>{true}</dd></dl>
<p>{(({*this}))}</p>
<dl class="attention"><dt><b>Attention:</b></dt><dd>Como se explicita, esta función no hace nada, porque no tiene un objetivo funcional. De hecho, su implementación es innecesaria bajo la hipótesis de infinitud de memoria (que muchos sistemas de especificación, e.g. nuestros TADs, asumen por simplicidad). Sin embargo, esta función tiene un comportamiento real y es liberar la memoria usada. Claramente, esta funcionalidad depende del sistema en que estemos trabajando. Suponiendo que tuvieramos acceso a la implementación de las tablas de memoria del sistema operativo (o al mapa de memoria de la computadora), podríamos expresar la funcionalidad estableciendo la liberación de la memoria inicializa iterador con <a class="el" href="classaed2_1_1map.html#a58a95705d54b3dda7f775ce5a22225cb" title="Devuelve un iterador al primer valor del diccionario.">begin()</a> mientras hay Siguiente, borra (siguiente) </dd></dl>

</div>
</div>
<hr/><h2>Member Function Documentation</h2>
<a class="anchor" id="a0b0a11f906da2926f9eb342fcee79fd7"></a><!-- doxytag: member="aed2::map::at" ref="a0b0a11f906da2926f9eb342fcee79fd7" args="(const Key &amp;key) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key, class Meaning, class Compare = std::less&lt;Key&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const Meaning&amp; <a class="el" href="classaed2_1_1map.html">aed2::map</a>&lt; Key, Meaning, Compare &gt;::<a class="el" href="classaed2_1_1map.html#a0b0a11f906da2926f9eb342fcee79fd7">at</a> </td>
          <td>(</td>
          <td class="paramtype">const Key &amp;&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Devuelve el significado asociado a {key}. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>clave a buscar. </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt><b>Return values:</b></dt><dd>
  <table class="retval">
    <tr><td class="paramname">res</td><td>referencia al significado asociado a {key}.</td></tr>
  </table>
  </dd>
</dl>
<p>{completar}</p>
<dl class="pre"><dt><b>Precondition:</b></dt><dd>{def?(key,*this)}</dd></dl>
<dl class="post"><dt><b>Postcondition:</b></dt><dd>{res  obtener(key,*this)}</dd></dl>
<p>{((({*this})  ({*this}))}</p>
<dl class="remark"><dt><b>Remarks:</b></dt><dd>Esta función, que se asemeja más a la forma de programar propuesta en AED2 que al estándar C++, fue incluida en el estándar C++11. Antes era obligación recurrir a la función find. Comienza en la raiz y si el valor es menor sigue la recursión hacia la izquierda, sino a la derecha, hasta que encuentra un nodo con la clave (key) pasada por parámetro y devuelve el significado almacenado en ese nodo. </dd></dl>

</div>
</div>
<a class="anchor" id="a6b21c09f59a83b6ee45432dcfa61f4a1"></a><!-- doxytag: member="aed2::map::at" ref="a6b21c09f59a83b6ee45432dcfa61f4a1" args="(const Key &amp;key)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key, class Meaning, class Compare = std::less&lt;Key&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Meaning&amp; <a class="el" href="classaed2_1_1map.html">aed2::map</a>&lt; Key, Meaning, Compare &gt;::<a class="el" href="classaed2_1_1map.html#a0b0a11f906da2926f9eb342fcee79fd7">at</a> </td>
          <td>(</td>
          <td class="paramtype">const Key &amp;&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>

</div>
</div>
<a class="anchor" id="a58a95705d54b3dda7f775ce5a22225cb"></a><!-- doxytag: member="aed2::map::begin" ref="a58a95705d54b3dda7f775ce5a22225cb" args="()" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key, class Meaning, class Compare = std::less&lt;Key&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classaed2_1_1map_1_1iterator.html">iterator</a> <a class="el" href="classaed2_1_1map.html">aed2::map</a>&lt; Key, Meaning, Compare &gt;::<a class="el" href="classaed2_1_1map.html#a58a95705d54b3dda7f775ce5a22225cb">begin</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Devuelve un iterador al primer valor del diccionario. </p>
<p>{no hay}</p>
<dl class="retval"><dt><b>Return values:</b></dt><dd>
  <table class="retval">
    <tr><td class="paramname">res</td><td>iterador al primer valor</td></tr>
  </table>
  </dd>
</dl>
<dl class="pre"><dt><b>Precondition:</b></dt><dd>{true} </dd></dl>
<dl class="post"><dt><b>Postcondition:</b></dt><dd>{res  CrearItMod(inorder(*this))}</dd></dl>
<p>{(1)} Inicia un iterador en raíz, y va iterando hacia la izquierda hasta llegar al elemento más chico. Devuelve el iterador. </p>

</div>
</div>
<a class="anchor" id="a1d10432d305bcb5f1af6ab7b75c27c1c"></a><!-- doxytag: member="aed2::map::begin" ref="a1d10432d305bcb5f1af6ab7b75c27c1c" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key, class Meaning, class Compare = std::less&lt;Key&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classaed2_1_1map_1_1const__iterator.html">const_iterator</a> <a class="el" href="classaed2_1_1map.html">aed2::map</a>&lt; Key, Meaning, Compare &gt;::<a class="el" href="classaed2_1_1map.html#a58a95705d54b3dda7f775ce5a22225cb">begin</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>

</div>
</div>
<a class="anchor" id="ab96ad892caa28f193481a578f4956a2a"></a><!-- doxytag: member="aed2::map::cbegin" ref="ab96ad892caa28f193481a578f4956a2a" args="()" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key, class Meaning, class Compare = std::less&lt;Key&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classaed2_1_1map_1_1const__iterator.html">const_iterator</a> <a class="el" href="classaed2_1_1map.html">aed2::map</a>&lt; Key, Meaning, Compare &gt;::<a class="el" href="classaed2_1_1map.html#ab96ad892caa28f193481a578f4956a2a">cbegin</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>

</div>
</div>
<a class="anchor" id="a7bb91e94cbc875f1a011b142ef877912"></a><!-- doxytag: member="aed2::map::cend" ref="a7bb91e94cbc875f1a011b142ef877912" args="()" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key, class Meaning, class Compare = std::less&lt;Key&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classaed2_1_1map_1_1const__iterator.html">const_iterator</a> <a class="el" href="classaed2_1_1map.html">aed2::map</a>&lt; Key, Meaning, Compare &gt;::<a class="el" href="classaed2_1_1map.html#a7bb91e94cbc875f1a011b142ef877912">cend</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>

</div>
</div>
<a class="anchor" id="a2bfa5165825979bf2431db55bc6bc9ca"></a><!-- doxytag: member="aed2::map::clear" ref="a2bfa5165825979bf2431db55bc6bc9ca" args="()" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key, class Meaning, class Compare = std::less&lt;Key&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classaed2_1_1map.html">aed2::map</a>&lt; Key, Meaning, Compare &gt;::<a class="el" href="classaed2_1_1map.html#a2bfa5165825979bf2431db55bc6bc9ca">clear</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Vacia el diccionario. </p>
<p>{Se invalidan todos los iteradores asociados a {*this}, con excepcion de aquellos que apuntan a la posicion pasando-el-ultimo.}</p>
<dl class="pre"><dt><b>Precondition:</b></dt><dd>{true} </dd></dl>
<dl class="post"><dt><b>Postcondition:</b></dt><dd>{{*this}  vacio}</dd></dl>
<p>{(({*this}))} Mientras count sea distinto de 0, va eliminando con la función erase todos los elementos del árbol. </p>

</div>
</div>
<a class="anchor" id="a6ad62765a2b2e00247b9e35a7542b448"></a><!-- doxytag: member="aed2::map::crbegin" ref="a6ad62765a2b2e00247b9e35a7542b448" args="()" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key, class Meaning, class Compare = std::less&lt;Key&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const_reverse_iterator <a class="el" href="classaed2_1_1map.html">aed2::map</a>&lt; Key, Meaning, Compare &gt;::<a class="el" href="classaed2_1_1map.html#a6ad62765a2b2e00247b9e35a7542b448">crbegin</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>

</div>
</div>
<a class="anchor" id="a40933b2efe1cb479de9195ea947244d1"></a><!-- doxytag: member="aed2::map::crend" ref="a40933b2efe1cb479de9195ea947244d1" args="()" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key, class Meaning, class Compare = std::less&lt;Key&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const_reverse_iterator <a class="el" href="classaed2_1_1map.html">aed2::map</a>&lt; Key, Meaning, Compare &gt;::<a class="el" href="classaed2_1_1map.html#a40933b2efe1cb479de9195ea947244d1">crend</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>

</div>
</div>
<a class="anchor" id="af5320ca0a7df4d16015441d5d055a7ee"></a><!-- doxytag: member="aed2::map::empty" ref="af5320ca0a7df4d16015441d5d055a7ee" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key, class Meaning, class Compare = std::less&lt;Key&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classaed2_1_1map.html">aed2::map</a>&lt; Key, Meaning, Compare &gt;::<a class="el" href="classaed2_1_1map.html#af5320ca0a7df4d16015441d5d055a7ee">empty</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Indica si el diccionario esta vacío. </p>
<dl class="retval"><dt><b>Return values:</b></dt><dd>
  <table class="retval">
    <tr><td class="paramname">res</td><td>denota true si y solo si el diccionario está vacío</td></tr>
  </table>
  </dd>
</dl>
<dl class="pre"><dt><b>Precondition:</b></dt><dd>{true} </dd></dl>
<dl class="post"><dt><b>Postcondition:</b></dt><dd>{res   ?(claves(*this))}</dd></dl>
<p>{(1)} Inicia en raíz, y si la misma es distinta de null devuelve false. </p>

</div>
</div>
<a class="anchor" id="a76023e6a56cb625513e1b5ea028bf983"></a><!-- doxytag: member="aed2::map::end" ref="a76023e6a56cb625513e1b5ea028bf983" args="()" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key, class Meaning, class Compare = std::less&lt;Key&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classaed2_1_1map_1_1iterator.html">iterator</a> <a class="el" href="classaed2_1_1map.html">aed2::map</a>&lt; Key, Meaning, Compare &gt;::<a class="el" href="classaed2_1_1map.html#a76023e6a56cb625513e1b5ea028bf983">end</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Devuelve un iterador apuntando a la posición pasando-el-ultimo del diccionario. </p>
<p>{no hay}</p>
<dl class="retval"><dt><b>Return values:</b></dt><dd>
  <table class="retval">
    <tr><td class="paramname">res</td><td>iterador a la posicion pasando-al-ultimo</td></tr>
  </table>
  </dd>
</dl>
<dl class="pre"><dt><b>Precondition:</b></dt><dd>{true} </dd></dl>
<dl class="post"><dt><b>Postcondition:</b></dt><dd>{res  CrearItMod(inorder(*this),  )}</dd></dl>
<p>{(1)}</p>
<p>Inicia un iterador en raíz, y va iterando hacia la derecha hasta llegar al elemento más grande. Devuelve el iterador. </p>

</div>
</div>
<a class="anchor" id="a1f847ad4fd46883ac60d764967172179"></a><!-- doxytag: member="aed2::map::end" ref="a1f847ad4fd46883ac60d764967172179" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key, class Meaning, class Compare = std::less&lt;Key&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classaed2_1_1map_1_1const__iterator.html">const_iterator</a> <a class="el" href="classaed2_1_1map.html">aed2::map</a>&lt; Key, Meaning, Compare &gt;::<a class="el" href="classaed2_1_1map.html#a76023e6a56cb625513e1b5ea028bf983">end</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>

</div>
</div>
<a class="anchor" id="ad8e796bf9c9c558e5ce6b61e116253fe"></a><!-- doxytag: member="aed2::map::erase" ref="ad8e796bf9c9c558e5ce6b61e116253fe" args="(const_iterator pos)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key, class Meaning, class Compare = std::less&lt;Key&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classaed2_1_1map_1_1iterator.html">iterator</a> <a class="el" href="classaed2_1_1map.html">aed2::map</a>&lt; Key, Meaning, Compare &gt;::<a class="el" href="classaed2_1_1map.html#ad8e796bf9c9c558e5ce6b61e116253fe">erase</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classaed2_1_1map_1_1const__iterator.html">const_iterator</a>&#160;</td>
          <td class="paramname"><em>pos</em></td><td>)</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Elimina el valor apuntado por {pos}. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">pos</td><td>iterador apuntando al valor a eliminar. </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt><b>Return values:</b></dt><dd>
  <table class="retval">
    <tr><td class="paramname">res</td><td>iterador apuntando al primer valor con clave mayor a {pos} (o {this}-&gt;<a class="el" href="classaed2_1_1map.html#a76023e6a56cb625513e1b5ea028bf983" title="Devuelve un iterador apuntando a la posición pasando-el-ultimo del diccionario.">end()</a>, si dicho valor no existe).</td></tr>
  </table>
  </dd>
</dl>
<p>{complertar}.</p>
<dl class="pre"><dt><b>Precondition:</b></dt><dd>{HayMas?(pos)} </dd></dl>
<dl class="post"><dt><b>Postcondition:</b></dt><dd>{Eliminar(pos)}</dd></dl>
<p>{</p>
<ul>
<li>Peor caso: (({*pos}) + (({*this})))</li>
<li>Peor caso amortizado: (({*pos})) } </li>
</ul>

</div>
</div>
<a class="anchor" id="a2ffadb42cd5f0bc7b3752ff159b75334"></a><!-- doxytag: member="aed2::map::erase" ref="a2ffadb42cd5f0bc7b3752ff159b75334" args="(const Key &amp;key)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key, class Meaning, class Compare = std::less&lt;Key&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classaed2_1_1map.html">aed2::map</a>&lt; Key, Meaning, Compare &gt;::<a class="el" href="classaed2_1_1map.html#ad8e796bf9c9c558e5ce6b61e116253fe">erase</a> </td>
          <td>(</td>
          <td class="paramtype">const Key &amp;&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Elimina el valor cuya clave es {key}. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>clave del elemento a eliminar</td></tr>
  </table>
  </dd>
</dl>
<p>{completar}</p>
<dl class="pre"><dt><b>Precondition:</b></dt><dd>{*this  *this0  def?(key, *this)} </dd></dl>
<dl class="post"><dt><b>Postcondition:</b></dt><dd>{*this  borrar(key, *this0)}</dd></dl>
<p>{(({*pos}) + (({*this}))  ({*this}))} </p>

</div>
</div>
<a class="anchor" id="afd0fc1a8234888e61e0e615de7e245b8"></a><!-- doxytag: member="aed2::map::find" ref="afd0fc1a8234888e61e0e615de7e245b8" args="(const Key &amp;key)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key, class Meaning, class Compare = std::less&lt;Key&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classaed2_1_1map_1_1iterator.html">iterator</a> <a class="el" href="classaed2_1_1map.html">aed2::map</a>&lt; Key, Meaning, Compare &gt;::<a class="el" href="classaed2_1_1map.html#afd0fc1a8234888e61e0e615de7e245b8">find</a> </td>
          <td>(</td>
          <td class="paramtype">const Key &amp;&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Devuelve un iterador a la posicion del valor con clave {key}. </p>
<p>Retorna un iterador apuntando a la posicion del valor con clave {key}. Si dicho valor no existe, porque la clave no fue definida, entonces el iterador retornado apunta a la posición <em>pasando-el-ultimo</em>.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>clave a buscar </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt><b>Return values:</b></dt><dd>
  <table class="retval">
    <tr><td class="paramname">res</td><td>iterador apuntando al valor con clave {key} (o a {this}-&gt;<a class="el" href="classaed2_1_1map.html#a76023e6a56cb625513e1b5ea028bf983" title="Devuelve un iterador apuntando a la posición pasando-el-ultimo del diccionario.">end()</a> si dicho elemento no existe)</td></tr>
  </table>
  </dd>
</dl>
<p>{Hay aliasing entre el actual(iterador) y obtener(key, *this)}</p>
<dl class="pre"><dt><b>Precondition:</b></dt><dd>{true} </dd></dl>
<dl class="post"><dt><b>Postcondition:</b></dt><dd>{def?(key, *this)  res  crearitAux(key,inorder(*this))}</dd></dl>
<p>{((({*this}))  ({*this}))}</p>
<dl class="attention"><dt><b>Attention:</b></dt><dd>Si el objetivo es insertar un valor con clave {key} de acuerdo a alguna condición, entonces conviene usar <a class="el" href="classaed2_1_1map.html#a3399d36fdd5a880b494f3a5795d3f18f" title="Devuelve un iterador al primer valor con clave mayor o igual a {key}.">aed2::map::lower_bound</a> para la búsqueda, dado que el resultado puede ser usado como hint, mejorando la complejidad de la inserción.<ul>
<li>Inicia el iterador en el hijo izquierdo de header.</li>
<li>Avanzo hasta que la clave sea key o, en caso de que no esté definida, hasta la posición pasando-el-último.</li>
<li>Devuelve el Iterador en esa posición. </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="ab8f3e41b1a0d7b74645836f8d2e1acfc"></a><!-- doxytag: member="aed2::map::find" ref="ab8f3e41b1a0d7b74645836f8d2e1acfc" args="(const Key &amp;key) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key, class Meaning, class Compare = std::less&lt;Key&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classaed2_1_1map_1_1const__iterator.html">const_iterator</a> <a class="el" href="classaed2_1_1map.html">aed2::map</a>&lt; Key, Meaning, Compare &gt;::<a class="el" href="classaed2_1_1map.html#afd0fc1a8234888e61e0e615de7e245b8">find</a> </td>
          <td>(</td>
          <td class="paramtype">const Key &amp;&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>

</div>
</div>
<a class="anchor" id="a6941cde9a79c27f054b5c97a587a1854"></a><!-- doxytag: member="aed2::map::insert" ref="a6941cde9a79c27f054b5c97a587a1854" args="(const_iterator hint, const value_type &amp;value)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key, class Meaning, class Compare = std::less&lt;Key&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classaed2_1_1map_1_1iterator.html">iterator</a> <a class="el" href="classaed2_1_1map.html">aed2::map</a>&lt; Key, Meaning, Compare &gt;::<a class="el" href="classaed2_1_1map.html#a6941cde9a79c27f054b5c97a587a1854">insert</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classaed2_1_1map_1_1const__iterator.html">const_iterator</a>&#160;</td>
          <td class="paramname"><em>hint</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const value_type &amp;&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Inserta {value} en el diccionario. </p>
<p>Inserta un <b>nuevo</b> valor en el diccionario. Si {*this} ya tiene un valor con clave {value}.first, entonces la función no tiene efectos. El iterador de retorno apunta al elemento recien insertado (o aquel que previno la insercion).</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>valor a insertar </td></tr>
    <tr><td class="paramname">hint</td><td>iterador apuntando al diccionario. Se espera que apunte al minimo valor mayor o igual a {value}.first (i.e., a lower_bound({value}.first)). Igualmente, la función es robusta y funciona correctamente aunque esto no ocurra. </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt><b>Return values:</b></dt><dd>
  <table class="retval">
    <tr><td class="paramname">res</td><td>iterador apuntando al elemento insertado o que previno la inserción</td></tr>
  </table>
  </dd>
</dl>
<p>{hay aliasing???}</p>
<dl class="pre"><dt><b>Precondition:</b></dt><dd>{true} </dd></dl>
<dl class="post"><dt><b>Postcondition:</b></dt><dd>{def?(value.first, *this)  crearitAux(*this.first, inorder(*this) )   def?(value.first, *this)  res  agregar(crearIt(inorder(*this)), value)}</dd></dl>
<p>{</p>
<ul>
<li>Peor caso: ((({*this}))  ({*this})  ({value}))</li>
<li>Si {hint} apunta al primer valor con clave al menos {value}.first (o {this}-&gt;<a class="el" href="classaed2_1_1map.html#a76023e6a56cb625513e1b5ea028bf983" title="Devuelve un iterador apuntando a la posición pasando-el-ultimo del diccionario.">end()</a> en caso de no existir): (({*this})  ({value})) amortizado. }</li>
</ul>
<dl class="attention"><dt><b>Attention:</b></dt><dd>Para garantizar que el nuevo elemento se inserte sí o sí, usar <a class="el" href="classaed2_1_1map.html#a2ef6723c183916276b0afc4a4c721475">aed2::map::insert_or_assign</a>. </dd></dl>

</div>
</div>
<a class="anchor" id="a60aacba06b1579630b3c8e996cf248c8"></a><!-- doxytag: member="aed2::map::insert" ref="a60aacba06b1579630b3c8e996cf248c8" args="(const value_type &amp;value)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key, class Meaning, class Compare = std::less&lt;Key&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classaed2_1_1map_1_1iterator.html">iterator</a> <a class="el" href="classaed2_1_1map.html">aed2::map</a>&lt; Key, Meaning, Compare &gt;::<a class="el" href="classaed2_1_1map.html#a6941cde9a79c27f054b5c97a587a1854">insert</a> </td>
          <td>(</td>
          <td class="paramtype">const value_type &amp;&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>

</div>
</div>
<a class="anchor" id="a2ef6723c183916276b0afc4a4c721475"></a><!-- doxytag: member="aed2::map::insert_or_assign" ref="a2ef6723c183916276b0afc4a4c721475" args="(const_iterator hint, const value_type &amp;value)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key, class Meaning, class Compare = std::less&lt;Key&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classaed2_1_1map_1_1iterator.html">iterator</a> <a class="el" href="classaed2_1_1map.html">aed2::map</a>&lt; Key, Meaning, Compare &gt;::<a class="el" href="classaed2_1_1map.html#a2ef6723c183916276b0afc4a4c721475">insert_or_assign</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classaed2_1_1map_1_1const__iterator.html">const_iterator</a>&#160;</td>
          <td class="paramname"><em>hint</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const value_type &amp;&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>{</p>
<ul>
<li>Peor caso: ((({*this}))  ({*this})  ({value}))</li>
<li>Si {hint} apunta al primer valor con clave al menos {value}.first (o {this}-&gt;<a class="el" href="classaed2_1_1map.html#a76023e6a56cb625513e1b5ea028bf983" title="Devuelve un iterador apuntando a la posición pasando-el-ultimo del diccionario.">end()</a> en caso de no existir): (({*this})  ({value})) amortizado. }</li>
</ul>
<dl class="attention"><dt><b>Attention:</b></dt><dd>Para prevenir que el nuevo valor redefina uno ya existente, usar <a class="el" href="classaed2_1_1map.html#a6941cde9a79c27f054b5c97a587a1854" title="Inserta {value} en el diccionario.">aed2::map::insert</a>. </dd></dl>
<dl class="remark"><dt><b>Remarks:</b></dt><dd>Esta función es similar al operator[], pero tiene dos ventajas y una desventaja. Las ventajas es que 1. se puede indicar un {hint} para la búsqueda y 2. no es necesario que {Meaning} tenga constructor sin parámetros. La desventaja es que la notación no es tan bonita. </dd></dl>

</div>
</div>
<a class="anchor" id="a9128a806713bcc999ebd8a97ab77e765"></a><!-- doxytag: member="aed2::map::insert_or_assign" ref="a9128a806713bcc999ebd8a97ab77e765" args="(const value_type &amp;value)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key, class Meaning, class Compare = std::less&lt;Key&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classaed2_1_1map_1_1iterator.html">iterator</a> <a class="el" href="classaed2_1_1map.html">aed2::map</a>&lt; Key, Meaning, Compare &gt;::<a class="el" href="classaed2_1_1map.html#a2ef6723c183916276b0afc4a4c721475">insert_or_assign</a> </td>
          <td>(</td>
          <td class="paramtype">const value_type &amp;&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>

</div>
</div>
<a class="anchor" id="a3399d36fdd5a880b494f3a5795d3f18f"></a><!-- doxytag: member="aed2::map::lower_bound" ref="a3399d36fdd5a880b494f3a5795d3f18f" args="(const Key &amp;key) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key, class Meaning, class Compare = std::less&lt;Key&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classaed2_1_1map_1_1const__iterator.html">const_iterator</a> <a class="el" href="classaed2_1_1map.html">aed2::map</a>&lt; Key, Meaning, Compare &gt;::<a class="el" href="classaed2_1_1map.html#a3399d36fdd5a880b494f3a5795d3f18f">lower_bound</a> </td>
          <td>(</td>
          <td class="paramtype">const Key &amp;&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Devuelve un iterador al primer valor con clave mayor o igual a {key}. </p>
<p>Retorna un iterador apuntando a la primer posición cuyo valor tenga clave al menos {key}. Si dicho valor no existe, porque {key} es mayor a todas las claves de {*this}, entonces el iterador retornado apunta a la posición <em>pasando-el-último</em>.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>clave a buscar </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt><b>Return values:</b></dt><dd>
  <table class="retval">
    <tr><td class="paramname">res</td><td>iterador apuntando al valor con clave al menos {key} (o a {this}-&gt;<a class="el" href="classaed2_1_1map.html#a76023e6a56cb625513e1b5ea028bf983" title="Devuelve un iterador apuntando a la posición pasando-el-ultimo del diccionario.">end()</a> si dicho elemento no existe)</td></tr>
  </table>
  </dd>
</dl>
<p>{hay aliasing entre res y el sucesor inmediato de key}</p>
<dl class="pre"><dt><b>Precondition:</b></dt><dd>{true} </dd></dl>
<dl class="post"><dt><b>Postcondition:</b></dt><dd>{res  crearitAux2(key,inorder(*this))(busca en la secu inorder a key y devuelve el siguiente o null si es mayor a todas las claves)}</dd></dl>
<p>{((({*this}))  ({*this}))}</p>
<ul>
<li>Inicia el iterador en el hijo izquierdo de header.</li>
<li>Avanzo hasta que la clave sea mayor o igual a key o, en caso de que no exista ninguna, hasta la posición pasando-el-último.</li>
<li>Devuelve el Iterador en esa posición. </li>
</ul>

</div>
</div>
<a class="anchor" id="a07b3dd65557c59ee085e5f211269c6b3"></a><!-- doxytag: member="aed2::map::lower_bound" ref="a07b3dd65557c59ee085e5f211269c6b3" args="(const Key &amp;key)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key, class Meaning, class Compare = std::less&lt;Key&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classaed2_1_1map_1_1iterator.html">iterator</a> <a class="el" href="classaed2_1_1map.html">aed2::map</a>&lt; Key, Meaning, Compare &gt;::<a class="el" href="classaed2_1_1map.html#a3399d36fdd5a880b494f3a5795d3f18f">lower_bound</a> </td>
          <td>(</td>
          <td class="paramtype">const Key &amp;&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>

</div>
</div>
<a class="anchor" id="ac606d334809066929522964d45e76317"></a><!-- doxytag: member="aed2::map::operator=" ref="ac606d334809066929522964d45e76317" args="(map other)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key, class Meaning, class Compare = std::less&lt;Key&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classaed2_1_1map.html">map</a>&amp; <a class="el" href="classaed2_1_1map.html">aed2::map</a>&lt; Key, Meaning, Compare &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classaed2_1_1map.html">map</a>&lt; Key, Meaning, Compare &gt;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Operador de asignación. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>diccionario a copiar </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt><b>Return values:</b></dt><dd>
  <table class="retval">
    <tr><td class="paramname">res</td><td>referencia a *this</td></tr>
  </table>
  </dd>
</dl>
<p>{no hay}</p>
<dl class="pre"><dt><b>Precondition:</b></dt><dd>{true} </dd></dl>
<dl class="post"><dt><b>Postcondition:</b></dt><dd>{res  other}</dd></dl>
<p>{(({*this})  ({other}))}</p>
<dl class="note"><dt><b>Note:</b></dt><dd>Es importante remarcar que no se realiza ninguna comparación entre los elementos. -destruir this<ul>
<li>this-&gt;map(other) </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="a96f23896164ab47bee48c26b803f9801"></a><!-- doxytag: member="aed2::map::operator[]" ref="a96f23896164ab47bee48c26b803f9801" args="(const Key &amp;key)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key, class Meaning, class Compare = std::less&lt;Key&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Meaning&amp; <a class="el" href="classaed2_1_1map.html">aed2::map</a>&lt; Key, Meaning, Compare &gt;::operator[] </td>
          <td>(</td>
          <td class="paramtype">const Key &amp;&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Devuelve el significado asociado a {key}, asegurando su existencia. </p>
<p>Devuelve el significado asociado a {key}. Si {key} no está definido en {*this}, entonces se inserta un nuevo valor con clave {key} y significado {Meaning}(). De esta forma, podemos usar `operator[]` para definir nuevos valores o modificar los existentes.</p>
<p>Ejemplo: </p>
<div class="fragment"><pre class="fragment"> {.cpp}
 <a class="code" href="classaed2_1_1map.html" title="Modulo que implementa un diccionario.">aed2::map&lt;int, int&gt;</a> d;
 d[1] = 2;      <span class="comment">//define 1 -&gt; 2</span>
 d[1] = 3;      <span class="comment">//redefine 1 -&gt; 3</span>

 <a class="code" href="classaed2_1_1map.html" title="Modulo que implementa un diccionario.">aed2::map&lt;int, int&gt;</a> m;
 <span class="keywordflow">if</span>(m[1] == 3) {...} <span class="comment">//posible bug: define 1 -&gt; basura (que puede o no ser 3).</span>
</pre></div><dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>clave a buscar. </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt><b>Return values:</b></dt><dd>
  <table class="retval">
    <tr><td class="paramname">res</td><td>referencia al significado asociado a {key}.</td></tr>
  </table>
  </dd>
</dl>
<dl class="user"><dt><b>Requerimientos sobre el tipo {Meaning}</b></dt><dd>Requiere que {Meaning} tenga un constructor sin parámetros con complejidad (<em>c</em>)</dd></dl>
<p>{hay aliasing entre res y obtener(key, *this)}</p>
<dl class="pre"><dt><b>Precondition:</b></dt><dd>{true} </dd></dl>
<dl class="post"><dt><b>Postcondition:</b></dt><dd>{def?(key, *this)  res  obtener(key, *this)}</dd></dl>
<p>{((({*this}))  ({*this}) + <em>x</em>) donde</p>
<ul>
<li><em>x</em> = 1 si def?(<em>self</em>, {key}), y</li>
<li><em>x</em> = <em>c</em> en caso contrario.} Comienza en la raiz y si el valor es menor sigue la recursión hacia la izquierda, sino a la derecha, hasta que encuentra un nodo con la clave (key) pasada por parámetro y devuelve el significado almacenado en ese nodo, o en el caso que la clave no esté definida, la define con el significado default y además incrementa en uno count. </li>
</ul>
<p>it = lower_bound(key); if (it.nodo-&gt;value_.key() == key) return value_-&gt;second; else insert(it, value(key, Meaning))</p>

</div>
</div>
<a class="anchor" id="ac412d3902112122c1bffe2d4283a4e9d"></a><!-- doxytag: member="aed2::map::rbegin" ref="ac412d3902112122c1bffe2d4283a4e9d" args="()" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key, class Meaning, class Compare = std::less&lt;Key&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">reverse_iterator <a class="el" href="classaed2_1_1map.html">aed2::map</a>&lt; Key, Meaning, Compare &gt;::<a class="el" href="classaed2_1_1map.html#ac412d3902112122c1bffe2d4283a4e9d">rbegin</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Devuelve un iterador al primer valor del diccionario, en un recorrido al revés. </p>
<p>{no hay}</p>
<dl class="retval"><dt><b>Return values:</b></dt><dd>
  <table class="retval">
    <tr><td class="paramname">res</td><td>iterador a la primer posicion en un recorrido al revés</td></tr>
  </table>
  </dd>
</dl>
<dl class="pre"><dt><b>Precondition:</b></dt><dd>{true} </dd></dl>
<dl class="post"><dt><b>Postcondition:</b></dt><dd>{res  CrearItMod(  , postorder(*this))}</dd></dl>
<p>{(1)}</p>
<p>Inicia un reverse_iterator en el hijo derecho de header. </p>

</div>
</div>
<a class="anchor" id="aa68b6888ae3e256203d4ef273c293586"></a><!-- doxytag: member="aed2::map::rbegin" ref="aa68b6888ae3e256203d4ef273c293586" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key, class Meaning, class Compare = std::less&lt;Key&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const_reverse_iterator <a class="el" href="classaed2_1_1map.html">aed2::map</a>&lt; Key, Meaning, Compare &gt;::<a class="el" href="classaed2_1_1map.html#ac412d3902112122c1bffe2d4283a4e9d">rbegin</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>

</div>
</div>
<a class="anchor" id="a277f03b4f4b6b98879e4e4921081801f"></a><!-- doxytag: member="aed2::map::rend" ref="a277f03b4f4b6b98879e4e4921081801f" args="()" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key, class Meaning, class Compare = std::less&lt;Key&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">reverse_iterator <a class="el" href="classaed2_1_1map.html">aed2::map</a>&lt; Key, Meaning, Compare &gt;::<a class="el" href="classaed2_1_1map.html#a277f03b4f4b6b98879e4e4921081801f">rend</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Devuelve un iterador apuntando a la posición pasando-el-ultimo del diccionario, en un recorrido al revés. </p>
<p>{no hay}</p>
<dl class="retval"><dt><b>Return values:</b></dt><dd>
  <table class="retval">
    <tr><td class="paramname">res</td><td>iterador a la posicion pasando-al-ultimo, en un recorrido al revés</td></tr>
  </table>
  </dd>
</dl>
<dl class="pre"><dt><b>Precondition:</b></dt><dd>{true} </dd></dl>
<dl class="post"><dt><b>Postcondition:</b></dt><dd>{res  CrearItMod(postorder(*this),  )}</dd></dl>
<p>{(1)}</p>
<p>Inicia un reversre_iterator en el hijo izquierdo de header. </p>

</div>
</div>
<a class="anchor" id="aafce6e53c53c460897613747fec89f9d"></a><!-- doxytag: member="aed2::map::rend" ref="aafce6e53c53c460897613747fec89f9d" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key, class Meaning, class Compare = std::less&lt;Key&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const_reverse_iterator <a class="el" href="classaed2_1_1map.html">aed2::map</a>&lt; Key, Meaning, Compare &gt;::<a class="el" href="classaed2_1_1map.html#a277f03b4f4b6b98879e4e4921081801f">rend</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>

</div>
</div>
<a class="anchor" id="a89f2613f926ac13293eafe65889d6021"></a><!-- doxytag: member="aed2::map::size" ref="a89f2613f926ac13293eafe65889d6021" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key, class Meaning, class Compare = std::less&lt;Key&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">size_t <a class="el" href="classaed2_1_1map.html">aed2::map</a>&lt; Key, Meaning, Compare &gt;::<a class="el" href="classaed2_1_1map.html#a89f2613f926ac13293eafe65889d6021">size</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Devuelve la cantidad de valores en el diccionario. </p>
<dl class="retval"><dt><b>Return values:</b></dt><dd>
  <table class="retval">
    <tr><td class="paramname">res</td><td>cantidad de valores</td></tr>
  </table>
  </dd>
</dl>
<dl class="pre"><dt><b>Precondition:</b></dt><dd>{true} </dd></dl>
<dl class="post"><dt><b>Postcondition:</b></dt><dd>{res  #claves(*this)}</dd></dl>
<p>{(1)} Devuelve count; </p>

</div>
</div>
<a class="anchor" id="a43ddb71cc91e5c6021a7a1f243d6cc4a"></a><!-- doxytag: member="aed2::map::swap" ref="a43ddb71cc91e5c6021a7a1f243d6cc4a" args="(map &amp;other)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key, class Meaning, class Compare = std::less&lt;Key&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classaed2_1_1map.html">aed2::map</a>&lt; Key, Meaning, Compare &gt;::<a class="el" href="classaed2_1_1map.html#a43ddb71cc91e5c6021a7a1f243d6cc4a">swap</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classaed2_1_1map.html">map</a>&lt; Key, Meaning, Compare &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Intercambia el contenido de {*this} y {other}. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>diccionario a intercambiar con {*this}</td></tr>
  </table>
  </dd>
</dl>
<p>{Todos los iteradores, salvo aquellos que apuntan a las posiciones pasando-el-ultimo, se mantienen válidos. Aquellos iteradores que apuntan a la posición pasando-el-ultimo de {*this} pasan a apuntar a la posición pasando-el-ultimo de {other}, y viceversa.}</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>mapa a intercambiar con this</td></tr>
  </table>
  </dd>
</dl>
<dl class="pre"><dt><b>Precondition:</b></dt><dd>{<em>self</em> = {*this}  <em>oth</em> = {other}} </dd></dl>
<dl class="post"><dt><b>Postcondition:</b></dt><dd>{{*this}  <em>oth</em>  {other} = <em>self}</em> </dd></dl>
<p>{(1)}</p>
<dl class="note"><dt><b>Note:</b></dt><dd>La razón por la que se "invalidan" los iteradores pasando-el-fin tiene que ver con la forma en que se implementa el módulo (que emula la implementacion de C++). No hay ninguna razón técnica que impida mantener los iteradores pasando el fin, salvo por un pequeño ahorro de memoria y tiempo. En caso de querer usar los iteradores como punteros, se recomienda usar el iterador nulo de diccionario para representar al valor inválido, en lugar de usar los iteradores pasando-el-ultimo. </dd></dl>

</div>
</div>
<hr/><h2>Friends And Related Function Documentation</h2>
<a class="anchor" id="abce0fa35c5b25fd67111c2e704616f09"></a><!-- doxytag: member="aed2::map::operator!=" ref="abce0fa35c5b25fd67111c2e704616f09" args="(const map&lt; K, V, C &gt; &amp;m1, const map&lt; K, V, C &gt; &amp;m2)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class K , class V , class C &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool operator!= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classaed2_1_1map.html">map</a>&lt; K, V, C &gt; &amp;&#160;</td>
          <td class="paramname"><em>m1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classaed2_1_1map.html">map</a>&lt; K, V, C &gt; &amp;&#160;</td>
          <td class="paramname"><em>m2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [related]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Renombre de not({m1} == {m2}) </p>
<dl class="see"><dt><b>See also:</b></dt><dd>aed2::operator==() </dd></dl>

</div>
</div>
<a class="anchor" id="a8ff07f6a24c290ea7e8f63ec7ab24f8d"></a><!-- doxytag: member="aed2::map::operator&lt;" ref="a8ff07f6a24c290ea7e8f63ec7ab24f8d" args="(const map&lt; K, V, C &gt; &amp;m1, const map&lt; K, V, C &gt; &amp;m2)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class K , class V , class C &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool operator&lt; </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classaed2_1_1map.html">map</a>&lt; K, V, C &gt; &amp;&#160;</td>
          <td class="paramname"><em>m1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classaed2_1_1map.html">map</a>&lt; K, V, C &gt; &amp;&#160;</td>
          <td class="paramname"><em>m2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [related]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Operador de orden lexicografico entre diccionarios. </p>
<dl class=""><dt><b>Template Parameters:</b></dt><dd>
  <table class="">
    <tr><td class="paramname">K</td><td>clave del diccionario </td></tr>
    <tr><td class="paramname">V</td><td>signficado del diccionario </td></tr>
    <tr><td class="paramname">C</td><td>tipo del comparador</td></tr>
  </table>
  </dd>
</dl>
<dl class="user"><dt><b>Requerimientos sobre los tipos</b></dt><dd>{K} y {V} tienen operator&lt;; vamos a usar  para describir los costos de comparación.</dd></dl>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">m1</td><td>diccionario a comparar </td></tr>
    <tr><td class="paramname">m2</td><td>diccionario a comparar </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt><b>Return values:</b></dt><dd>
  <table class="retval">
    <tr><td class="paramname">res</td><td>true si m1 es menor a m2 en el orden lexicografico</td></tr>
  </table>
  </dd>
</dl>
<dl class="pre"><dt><b>Precondition:</b></dt><dd>{completar} </dd></dl>
<dl class="post"><dt><b>Postcondition:</b></dt><dd>{completar}</dd></dl>
<p>{ (((m1) + (m2))  ((m1) + (m2)))}</p>
<dl class="attention"><dt><b>Attention:</b></dt><dd>Para determinar la comparación de las claves no se utiliza el functor de comparación (que podrian ser distintos entre los diccionarios), sino si los valores son los mismos con respecto al operator&lt; de {K} y T{V}. </dd></dl>

</div>
</div>
<a class="anchor" id="afe374b37f17263d0cad3ee19a590d208"></a><!-- doxytag: member="aed2::map::operator&lt;=" ref="afe374b37f17263d0cad3ee19a590d208" args="(const map&lt; K, V, C &gt; &amp;m1, const map&lt; K, V, C &gt; &amp;m2)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class K , class V , class C &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool operator&lt;= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classaed2_1_1map.html">map</a>&lt; K, V, C &gt; &amp;&#160;</td>
          <td class="paramname"><em>m1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classaed2_1_1map.html">map</a>&lt; K, V, C &gt; &amp;&#160;</td>
          <td class="paramname"><em>m2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [related]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Renombre de not({m2} &lt; {m1}) </p>
<dl class="see"><dt><b>See also:</b></dt><dd>aed2::operator&lt;() </dd></dl>

</div>
</div>
<a class="anchor" id="abfc51b39670220e79037ac067006e933"></a><!-- doxytag: member="aed2::map::operator==" ref="abfc51b39670220e79037ac067006e933" args="(const map&lt; K, V, C &gt; &amp;m1, const map&lt; K, V, C &gt; &amp;m2)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class K , class V , class C &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classaed2_1_1map.html">map</a>&lt; K, V, C &gt; &amp;&#160;</td>
          <td class="paramname"><em>m1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classaed2_1_1map.html">map</a>&lt; K, V, C &gt; &amp;&#160;</td>
          <td class="paramname"><em>m2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [related]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Operador de igualdad entre dos diccionarios. </p>
<dl class=""><dt><b>Template Parameters:</b></dt><dd>
  <table class="">
    <tr><td class="paramname">K</td><td>clave del diccionario </td></tr>
    <tr><td class="paramname">V</td><td>signficado del diccionario </td></tr>
    <tr><td class="paramname">C</td><td>tipo del comparador</td></tr>
  </table>
  </dd>
</dl>
<dl class="user"><dt><b>Requerimientos sobre los tipos</b></dt><dd>{K} y {V} tienen operator==; vamos a usar  para describir los costos de comparación.</dd></dl>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">m1</td><td>diccionario a comparar </td></tr>
    <tr><td class="paramname">m2</td><td>diccionario a comparar </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt><b>Return values:</b></dt><dd>
  <table class="retval">
    <tr><td class="paramname">res</td><td>true si los diccionarios son iguales</td></tr>
  </table>
  </dd>
</dl>
<dl class="pre"><dt><b>Precondition:</b></dt><dd>{completar} </dd></dl>
<dl class="post"><dt><b>Postcondition:</b></dt><dd>{completar}</dd></dl>
<p>{ (((m1) + (m2))  ((m1) + (m2)))}</p>
<dl class="attention"><dt><b>Attention:</b></dt><dd>Para determinar la igualdad de las claves no se utiliza el functor de comparación (que podrian ser distintos entre los diccionarios), sino si los valores son los mismos con respecto al operator== de {K} y T{V}. </dd></dl>

</div>
</div>
<a class="anchor" id="a2000cd874b72034ce7fe730c811b6c63"></a><!-- doxytag: member="aed2::map::operator&gt;" ref="a2000cd874b72034ce7fe730c811b6c63" args="(const map&lt; K, V, C &gt; &amp;m1, const map&lt; K, V, C &gt; &amp;m2)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class K , class V , class C &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool operator&gt; </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classaed2_1_1map.html">map</a>&lt; K, V, C &gt; &amp;&#160;</td>
          <td class="paramname"><em>m1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classaed2_1_1map.html">map</a>&lt; K, V, C &gt; &amp;&#160;</td>
          <td class="paramname"><em>m2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [related]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Renombre de {m2} &lt; {m1}. </p>
<dl class="see"><dt><b>See also:</b></dt><dd>aed2::operator&lt;() </dd></dl>

</div>
</div>
<a class="anchor" id="a093a6d1a055339c5fc6297a1d47a9159"></a><!-- doxytag: member="aed2::map::operator&gt;=" ref="a093a6d1a055339c5fc6297a1d47a9159" args="(const map&lt; K, V, C &gt; &amp;m1, const map&lt; K, V, C &gt; &amp;m2)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class K , class V , class C &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool operator&gt;= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classaed2_1_1map.html">map</a>&lt; K, V, C &gt; &amp;&#160;</td>
          <td class="paramname"><em>m1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classaed2_1_1map.html">map</a>&lt; K, V, C &gt; &amp;&#160;</td>
          <td class="paramname"><em>m2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [related]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Renombre de not({m1} &lt; {m2}) </p>
<dl class="see"><dt><b>See also:</b></dt><dd>aed2::operator&lt;() </dd></dl>

</div>
</div>
<a class="anchor" id="a119cb2938bbc11c25ebd4fb824782a72"></a><!-- doxytag: member="aed2::map::swap" ref="a119cb2938bbc11c25ebd4fb824782a72" args="(map&lt; K, V, C &gt; &amp;m1, map&lt; K, V, C &gt; &amp;m2)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class K , class V , class C &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classaed2_1_1map.html#a43ddb71cc91e5c6021a7a1f243d6cc4a">swap</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classaed2_1_1map.html">map</a>&lt; K, V, C &gt; &amp;&#160;</td>
          <td class="paramname"><em>m1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classaed2_1_1map.html">map</a>&lt; K, V, C &gt; &amp;&#160;</td>
          <td class="paramname"><em>m2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [related]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Implementa la función swap para cumplir con el concepto swappable. </p>
<dl class=""><dt><b>Template Parameters:</b></dt><dd>
  <table class="">
    <tr><td class="paramname">K</td><td>clave del diccionario </td></tr>
    <tr><td class="paramname">V</td><td>signficado del diccionario </td></tr>
    <tr><td class="paramname">C</td><td>tipo del comparador</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">m1</td><td>diccionario a intercambiar </td></tr>
    <tr><td class="paramname">m2</td><td>diccionario a intercambiar</td></tr>
  </table>
  </dd>
</dl>
<p>{(1)}</p>
<dl class="see"><dt><b>See also:</b></dt><dd>[Swappable](<a href="http://en.cppreference.com/w/cpp/concept/Swappable">http://en.cppreference.com/w/cpp/concept/Swappable</a>) </dd></dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li><a class="el" href="map_8h_source.html">map.h</a></li>
</ul>
</div><!-- contents -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Friends</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>



<hr class="footer"/><address class="footer"><small>
Generated on Sun May 28 2017 15:36:56 for My Project by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.7.6.1
</small></address>

</body>
</html>
