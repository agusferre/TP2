<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.14"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>My Project: aed2::iterator::iterator Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">My Project
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.14 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespaceaed2.html">aed2</a></li><li class="navelem"><a class="el" href="classaed2_1_1iterator.html">iterator</a></li><li class="navelem"><a class="el" href="classaed2_1_1iterator_1_1iterator.html">iterator</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#friends">Friends</a> &#124;
<a href="classaed2_1_1iterator_1_1iterator-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">aed2::iterator::iterator Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Parte del módulo que implementa los iteradores que permiten la modificación de los significados.  
 <a href="classaed2_1_1iterator_1_1iterator.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="map2_8h_source.html">map2.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:ad98a0b33afe1df977c248314251fe2b2"><td class="memItemLeft" align="right" valign="top"><a id="ad98a0b33afe1df977c248314251fe2b2"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classaed2_1_1iterator_1_1iterator.html#ad98a0b33afe1df977c248314251fe2b2">iterator_category</a> = std::bidirectional_iterator_tag</td></tr>
<tr class="memdesc:ad98a0b33afe1df977c248314251fe2b2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Categoria del iterador: bidireccional. Requerido por estándar C++. <br /></td></tr>
<tr class="separator:ad98a0b33afe1df977c248314251fe2b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a10ed10b6d144d04ae127ef846e1d4e7c"><td class="memItemLeft" align="right" valign="top"><a id="a10ed10b6d144d04ae127ef846e1d4e7c"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classaed2_1_1iterator_1_1iterator.html#a10ed10b6d144d04ae127ef846e1d4e7c">value_type</a> = <a class="el" href="classaed2_1_1map.html#a719db98e0ff9a837610f76be33264680">map::value_type</a></td></tr>
<tr class="memdesc:a10ed10b6d144d04ae127ef846e1d4e7c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tipo de los valores recorridos. Requerido por estándar C++. <br /></td></tr>
<tr class="separator:a10ed10b6d144d04ae127ef846e1d4e7c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a91be74b60dfc3eabfa5a69d9aa068959"><td class="memItemLeft" align="right" valign="top"><a id="a91be74b60dfc3eabfa5a69d9aa068959"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classaed2_1_1iterator_1_1iterator.html#a91be74b60dfc3eabfa5a69d9aa068959">reference</a> = <a class="el" href="classaed2_1_1map.html#af4f147533b3c0207ab036c86ce13ec0d">map::reference</a></td></tr>
<tr class="memdesc:a91be74b60dfc3eabfa5a69d9aa068959"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tipo de la referencia (resultado de operator*). Requerido por estándar C++. <br /></td></tr>
<tr class="separator:a91be74b60dfc3eabfa5a69d9aa068959"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:add8c8243f6b0e3cb7b67ce06757df53b"><td class="memItemLeft" align="right" valign="top"><a id="add8c8243f6b0e3cb7b67ce06757df53b"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classaed2_1_1iterator_1_1iterator.html#add8c8243f6b0e3cb7b67ce06757df53b">pointer</a> = <a class="el" href="classaed2_1_1map.html#a7394e98a23b86bc008ad73326b273fd5">map::pointer</a></td></tr>
<tr class="memdesc:add8c8243f6b0e3cb7b67ce06757df53b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tipo del puntero (resultado de operator-&gt;). Requerido por estándar C++. <br /></td></tr>
<tr class="separator:add8c8243f6b0e3cb7b67ce06757df53b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7dc57879d054ca0168a20003c9d655b6"><td class="memItemLeft" align="right" valign="top"><a id="a7dc57879d054ca0168a20003c9d655b6"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classaed2_1_1iterator_1_1iterator.html#a7dc57879d054ca0168a20003c9d655b6">difference_type</a> = std::ptrdiff_t</td></tr>
<tr class="memdesc:a7dc57879d054ca0168a20003c9d655b6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Resultado de la diferencia entre dos punteros. Requerido por estándar C++. <br /></td></tr>
<tr class="separator:a7dc57879d054ca0168a20003c9d655b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:ae488782067dfba96b447080b0db1ed2c"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classaed2_1_1iterator_1_1iterator.html#ae488782067dfba96b447080b0db1ed2c">iterator</a> ()</td></tr>
<tr class="memdesc:ae488782067dfba96b447080b0db1ed2c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Crea un iterador nulo.  <a href="#ae488782067dfba96b447080b0db1ed2c">More...</a><br /></td></tr>
<tr class="separator:ae488782067dfba96b447080b0db1ed2c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5d87de9e96d5efd0456e8f7aec240b8d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classaed2_1_1iterator_1_1iterator.html#a91be74b60dfc3eabfa5a69d9aa068959">reference</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classaed2_1_1iterator_1_1iterator.html#a5d87de9e96d5efd0456e8f7aec240b8d">operator*</a> () const</td></tr>
<tr class="memdesc:a5d87de9e96d5efd0456e8f7aec240b8d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retorna el valor apuntado por {*this}.  <a href="#a5d87de9e96d5efd0456e8f7aec240b8d">More...</a><br /></td></tr>
<tr class="separator:a5d87de9e96d5efd0456e8f7aec240b8d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9e9f5ca8d13a6945d6520736c0cc1a4f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classaed2_1_1iterator_1_1iterator.html#add8c8243f6b0e3cb7b67ce06757df53b">pointer</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classaed2_1_1iterator_1_1iterator.html#a9e9f5ca8d13a6945d6520736c0cc1a4f">operator-&gt;</a> () const</td></tr>
<tr class="memdesc:a9e9f5ca8d13a6945d6520736c0cc1a4f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retorna la dirección del valor apuntado por {*this}.  <a href="#a9e9f5ca8d13a6945d6520736c0cc1a4f">More...</a><br /></td></tr>
<tr class="separator:a9e9f5ca8d13a6945d6520736c0cc1a4f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a457fdf0ed06c88121b441424f1c99f4f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classaed2_1_1iterator_1_1iterator.html">iterator</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classaed2_1_1iterator_1_1iterator.html#a457fdf0ed06c88121b441424f1c99f4f">operator++</a> ()</td></tr>
<tr class="memdesc:a457fdf0ed06c88121b441424f1c99f4f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Avanza el iterador a la siguiente posición.  <a href="#a457fdf0ed06c88121b441424f1c99f4f">More...</a><br /></td></tr>
<tr class="separator:a457fdf0ed06c88121b441424f1c99f4f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa2023454f3ce45f7da4ef23d7a7f6749"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classaed2_1_1iterator_1_1iterator.html">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classaed2_1_1iterator_1_1iterator.html#aa2023454f3ce45f7da4ef23d7a7f6749">operator++</a> (int)</td></tr>
<tr class="memdesc:aa2023454f3ce45f7da4ef23d7a7f6749"><td class="mdescLeft">&#160;</td><td class="mdescRight">Avanza el iterador a la siguiente posición.  <a href="#aa2023454f3ce45f7da4ef23d7a7f6749">More...</a><br /></td></tr>
<tr class="separator:aa2023454f3ce45f7da4ef23d7a7f6749"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a260692ee1d51f87ef547b4a798fc2de5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classaed2_1_1iterator_1_1iterator.html">iterator</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classaed2_1_1iterator_1_1iterator.html#a260692ee1d51f87ef547b4a798fc2de5">operator--</a> ()</td></tr>
<tr class="memdesc:a260692ee1d51f87ef547b4a798fc2de5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrocede el iterador a la posición anterior.  <a href="#a260692ee1d51f87ef547b4a798fc2de5">More...</a><br /></td></tr>
<tr class="separator:a260692ee1d51f87ef547b4a798fc2de5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6bd61026c75767d0d41e45229144e9d0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classaed2_1_1iterator_1_1iterator.html">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classaed2_1_1iterator_1_1iterator.html#a6bd61026c75767d0d41e45229144e9d0">operator--</a> (int)</td></tr>
<tr class="memdesc:a6bd61026c75767d0d41e45229144e9d0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrocede el iterador a la posición anterior.  <a href="#a6bd61026c75767d0d41e45229144e9d0">More...</a><br /></td></tr>
<tr class="separator:a6bd61026c75767d0d41e45229144e9d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a565d56436e9490edab1ea31803af34ae"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classaed2_1_1iterator_1_1iterator.html#a565d56436e9490edab1ea31803af34ae">operator==</a> (<a class="el" href="classaed2_1_1iterator_1_1iterator.html">iterator</a> other) const</td></tr>
<tr class="memdesc:a565d56436e9490edab1ea31803af34ae"><td class="mdescLeft">&#160;</td><td class="mdescRight">Operador de igualdad.  <a href="#a565d56436e9490edab1ea31803af34ae">More...</a><br /></td></tr>
<tr class="separator:a565d56436e9490edab1ea31803af34ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1c42a3d770db85a6b25abf05e7fa1683"><td class="memItemLeft" align="right" valign="top"><a id="a1c42a3d770db85a6b25abf05e7fa1683"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classaed2_1_1iterator_1_1iterator.html#a1c42a3d770db85a6b25abf05e7fa1683">operator!=</a> (<a class="el" href="classaed2_1_1iterator_1_1iterator.html">iterator</a> other) const</td></tr>
<tr class="memdesc:a1c42a3d770db85a6b25abf05e7fa1683"><td class="mdescLeft">&#160;</td><td class="mdescRight">idem !|operator== <br /></td></tr>
<tr class="separator:a1c42a3d770db85a6b25abf05e7fa1683"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="friends"></a>
Friends</h2></td></tr>
<tr class="memitem:aeda338414e516b47761f994fb78056c6"><td class="memItemLeft" align="right" valign="top"><a id="aeda338414e516b47761f994fb78056c6"></a>
class&#160;</td><td class="memItemRight" valign="bottom"><b>map</b></td></tr>
<tr class="separator:aeda338414e516b47761f994fb78056c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Parte del módulo que implementa los iteradores que permiten la modificación de los significados. </p>
<p>Cuando el iterador se encuentra asociado a un diccionario <code>d</code>, el rango válido de valores del iterador va desde el primer valor de <code>d</code> hasta una posición (ficticia) que se encuentra pasando-el-último. Esta posición no tiene definido un valor para el <code>operator*</code>, y se usa para indicar el fin del recorrido.</p>
<p>Este es un iterador que sigue el estándar de C++, y por lo tanto es compatible con la bilioteca de algoritmos. Asimismo, las operaciones siguen el protocolo estándar, con lo cual no es necesiario describir el resultado de las mismas. Sin embargo, siendo este un TP, vamos a describir el comportamiento en el marco conceptual de la materia.</p>
<dl class="section user"><dt>Aspectos generales de aliasing</dt><dd>Vale remarcar que un iterador tiene dos estados posibles:<ol type="1">
<li>Es valido: cuando esta asociado a un diccionario y apunta a un valor existente del diccionario,</li>
<li>Es inválido: cuando esta asociado a un diccionario (que quiza ya no es accesible), pero el valor al que apunta fue eliminado.</li>
<li>Es nulo: cuando no está asociado a ningún diccionario; sirve como análogo de <code>nullptr</code>. </li>
</ol>
</dd></dl>
<dl class="section user"><dt>Se explica con</dt><dd>IteradorBidireccional(Diccionario({Key}, {Meaning}), tupla({Key}, {Meaning}))</dd></dl>
<dl class="section attention"><dt>Attention</dt><dd>En caso de usar los iteradores como punteros, se desaconseja el uso de la posicion pasando-el-ultimo como valor nulo, ya que queda invalidada luego de aplicar la operación <a class="el" href="classaed2_1_1map.html#a43ddb71cc91e5c6021a7a1f243d6cc4a" title="Intercambia el contenido de {*this} y {other}. ">aed2::map::swap</a>. Conviene usar el iterador nulo (que, lamentablemente, es independiente del diccionario).</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a href="http://en.cppreference.com/w/cpp/concept/BidirectionalIterator">Documentacion estándar de iteradores bidireccionales</a> </dd></dl>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="ae488782067dfba96b447080b0db1ed2c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae488782067dfba96b447080b0db1ed2c">&#9670;&nbsp;</a></span>iterator()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">aed2::iterator::iterator::iterator </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Crea un iterador nulo. </p>
<p>Hay dos razones para permitir la existencia de iteradores nulos. La primera, más trivial, es permitir la declaracion de iteradores sin necesariamente asignarles un valor inicial. Por ejemplo </p><div class="fragment"><div class="line"><a class="code" href="classaed2_1_1map_1_1iterator.html">aed2::map::iterator</a> it;   <span class="comment">//iterador invalido</span></div><div class="line"><span class="keywordflow">if</span>(...) {</div><div class="line">  it = d.<a class="code" href="classaed2_1_1map.html#ac412d3902112122c1bffe2d4283a4e9d">rbegin</a>();</div><div class="line">} <span class="keywordflow">else</span> {</div><div class="line">  it = d.<a class="code" href="classaed2_1_1map.html#a277f03b4f4b6b98879e4e4921081801f">rend</a>();</div><div class="line">}</div></div><!-- fragment --><p> El segundo motivo, más esencial, es permitir el uso de iteradores como <em>handles</em> (punteros). En este caso, y teniendo en cuenta que el puntero pasando-el-último podría invalidarse, el iterador nulo nos brinda una forma conveniente de representar el puntero nulo.</p>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">res</td><td>iterador recién creado</td></tr>
  </table>
  </dd>
</dl>
<p>{El iterador {res} no está asociado a ningún diccionario.}</p>
<dl class="section pre"><dt>Precondition</dt><dd>{true} </dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd>{coleccion({res})    vacia?(SecuSuby({res}))}</dd></dl>
<p>{(1)}</p>
<p>Inicia un iterador apuntando a nullptr. </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a5d87de9e96d5efd0456e8f7aec240b8d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5d87de9e96d5efd0456e8f7aec240b8d">&#9670;&nbsp;</a></span>operator*()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classaed2_1_1iterator_1_1iterator.html#a91be74b60dfc3eabfa5a69d9aa068959">reference</a> aed2::iterator::iterator::operator* </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Retorna el valor apuntado por {*this}. </p>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">res</td><td>referencia al valor apuntado por {*this}</td></tr>
  </table>
  </dd>
</dl>
<p>{hay aliasing entre res y Siguiente(*this)}</p>
<dl class="section pre"><dt>Precondition</dt><dd>{Siguiente(this) != nullptr} </dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd>{res  Siguiente(*this)}</dd></dl>
<p>{(1)}</p>
<p>Devuelve el elemento del nodo al que está apuntando el iterador. </p>

</div>
</div>
<a id="a457fdf0ed06c88121b441424f1c99f4f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a457fdf0ed06c88121b441424f1c99f4f">&#9670;&nbsp;</a></span>operator++() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classaed2_1_1iterator_1_1iterator.html">iterator</a>&amp; aed2::iterator::iterator::operator++ </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Avanza el iterador a la siguiente posición. </p>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">res</td><td>referencia a {*this}</td></tr>
  </table>
  </dd>
</dl>
<p>{no hay}</p>
<dl class="section pre"><dt>Precondition</dt><dd>{HaySiguiente?(*this)} </dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd>{res  Avanzar(*this)}</dd></dl>
<p>{</p><ul>
<li>Peor caso: ((SIZE(<em>d</em>)) donde <em>d</em> es el diccionario asociado a {*this}.</li>
<li>Peor caso amortizado: (1) }</li>
</ul>
<p>Avanza el iterador en una posición y lo devuelve. </p>

</div>
</div>
<a id="aa2023454f3ce45f7da4ef23d7a7f6749"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa2023454f3ce45f7da4ef23d7a7f6749">&#9670;&nbsp;</a></span>operator++() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classaed2_1_1iterator_1_1iterator.html">iterator</a> aed2::iterator::iterator::operator++ </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Avanza el iterador a la siguiente posición. </p>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">res</td><td>iterador apuntando a la dirección anterior de {*this}</td></tr>
  </table>
  </dd>
</dl>
<p>{no hay}</p>
<dl class="section pre"><dt>Precondition</dt><dd>{HaySiguiente?(*this)} </dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd>{CONSULTAR}</dd></dl>
<p>{</p><ul>
<li>Peor caso: ((SIZE(<em>d</em>)) donde <em>d</em> es el diccionario asociado a {*this}.</li>
<li>Peor caso amortizado: (1) }</li>
</ul>
<p>CONSULTAR. </p>

</div>
</div>
<a id="a260692ee1d51f87ef547b4a798fc2de5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a260692ee1d51f87ef547b4a798fc2de5">&#9670;&nbsp;</a></span>operator--() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classaed2_1_1iterator_1_1iterator.html">iterator</a>&amp; aed2::iterator::iterator::operator-- </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Retrocede el iterador a la posición anterior. </p>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">res</td><td>referencia a {*this}</td></tr>
  </table>
  </dd>
</dl>
<p>{no hay}</p>
<dl class="section pre"><dt>Precondition</dt><dd>{HayAnterior?(*this)} </dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd>{res  Retroceder(*this)}</dd></dl>
<p>{</p><ul>
<li>Peor caso: ((SIZE(<em>d</em>)) donde <em>d</em> es el diccionario asociado a {*this}.</li>
<li>Peor caso amortizado: (1) }</li>
</ul>
<p>Retrocede el iterador en una posicion y lo devuelve. </p>

</div>
</div>
<a id="a6bd61026c75767d0d41e45229144e9d0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6bd61026c75767d0d41e45229144e9d0">&#9670;&nbsp;</a></span>operator--() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classaed2_1_1iterator_1_1iterator.html">iterator</a> aed2::iterator::iterator::operator-- </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Retrocede el iterador a la posición anterior. </p>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">res</td><td>iterador apuntando a la dirección siguiente de {*this}</td></tr>
  </table>
  </dd>
</dl>
<p>{no hay}</p>
<dl class="section pre"><dt>Precondition</dt><dd>{HayAnterior?(*this)} </dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd>{completar}</dd></dl>
<p>{</p><ul>
<li>Peor caso: ((SIZE(<em>d</em>)) donde <em>d</em> es el diccionario asociado a {*this}.</li>
<li>Peor caso amortizado: (1) }</li>
</ul>
<p>CONSULTAR </p>

</div>
</div>
<a id="a9e9f5ca8d13a6945d6520736c0cc1a4f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9e9f5ca8d13a6945d6520736c0cc1a4f">&#9670;&nbsp;</a></span>operator->()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classaed2_1_1iterator_1_1iterator.html#add8c8243f6b0e3cb7b67ce06757df53b">pointer</a> aed2::iterator::iterator::operator-&gt; </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Retorna la dirección del valor apuntado por {*this}. </p>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">res</td><td>puntero al valor apuntado por {*this}</td></tr>
  </table>
  </dd>
</dl>
<p>{hay aliasing entre res y Siguiente(*this)}</p>
<dl class="section pre"><dt>Precondition</dt><dd>{haySiguiente({*this})} </dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd>{{*res}  siguiente({*this})}</dd></dl>
<p>{(1)}</p>
<dl class="section attention"><dt>Attention</dt><dd>No hay forma de expresar, en el lenguaje de TADs, que un puntero apunta a la dirección de otro objeto. Es por eso que la postcondición es más débil de lo que debiera. Eso no ocurre en las otras funciones del TP.</dd></dl>
<p>Devuelve la posición de memoria del valor del nodo al que está apuntando el iterador. </p>

</div>
</div>
<a id="a565d56436e9490edab1ea31803af34ae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a565d56436e9490edab1ea31803af34ae">&#9670;&nbsp;</a></span>operator==()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool aed2::iterator::iterator::operator== </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classaed2_1_1iterator_1_1iterator.html">iterator</a>&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Operador de igualdad. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>iterador a comparar </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">res</td><td>indica si {*this} apunta al mismo valor que {other}</td></tr>
  </table>
  </dd>
</dl>
<p>{No es necesario que {*this} y {other} estén asociados al mismo diccionario. Si no lo están, el resultado esta:</p><ul>
<li>indeterminado, cuando alguno de ellos es inválido,</li>
<li>false, cuando alguno de ellos es no nulo, o</li>
<li>true, cuando ambos son nulos.}</li>
</ul>
<dl class="section pre"><dt>Precondition</dt><dd>{true} </dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd>{res  (*this  other)}</dd></dl>
<p>{(1)}</p>
<p>Devuelve true si el nodo al que apunta this es el mismo que al que apunta other. (Consultar) </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li><a class="el" href="map2_8h_source.html">map2.h</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.14
</small></address>
</body>
</html>
