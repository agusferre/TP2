\-En esta pagina, y por conveniencia, se listan todos los axiomas y proposiciones auxiliares requeridos para formalizar los invariantes de representación y las funciones de abstracción. \-Previamente se presentan los renombres de los tipos usados.

\begin{DoxyParagraph}{\-Renombres de tipos}

\end{DoxyParagraph}

\begin{DoxyItemize}
\item \-Node es tupla(child\-: arreglo\mbox{[}2\mbox{]} de puntero(\-Node), parent\-: puntero(\-Node), color\-: \-Color, value\-: \-Value)
\item \-Value es \-Maybe(value\-\_\-type)
\item value\-\_\-type es tupla(clave\-: \-Key, significado\-: \-Meaning)
\end{DoxyItemize}

\-El \-T\-A\-D \-Maybe( $\alpha$) representa un tipo $\alpha$ extendido con un valor nulo. \-En otras palabras, el \-T\-A\-D \-Maybe se puede usar para representar los valores de los nodos, donde el nodo cabecera no tiene valor y los nodos internos sí tienen valor. (\-Esto independientemente de si se implementa con herencia o con un puntero o de otra forma.) \-Tiene dos observadores\-:
\begin{DoxyItemize}
\item nothing?(x)\-: que indica si x tiene un valor nulo, y
\item data(x)\-: que devuelve el valor de x, suponiendo que no es inválido.
\end{DoxyItemize}

\-La especificación de este \-T\-A\-D queda como ejercicio (no obligatorio).\hypertarget{axiomas_sec-Axiomas}{}\subsection{\-Axiomas y proposiciones auxiliares}\label{axiomas_sec-Axiomas}
\-En esta sección se deben incluir todos los axiomas y proposiciones auxiliares que se usen para describir los invariantes de representación, las funciones de abstracción, las precondiciones y las postcondiciones.

\begin{DoxyRemark}{\-Comentarios}
\-Recordar incluir un alias en el archivo doxyfile a fin de poder referenciar automaticamente a cada axioma desde las otras páginas.
\end{DoxyRemark}
\-Se muestran algunos ejemplos a continuación.

\begin{DoxyParagraph}{es\-Diccionario?}
\-Retorna true si la secuencia representa un diccionario
\end{DoxyParagraph}
es\-Diccionario?\-: secu(tupla( $\alpha$, $\beta$)) $\to$ bool\par
 es\-Diccionario?(s) $\equiv$ sin\-Repetidos?(\href{axiomas.html#primeros}{\tt primeros}(s)) 

\begin{DoxyParagraph}{primeros}
\-Proyecta las primeras componentes de una secuencia de pares
\end{DoxyParagraph}
primeros\-: secu(tupla( $\alpha$, $\beta$)) $\to$ secu( $\alpha$)\par
 primeros(s) $\equiv$ {\bfseries if} vacia?(s) {\bfseries then} $<$$>$ {\bfseries else} $\pi_1$(prim(s)) $\bullet$ \href{axiomas.html#primeros}{\tt primeros}(fin(s)) {\bfseries fi} 

$\backslash$ $\ast$$\ast$ \-Auxiliares para pre y post $\ast$$\ast$ // \begin{DoxyParagraph}{\-Dicc\-Secu}
\-Devuelve una secuencia ordenada con elementos del diccionario.
\end{DoxyParagraph}
\-Dicc\-Secu\-: \-Conj( $\alpha$, $\beta$) $\to$ secu( $\alpha$, $\beta$)\par
 \-Dicc\-Secu(elems) $\equiv$ {\bfseries if} $\emptyset$ ?(elems) {\bfseries then} $<$ $>$ {\bfseries else} \-Dicc\-Secu(elems -\/ minimo(elems)) $\bot$ dame\-Uno(elems) {\bfseries fi} 

\begin{DoxyParagraph}{\-Menor\-Que}
\-Devuelve true si y solo si m1 es lexicograficamente menor que m2.
\end{DoxyParagraph}
\-Menor\-Que\-: \-Dicc( $\alpha$, $\beta$) d1 x \-Dicc( $\alpha$, $\beta$) d2 $\to$ bool\par
 \-Menor\-Que(d1, d2) $\equiv$ comparar\-Claves(claves(d1), claves(d2)) 

\begin{DoxyParagraph}{comparar\-Elems}
comparar\-Elems\-: \-Conj( $\alpha$, $\beta$) cs1 x \-Conj( $\alpha$, $\beta$) cs2 $\to$ bool\par
 comparar\-Elems(cs1, cs2) $\equiv$ {\bfseries if} \# cs1 = 0 {\bfseries then} true {\bfseries else} {\bfseries if} (\# cs2 = 0 $\lor$ $\pi_1$(minimo(cs1)) $>$ $\pi_1$(minimo(cs2)) $|$$|$ $\pi_2$(minimo(cs1)) $>$ $\pi_2$(minimo(cs2))) {\bfseries then} false {\bfseries fi} {\bfseries else} comparar\-Elems(cs1 -\/ \{minimo\}, cs2 -\/ \{minimo\}) {\bfseries fi} 
\end{DoxyParagraph}
\-Proposiciones para \-Rep y \-Abs

\begin{DoxyParagraph}{header\-Valido}
\-El nodo header no tiene valor. \-Su padre es la raíz, de color negro, y sus hijos derecho e izquierdo son el mayor y el menor valor del arbol respectivamente.\par

\end{DoxyParagraph}
e.\-header.\-color == \-Header $\land$ nothing?(e.\-header.\-value) $\land$ e.\-header.\-parent.\-color == \-Black $\land$ ((e.\-count == 0 $\land$ e.\-header.\-child\mbox{[}0\mbox{]} == header) $\lor$ (e.\-count $>$ 0 $\Rightarrow_{\rm L}$ $\ast$e.header.\-child\mbox{[}0\mbox{]} = minimo(\-Map\-A\-Conjunto(e)))) $\land$ ((e.\-count == 0 $\land$ e.\-header.\-child\mbox{[}1\mbox{]} == header) $\lor$ (e.\-count $>$ 0 $\Rightarrow_{\rm L}$ $\ast$e.header.\-child\mbox{[}1\mbox{]} = maximo(\-Map\-A\-Conjunto(e)))) 

\begin{DoxyParagraph}{nodos\-Internos\-Validos}
\-Para cada nodo interno, sus ramas descendientes tienen la misma cantidad de nodos negros, y y el subarbol que tiene como raiz ese nodo cumple el invariante de \-Arbol binario de busqueda. \-Si es rojo, su o sus hijos son negros.
\end{DoxyParagraph}
( $\forall$ n\-: \-Node) \-Nodo\-Hijo(n, e.\-header) $\Rightarrow$ ((get(n.\-child\mbox{[}0\mbox{]}) = 0 $\lor$ n.\-chiild\mbox{[}0\mbox{]}.color = \-Black) $\land$ (get(n.\-child\mbox{[}1\mbox{]}) = 0 $\lor$ n.\-chiild\mbox{[}1\mbox{]}.color = \-Black) $\land$ nodos\-Negros(n.\-child\mbox{[}0\mbox{]}) = nodos\-Negros(n.\-child\mbox{[}1\mbox{]}) $\land$ arbol\-Binario\-De\-Busqueda(n)) 

\begin{DoxyParagraph}{arbol\-Binario\-De\-Busqueda}
\-Todos los nodos de la rama izquierda de n tienen valor menor al de n y todos los de la derecha, mayor. (( $\forall$ n'\-:\-Node) (\-Nodo\-Hijo(n', n) $\land$ \-Nodo\-Hijo(n', n.\-child\mbox{[}0\mbox{]})) $\Rightarrow$ n'.value.\-clave $<$ n.\-value.\-clave ) $\land$ (( $\forall$ n'\-:\-Node) (\-Nodo\-Hijo(n', n) $\land$ \-Nodo\-Hijo(n', n.\-child\mbox{[}1\mbox{]})) $\Rightarrow$ n'.value.\-clave $>$ n.\-value.\-clave ) 
\end{DoxyParagraph}
\begin{DoxyParagraph}{nodos\-Negros}

\end{DoxyParagraph}
nodos\-Negros \-: puntero(\-Node) $\to$ int\par
 \-Devuelve la cantidad de nodos negros en un subarbol. nodos\-Negros(n) $\equiv$ {\bfseries if} get(n) = 0 $\lor_{\rm L}$ n.\-color = \-Red {\bfseries then} 0 {\bfseries else} 1 {\bfseries fi} + nodos\-Negros(n.\-child\mbox{[}0\mbox{]}) + nodos\-Negros(n.\-child\mbox{[}1\mbox{]}) 

\-Auxiliares para \-Rep y \-Abs

\begin{DoxyParagraph}{nodo\-Hijo}
\-Devuelve true si el n1 es hijo de n2 en la estructura.
\end{DoxyParagraph}
nodo\-Hijo \-: \-Node n1 x \-Node n2 $\to$ bool\par
 nodo\-Hijo(n, h) $\equiv$ $\lnot$ nothing?(n.\-value) $\land_{\rm L}$ (n.\-parent = e.\-header $\lor$ nodo\-Hijo($\ast$n.parent, e)) 

\begin{DoxyParagraph}{llegar\-A\-Header}
\-Dado un puntero nodo (de un arbol), devuelve un puntero al header.
\end{DoxyParagraph}
\{llegar\-Al\-Header\}\-: puntero(\-Node) $\to$ puntero(\-Node)\{get(n)  0\}\par
 (n) $\equiv$ {\bfseries if} ($\ast$n) = \-Header {\bfseries then} n {\bfseries else} llegar\-Al\-Header( $\pi_2$($\ast$n)) {\bfseries fi} 

\begin{DoxyParagraph}{\-Map\-A\-Conjunto}
\-Crea un conjunto con los elementos de map.\par

\end{DoxyParagraph}
\-Map\-A\-Conjunto\-: \-Node n $\to$ \-Conj( $\alpha$)\par
 \-Map\-A\-Conjunto(n) $\equiv$ {\bfseries if} n.\-color = \-Header {\bfseries then} \-Map\-A\-Conjunto($\ast$ $\pi_2$(n)) {\bfseries else} \{$\ast$n\} $\cup$ {\bfseries if} get(n.\-child\mbox{[}0\mbox{]})  0 {\bfseries then} \-Map\-A\-Conjunto($\ast$n.child\mbox{[}0\mbox{]}) {\bfseries fi} $\cup$ {\bfseries if} get(n.\-child\mbox{[}1\mbox{]})  0 {\bfseries then} \-Map\-A\-Conjunto($\ast$n.child\mbox{[}1\mbox{]}) {\bfseries fi} {\bfseries fi} 

\begin{DoxyParagraph}{\-Encontrar\-Valor}

\end{DoxyParagraph}
\-Encontrar\-Valor \-: \-Puntero(\-Node) n x $\alpha$ key $\to$ $\beta$ \{get(n)  0\}\par
 \-Encontrar\-Valor(n, key) $\equiv$ {\bfseries if} $\pi_1$($\ast$n) = key {\bfseries then} $\pi_2$($\ast$n) {\bfseries else} {\bfseries if} $\pi_1$($\ast$n) $<$ key {\bfseries then} \-Encontrar\-Valor(n.\-child\mbox{[}1\mbox{]}, key) {\bfseries else} \-Encontrar\-Valor(n.\-child\mbox{[}0\mbox{]}) {\bfseries fi} {\bfseries fi} 

\begin{DoxyParagraph}{minimo}
\-Devuelve el elemento del diccionario con la menor clave \par
 minimo\-: \-Conj( $\alpha$, $\beta$) $\to$ ( $\alpha$, $\beta$) \{ $\lnot$ $\emptyset$?(elems)\}\par
 minimo(elems) $\equiv$ minimo\-Aux(elems, $\pi_1$(dame\-Uno(elems))) 
\end{DoxyParagraph}
\begin{DoxyParagraph}{minimo\-Aux}
minimo\-Aux\-: \-Conj( $\alpha$, $\beta$) x ( $\alpha$, $\beta$) $\to$ ( $\alpha$, $\beta$)\par
 minimo\-Aux(elems, e) $\equiv$ {\bfseries if} \#elems = 0 {\bfseries then} e {\bfseries else} {\bfseries if} e $>$ $\pi_1$(dame\-Uno(elems)) {\bfseries then} minimo\-Aux(sin\-Uno(elems), e) {\bfseries else} minimo\-Aux(sin\-Uno(elems), dame\-Uno(elems)) {\bfseries fi} 
\end{DoxyParagraph}
\begin{DoxyParagraph}{maximo}
\-Devuelve el elemento del diccionario con la menor clave\par
 maximo\-: \-Conj( $\alpha$, $\beta$) $\to$ ( $\alpha$, $\beta$) \{ $\lnot$ $\emptyset$?(elems)\}\par
 maximo(elems) $\equiv$ maximo\-Aux(elems, $\pi_1$(dame\-Uno(elems))) 
\end{DoxyParagraph}
\begin{DoxyParagraph}{maximo\-Aux}
maximo\-Aux\-: \-Conj( $\alpha$, $\beta$) x ( $\alpha$, $\beta$) $\to$ ( $\alpha$, $\beta$)\par
 maximo\-Aux(elems, e) $\equiv$ {\bfseries if} \#elems = 0 {\bfseries then} e {\bfseries else} {\bfseries if} e $>$ $\pi_1$(dame\-Uno(elems)) {\bfseries then} maximo\-Aux(sin\-Uno(elems), e) {\bfseries else} maximo\-Aux(sin\-Uno(elems), dame\-Uno(elems)) {\bfseries fi}  
\end{DoxyParagraph}
