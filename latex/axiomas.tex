En esta pagina, y por conveniencia, se listan todos los axiomas y proposiciones auxiliares requeridos para formalizar los invariantes de representación y las funciones de abstracción. Previamente se presentan los renombres de los tipos usados.

\begin{DoxyParagraph}{Renombres de tipos}

\end{DoxyParagraph}

\begin{DoxyItemize}
\item Node es tupla(child\+: arreglo\mbox{[}2\mbox{]} de puntero(\+Node), parent\+: puntero(\+Node), color\+: Color, value\+: Value)
\item Value es Maybe(value\+\_\+type)
\item value\+\_\+type es tupla(clave\+: Key, significado\+: Meaning)
\end{DoxyItemize}

El T\+AD Maybe( $\alpha$) representa un tipo $\alpha$ extendido con un valor nulo. En otras palabras, el T\+AD Maybe se puede usar para representar los valores de los nodos, donde el nodo cabecera no tiene valor y los nodos internos sí tienen valor. (Esto independientemente de si se implementa con herencia o con un puntero o de otra forma.) Tiene dos observadores\+:
\begin{DoxyItemize}
\item nothing?(x)\+: que indica si x tiene un valor nulo, y
\item data(x)\+: que devuelve el valor de x, suponiendo que no es inválido.
\end{DoxyItemize}

La especificación de este T\+AD queda como ejercicio (no obligatorio).\hypertarget{axiomas_sec-Axiomas}{}\subsection{Axiomas y proposiciones auxiliares}\label{axiomas_sec-Axiomas}
En esta sección se deben incluir todos los axiomas y proposiciones auxiliares que se usen para describir los invariantes de representación, las funciones de abstracción, las precondiciones y las postcondiciones.

\begin{DoxyRemark}{Comentarios}
Recordar incluir un alias en el archivo doxyfile a fin de poder referenciar automaticamente a cada axioma desde las otras páginas.
\end{DoxyRemark}
Se muestran algunos ejemplos a continuación.

\begin{DoxyParagraph}{es\+Diccionario?}
Retorna true si la secuencia representa un diccionario

es\+Diccionario?\+: secu(tupla( $\alpha$, $\beta$)) $\to$ bool~\newline
es\+Diccionario?(s) $\equiv$ sin\+Repetidos?(\href{axiomas.html#primeros}{\tt primeros}(s)) 
\end{DoxyParagraph}


\begin{DoxyParagraph}{primeros}
Proyecta las primeras componentes de una secuencia de pares

primeros\+: secu(tupla( $\alpha$, $\beta$)) $\to$ secu( $\alpha$)~\newline
primeros(s) $\equiv$ {\bfseries if} vacia?(s) {\bfseries then} $<$$>$ {\bfseries else} $\pi_1$(prim(s)) $\bullet$ \href{axiomas.html#primeros}{\tt primeros}(fin(s)) {\bfseries fi} 
\end{DoxyParagraph}


\textbackslash{} $\ast$$\ast$ Auxiliares para pre y post $\ast$$\ast$ // \begin{DoxyParagraph}{Dicc\+A\+Secu}
Devuelve una secuencia ordenada con elementos del diccionario.

Dicc\+A\+Secu\+: Dicc( $\alpha$, $\beta$) $\to$ secu( $\alpha$, $\beta$)~\newline
Dicc\+A\+Secu(d) $\equiv$ Por\+Clave(claves(d), d) 
\end{DoxyParagraph}


\begin{DoxyParagraph}{Por\+Clave}
Recorre las claves del diccionario para devolver la secuencia ordenada con sus valores. Por\+Clave\+: Conj( $\alpha$) x Dicc( $\alpha$, $\beta$) $\to$ secu( $\alpha$, $\beta$)~\newline
Por\+Clave(cs, d) $\equiv$ {\bfseries if} $\emptyset$ ?(cs) {\bfseries then} $<$ $>$ {\bfseries else} $\langle$ minimo(cs) , obtener(minimo(cs), d) $\rangle$ $\bullet$ Por\+Clave(cs -\/ \{minimo(cs)\}, d) {\bfseries fi} 
\end{DoxyParagraph}


\begin{DoxyParagraph}{Menor\+Que}
Devuelve true si y solo si m1 es lexicograficamente menor que m2.

Menor\+Que\+: Dicc( $\alpha$, $\beta$) d1 x Dicc( $\alpha$, $\beta$) d2 $\to$ bool~\newline
Menor\+Que(d1, d2) $\equiv$ comparar\+Claves(claves(d1), claves(d2)) 
\end{DoxyParagraph}


\begin{DoxyParagraph}{comparar\+Elems}
comparar\+Elems\+: Conj( $\alpha$, $\beta$) cs1 x Conj( $\alpha$, $\beta$) cs2 $\to$ bool~\newline
comparar\+Elems(cs1, cs2) $\equiv$ {\bfseries if} \# cs1 = 0 {\bfseries then} true {\bfseries else} {\bfseries if} (\# cs2 = 0 $\lor$ $\pi_1$(minimo(cs1)) $>$ $\pi_1$(minimo(cs2)) $\vert$$\vert$ (minimo(cs1)) $>$ (minimo(cs2))) {\bfseries then} false {\bfseries fi} {\bfseries else} comparar\+Elems(cs1 -\/ \{minimo\}, cs2 -\/ \{minimo\}) {\bfseries fi} 
\end{DoxyParagraph}


Proposiciones para Rep y Abs

\begin{DoxyParagraph}{header\+Valido}
El nodo header no tiene valor. Su padre es la raíz, de color negro, y sus hijos derecho e izquierdo son el mayor y el menor valor del arbol respectivamente.~\newline
header\+Valido\+: node n $\to$ bool~\newline
header\+Valido(n) $\equiv$ \mbox{[}n.\+color == Header $\land$ nothing?(n.\+value) $\land$ n.\+parent.\+color == Black $\land$ (n.\+parent == N\+U\+LL $\land$ (n.\+child\mbox{[}0\mbox{]} == \&header) $\lor$ (n.\+parent != N\+U\+LL $\Rightarrow_{\rm L}$ n.\+child\mbox{[}0\mbox{]} == llegar\+A\+Minimo(n.\+parent)) $\land$ (n.\+parent == N\+U\+LL $\land$ (n.\+child\mbox{[}1\mbox{]} == \&header) $\lor$ (n.\+parent != N\+U\+LL $\Rightarrow_{\rm L}$ n.\+child\mbox{[}1\mbox{]} == llegar\+A\+Maximo(n.\+parent))\mbox{]} 
\end{DoxyParagraph}


\begin{DoxyParagraph}{llegar\+A\+Minimo}
Devuelve un puntero al minimo nodo del subarbol cuya raiz es el nodo parametro. llegar\+A\+Minimo\+: puntero(node) n $\to$ puntero(node)~\newline
llegar\+A\+Minimo(n) $\equiv$ {\bfseries if} n.\+child\mbox{[}0\mbox{]} == N\+U\+LL {\bfseries then} n {\bfseries else} llegar\+A\+Minimo(n.\+child\mbox{[}0\mbox{]}) {\bfseries fi} 
\end{DoxyParagraph}


\begin{DoxyParagraph}{llegar\+A\+Maximo}
Devuelve un puntero al minimo nodo del subarbol cuya raiz es el nodo parametro. llegar\+A\+Maximo\+: puntero(node) n $\to$ puntero(node)~\newline
llegar\+A\+Minimo(n) $\equiv$ {\bfseries if} n.\+child\mbox{[}1\mbox{]} == N\+U\+LL {\bfseries then} n {\bfseries else} llegar\+A\+Minimo(n.\+child\mbox{[}1\mbox{]}) {\bfseries fi} 
\end{DoxyParagraph}


\begin{DoxyParagraph}{tiene\+Header}
tiene\+Header\+: puntero(node) n $\to$ bool~\newline
tiene\+Header(n) $\equiv$ nothing?(n) $\lor$ ( $\lnot$ get(n.\+parent) = 0 $\land$ tiene\+Header(n.\+parent)) 
\end{DoxyParagraph}


\begin{DoxyParagraph}{nodos\+Internos\+Validos}
Para cada nodo interno, sus ramas descendientes tienen la misma cantidad de nodos negros, y y el subarbol que tiene como raiz ese nodo cumple el invariante de Arbol binario de busqueda. Si es rojo, su o sus hijos son negros.

( $\forall$ n\+: Node) nodo\+Hijo(n, e.\+header) $\Rightarrow$ ((get(n.\+child\mbox{[}0\mbox{]}) = 0 $\lor_{\rm L}$ n.\+chiild\mbox{[}0\mbox{]}.color = Black) $\land$ (get(n.\+child\mbox{[}1\mbox{]}) = 0 $\lor_{\rm L}$ n.\+chiild\mbox{[}1\mbox{]}.color = Black) $\land$ nodos\+Negros(n.\+child\mbox{[}0\mbox{]}) = nodos\+Negros(n.\+child\mbox{[}1\mbox{]}) $\land$ arbol\+Binario\+De\+Busqueda(n)) 
\end{DoxyParagraph}


\begin{DoxyParagraph}{arbol\+Binario\+De\+Busqueda}
Todos los nodos de la rama izquierda de n tienen valor menor al de n y todos los de la derecha, mayor. arbol\+Binario\+De\+Busqueda\+: puntero(node) n $\to$ bool ~\newline
arbol\+Binario\+De\+Busqueda(n) $\equiv$ (n-\/$>$child\mbox{[}0\mbox{]}) == N\+U\+LL $\lor_{\rm L}$ (n-\/$>$child\mbox{[}0\mbox{]}-\/$>$value $<$ n-\/$>$value $\land$ arbol\+Binario\+De\+Busqueda(n-\/$>$child\mbox{[}0\mbox{]}))) $\land$ (n-\/$>$child\mbox{[}0\mbox{]}) == N\+U\+LL $\lor_{\rm L}$ (n-\/$>$child\mbox{[}0\mbox{]}-\/$>$value $>$ n-\/$>$value $\land$ arbol\+Binario\+De\+Busqueda(n-\/$>$child\mbox{[}0\mbox{]}))) 
\end{DoxyParagraph}


\begin{DoxyParagraph}{nodos\+Negros}


nodos\+Negros \+: puntero(\+Node) $\to$ int~\newline
Devuelve la cantidad de nodos negros en un subarbol. nodos\+Negros(n) $\equiv$ {\bfseries if} n == N\+U\+LL $\lor_{\rm L}$ n.\+color = Red {\bfseries then} 0 {\bfseries else} 1 {\bfseries fi} + nodos\+Negros(n.\+child\mbox{[}0\mbox{]})
\begin{DoxyItemize}
\item nodos\+Negros(n.\+child\mbox{[}1\mbox{]}) 
\end{DoxyItemize}
\end{DoxyParagraph}


\begin{DoxyVerb}Auxiliares para Rep y Abs
\end{DoxyVerb}


\begin{DoxyParagraph}{nodo\+Hijo}
Devuelve true si el n1 es hijo de n2 en la estructura.

nodo\+Hijo \+: Node n1 x Node n2 $\to$ bool~\newline
nodo\+Hijo(n, h) $\equiv$ $\lnot$ get(n.\+parent) = 0 $\land$ ($\ast$n.parent = n2 $\lor$ nodo\+Hijo($\ast$n.parent, n2)) 
\end{DoxyParagraph}


\begin{DoxyParagraph}{llegar\+Al\+Header}
Dado un puntero a nodo (de un arbol), devuelve un puntero al header.

\{llegar\+Al\+Header\}\+: puntero(\+Node) $\to$ puntero(\+Node)\{n $\_linebr eq$ N\+U\+LL\}~\newline
(n) $\equiv$ {\bfseries if} ($\ast$n) = Header {\bfseries then} n {\bfseries else} llegar\+Al\+Header(($\ast$n)) {\bfseries fi} 


\end{DoxyParagraph}
\begin{DoxyParagraph}{Map\+A\+Conjunto}
Crea un conjunto con los elementos de map.~\newline
 Map\+A\+Conjunto\+: Node n $\to$ Conj( $\alpha$)~\newline
Map\+A\+Conjunto(n) $\equiv$ {\bfseries if} n.\+color = Header {\bfseries then} Map\+A\+Conjunto($\ast$ (n)) {\bfseries else} \{$\ast$n\} $\cup$ {\bfseries if} get(n.\+child\mbox{[}0\mbox{]}) $\_linebr eq$ 0 {\bfseries then} Map\+A\+Conjunto($\ast$n.child\mbox{[}0\mbox{]}) {\bfseries fi} $\cup$ {\bfseries if} get(n.\+child\mbox{[}1\mbox{]}) $\_linebr eq$ 0 {\bfseries then} Map\+A\+Conjunto($\ast$n.child\mbox{[}1\mbox{]}) {\bfseries fi} {\bfseries fi} 
\end{DoxyParagraph}


\begin{DoxyParagraph}{Encontrar\+Valor}


Encontrar\+Valor \+: Puntero(\+Node) n x $\alpha$ key $\to$ $\beta$ \{get(n) $\_linebr eq$ 0\}~\newline
Encontrar\+Valor(n, key) $\equiv$ {\bfseries if} $\pi_1$($\ast$n) = key {\bfseries then} ($\ast$n) {\bfseries else} {\bfseries if} $\pi_1$($\ast$n) $<$ key {\bfseries then} Encontrar\+Valor(n.\+child\mbox{[}1\mbox{]}, key) {\bfseries else} Encontrar\+Valor(n.\+child\mbox{[}0\mbox{]}) {\bfseries fi} {\bfseries fi} 
\end{DoxyParagraph}


\begin{DoxyParagraph}{minimo}
Devuelve el elemento del diccionario con la menor clave ~\newline
minimo\+: Conj( $\alpha$, $\beta$) $\to$ ( $\alpha$, $\beta$) \{ $\lnot$ $\emptyset$?(elems)\}~\newline
minimo(elems) $\equiv$ minimo\+Aux(elems, $\pi_1$(dame\+Uno(elems))) 
\end{DoxyParagraph}


\begin{DoxyParagraph}{minimo\+Aux}
minimo\+Aux\+: Conj( $\alpha$, $\beta$) x ( $\alpha$, $\beta$) $\to$ ( $\alpha$, $\beta$)~\newline
minimo\+Aux(elems, e) $\equiv$ {\bfseries if} \#elems = 0 {\bfseries then} e {\bfseries else} {\bfseries if} e $>$ $\pi_1$(dame\+Uno(elems)) {\bfseries then} minimo\+Aux(sin\+Uno(elems), e) {\bfseries else} minimo\+Aux(sin\+Uno(elems), dame\+Uno(elems)) {\bfseries fi} 
\end{DoxyParagraph}


\begin{DoxyParagraph}{maximo}
Devuelve el elemento del diccionario con la menor clave~\newline
maximo\+: Conj( $\alpha$, $\beta$) $\to$ ( $\alpha$, $\beta$) \{ $\lnot$ $\emptyset$?(elems)\}~\newline
maximo(elems) $\equiv$ maximo\+Aux(elems, $\pi_1$(dame\+Uno(elems))) 
\end{DoxyParagraph}


\begin{DoxyParagraph}{maximo\+Aux}
maximo\+Aux\+: Conj( $\alpha$, $\beta$) x ( $\alpha$, $\beta$) $\to$ ( $\alpha$, $\beta$)~\newline
maximo\+Aux(elems, e) $\equiv$ {\bfseries if} \#elems = 0 {\bfseries then} e {\bfseries else} {\bfseries if} e $>$ $\pi_1$(dame\+Uno(elems)) {\bfseries then} maximo\+Aux(sin\+Uno(elems), e) {\bfseries else} maximo\+Aux(sin\+Uno(elems), dame\+Uno(elems)) {\bfseries fi} 
\end{DoxyParagraph}
